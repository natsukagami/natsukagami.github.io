<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kagami&#39;s Blog</title>
  
  <subtitle>IOI Medalist, osu! lover, I tryhard everything.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.nkagami.me/"/>
  <updated>2018-09-08T01:31:58.130Z</updated>
  <id>http://blog.nkagami.me/</id>
  
  <author>
    <name>Natsu Kagami</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018-09-07 Brainstorm</title>
    <link href="http://blog.nkagami.me/2018/09/07/2018-09-07-Brainstorm/"/>
    <id>http://blog.nkagami.me/2018/09/07/2018-09-07-Brainstorm/</id>
    <published>2018-09-07T16:00:00.000Z</published>
    <updated>2018-09-08T01:31:58.130Z</updated>
    
    <content type="html"><![CDATA[<p>So I’m going to write another version of CodefunMath. What’s the deal about it?</p><p>I’ve <strong>never</strong> been satisfied with the current state of the implementation. It’s laggy, it’s laggish, it’s not responding.It’s not easy at all to deploy (and keep it running). Features are <em>desperately</em> missing and incomplete. And guess what? <strong>All</strong> dependencies are outdated (and I cannot update them).</p><p>Why didn’t I just update it?</p><p>I never believed in it, since the moment it was written.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;So I’m going to write another version of CodefunMath. What’s the deal about it?&lt;/p&gt;
&lt;p&gt;I’ve &lt;strong&gt;never&lt;/strong&gt; been satisfied with th
      
    
    </summary>
    
      <category term="Random" scheme="http://blog.nkagami.me/categories/Random/"/>
    
    
      <category term="brainstorm" scheme="http://blog.nkagami.me/tags/brainstorm/"/>
    
  </entry>
  
  <entry>
    <title>[Random] Rain</title>
    <link href="http://blog.nkagami.me/2017/10/23/Random-Rain/"/>
    <id>http://blog.nkagami.me/2017/10/23/Random-Rain/</id>
    <published>2017-10-24T03:24:00.000Z</published>
    <updated>2017-10-24T13:24:08.518Z</updated>
    
    <content type="html"><![CDATA[<p><em>This is my first attempt at writing randomly. Please ignore any stupid errors I make!</em></p><p>Dark clouds filled the sky. She stood still, her hands holding something - it resembles an umbrella.</p><p>The rain started. Her fingers were shaking, that umbrella was completely useless. Raindrops filled her dress. She was not moving, at all. Her eyes were on the ground. Along with the rain, went a few teardrops.</p><p>She turned six today.</p><p>Minutes passed. The soaked girl let out a few coughs. She didn’t answer to anyone. Her legs were shaking, as if she wouldn’t stand any longer. But there she was, standing still. She cries out a little, but tried her best not to let anyone hear her.</p><p>This was the first time she ever felt alone.</p><p>In the heavy rain, came a light. The light got stronger, as wheels splashed the water. The mysterious black car stopped by her side. Inside the back seat was a woman. Black skirt, white shirt, little bow tie - not much to say about her, a businesswoman. She stepped out, opening her umbrella and walked towards the little girl.</p><p>“Carol, why are you standing outside of our house? Is that an umbrella, why aren’t you opening it?”</p><p>The girl stopped crying.</p><p>“It… it’s my birthday to…today. An…and mom is ten…twenty minutes late.”</p><p>“I’m so sorry dear! But I’ve bought you this… Happy Birthday Carol!”</p><p>The woman pulled a small box from the driver’s seat. A box of Godiva.</p><p>“That’s for you! You should go inside now, Carol. Have a bath! And I was asking you, why didn’t you open…”</p><p>Carol wasn’t carrying an umbrella.</p><p>“It’s a chocolate box, thanks mom. But you were late.”</p><hr><p>I’ve never written a horror piece before. So it clearly lacks some elements (the wind up is weak, I suck at describing stuff…)</p><p>I have to try better next time!</p><p>I rate myself 2/10.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;This is my first attempt at writing randomly. Please ignore any stupid errors I make!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Dark clouds filled the sky. She sto
      
    
    </summary>
    
      <category term="Writing" scheme="http://blog.nkagami.me/categories/Writing/"/>
    
    
      <category term="english" scheme="http://blog.nkagami.me/tags/english/"/>
    
      <category term="random" scheme="http://blog.nkagami.me/tags/random/"/>
    
      <category term="writing" scheme="http://blog.nkagami.me/tags/writing/"/>
    
      <category term="story" scheme="http://blog.nkagami.me/tags/story/"/>
    
  </entry>
  
  <entry>
    <title>HSGSO 2017 Editorial</title>
    <link href="http://blog.nkagami.me/2017/07/01/HSGSO-2017-Editorial/"/>
    <id>http://blog.nkagami.me/2017/07/01/HSGSO-2017-Editorial/</id>
    <published>2017-07-01T10:00:00.000Z</published>
    <updated>2017-12-30T11:41:38.010Z</updated>
    
    <content type="html"><![CDATA[<p>Đây chắc là một trong những bài viết được chờ đợi nhất sau kì thi HSGSO 2017 vừa rồi. Ngoài chữa bài, mình sẽ đưa ra một số thống kê về đề và lượng người giải được!</p><p>Phần chữa bài được thực hiện bởi mình và bạn <a href="https://www.facebook.com/HiImMing" target="_blank" rel="noopener">Nguyễn Đinh Quang Minh</a>. Nếu có câu hỏi gì bạn có thể hỏi mình hoặc Minh qua facebook.</p><h1 id="De-bai"><a href="#De-bai" class="headerlink" title="Đề bài"></a>Đề bài</h1><p>Các bạn có thể tải về đề bài tại <a href="https://www.facebook.com/groups/163215593699283/1468547496499413/" target="_blank" rel="noopener">đây</a>. Trong phần comment của link cũng có chữa tóm tắt một vài bài do các bạn của dự tuyển Tổng Hợp.</p><h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="Muc-luc"><a href="#Muc-luc" class="headerlink" title="Mục lục"></a>Mục lục</h2><h3 id="Ngay-1"><a href="#Ngay-1" class="headerlink" title="Ngày 1"></a>Ngày 1</h3><ol><li><a href="#number">number</a></li><li><a href="#race">race</a></li><li><a href="#tree">tree</a></li><li><a href="#inversion">inversion</a></li></ol><h3 id="Ngay-2"><a href="#Ngay-2" class="headerlink" title="Ngày 2"></a>Ngày 2</h3><ol start="5"><li><a href="#matrix">matrix</a></li><li><a href="#string">string</a></li><li><a href="#p2grp">p2grp</a></li><li><a href="#turtle">turtle</a></li></ol><h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><ul><li>Author: thầy Phương, Phạm Cao Nguyên</li><li>Tester: Nguyễn Hoàng Hải Minh<h3 id="Cac-subtask-nho"><a href="#Cac-subtask-nho" class="headerlink" title="Các subtask nhỏ"></a>Các subtask nhỏ</h3></li><li><strong>Subtask 1</strong> ($S \le 20$) có thể dễ dàng giải bằng thuật quay lui, thử tất cả các trường hợp cắt với độ phức tạp $O(M_1 \times M_2 … \times M_N)$.</li><li><strong>Subtask 2</strong> ($S \le 500, K \le 18$): Do giới hạn của $K$, đáp số là một số không quá giới hạn <code>long long</code>, vì vậy ta có thể thực hiện đơn giản phép quy hoạch động.Gọi $f[i][j]$ là số lớn nhất có thể tạo được nếu ta sử dụng các đoạn từ 1 đến $i$ và lấy tổng cộng $j$ chữ số.Hiển nhiên $f[0][0] = 0$. Ta có:$$f[i][j] = \sum\limits_{k=0}^{\min(M_i, j)} f[i - 1][j - k] \times 10^k + \overline{A_{i,1}A_{i,2}…A_{i,k}}$$Đáp số chính là $f[N][K]$. Lưu ý độ phức tạp của thuật toán này chỉ là $O(SK)$ chứ không phải $O(N^2K)$.</li></ul><h3 id="Tham-lam-1-chu-so"><a href="#Tham-lam-1-chu-so" class="headerlink" title="Tham lam 1 chữ số"></a>Tham lam 1 chữ số</h3><p>Subtask 3 có một giới hạn khá lạ: Mỗi đoạn có độ dài đều là 1. Như vậy, việc chọn một đoạn chỉ đơn giản là lấy hoặc không. Ta có thể ra một thuật toán tham lam cho subtask này.</p><p>Ta có thể thấy, ở mỗi vị trí từ trái sang phải ta sẽ luôn ưu tiên số lớn nhất ở trước. Thật vậy, dễ dàng chứng minh điều này: Khi so sánh 2 số có cùng độ dài, ta chỉ cần tìm chữ số đầu tiên khác nhau từ trái sang và so sánh chúng.</p><p>Ý tưởng tham lam như sau. Giả sử ta đã lấy $x$ chữ số, chữ số cuối cùng ta lấy ở vị trí $i$. Ta có các nhận xét sau về chữ số tiếp theo cần lấy (ở vị trí $j$):</p><ul><li>Hiển nhiên ta không thể lấy tiếp ở các vị trí $j \le i$.</li><li>Hiển nhiên không kém, ta không thể lấy ở các vị trí $j &gt; N - (K - x) + 1$. Đơn giản là, nếu lấy ở các vị trí này, ta không còn đủ chữ số để dựng số có $K$ chữ số nữa.</li><li>Trong các vị trí còn lại, ta luôn chọn vị trí có chữ số lớn nhất. Điều này hiển nhiên đúng, vì về sau ta chọn thế nào thì cũng ra số lớn hơn số được tạo ra nếu ta không chọn chữ số lớn nhất ở bước này.</li><li>Trong các vị trí có cùng giá trị, lấy vị trí trái nhất. Điều này đảm bảo ta có nhiều cơ hội hơn để lấy số lớn hơn ở vị trí tiếp theo.</li></ul><p>Như vậy subtask 3 có thể giải với độ phức tạp $O(10 \times N)$. Hãy lưu ý subtask này, vì ý tưởng tham lam là chìa khóa để giải subtask cuối!</p><h3 id="Cai-tien-quy-hoach-dong"><a href="#Cai-tien-quy-hoach-dong" class="headerlink" title="Cải tiến quy hoạch động"></a>Cải tiến quy hoạch động</h3><p>2 subtask tiếp theo (4 và 5) chỉ là việc cài đặt công thức quy hoạch động của subtask 2 lên với số lớn. Dễ dàng nhận thấy ta chỉ phải cài đặt phép cộng số lớn, và đáp số không quá $10^K$ nên độ phức tạp là $O(SK^2)$.</p><p>Dễ dàng cài số lớn qua subtask 4, nhưng để qua subtask 5 sẽ cần thêm một chút cải tiến để lọt time limit (vd nén 9 chữ số vào một <code>int</code> thay vì giữ từng chữ số, cộng dồn đoạn để giảm số phép tính,…)</p><h3 id="Subtask-cuoi"><a href="#Subtask-cuoi" class="headerlink" title="Subtask cuối"></a>Subtask cuối</h3><p>Để giải được subtask cuối, ta cần bỏ đi suy nghĩ quy hoạch động và quay lại với ý tưởng tham lam.</p><p><strong>Tại sao ý tưởng của subtask 3 không thể áp dụng được ngay vào subtask cuối?</strong> Bởi vì trong mỗi đoạn, ta bắt buộc phải chọn 1 đoạn tiền tố để đặt vào đáp số. Nhiều khi, chữ số phía sau lớn nhưng đoạn chữ số phía trước không tối ưu.</p><p><strong>Ta có thể chỉ xét chữ số tiếp theo của chuỗi đang lấy cuối cùng, hoặc đầu của các chuỗi phía sau.</strong> Đây là một nhận xét đúng. Thật vậy: Kiểu gì bạn cũng phải đặt chữ số đầu tiên của một chuỗi nếu lấy chuỗi đó. Và nếu chữ số đầu tiên có lựa chọn tốt hơn: điều đúng đắn là bỏ cả chuỗi.</p><p><strong>Tuy nhiên, có một vấn đề khác.</strong> Khi có nhiều lựa chọn chữ số tiếp theo giống nhau, <strong>chọn chữ số trái cùng không phải lựa chọn tối ưu</strong>. Bản chất là vì lựa chọn của bạn còn làm ảnh hưởng đến tập đáp số tối ưu phía sau:</p><ul><li>Nếu $M_i = 1$ với mọi $i$, lựa chọn của bạn luôn là $(x_j, y_j)$ (giá trị, vị trí) với chữ số $j$ (từ trái sang) và $j$ luôn tốt hơn $j + 1$.</li><li>Khi điều kiện 1 không còn nữa, không phải lúc nào $j$ cũng tốt hơn $j + 1$. Xét trường hợp sau: <code>5 6</code> và <code>5 7</code> ($K = 2$). Nếu bạn chọn số <code>5</code> bên trái, tiếp theo bạn chỉ được chọn giữa <code>6</code> và <code>5</code> cho chữ số tiếp theo. Trong khi đó đáp số hiển nhiên là <code>57</code>.</li></ul><p>Tuy vậy, ta nhận thấy đáp án tối ưu vẫn luôn xuất phát từ chữ số lớn nhất, và đáp án vẫn là chọn số lớn nhất có thể ở mỗi bước. Vậy ta vẫn có thể đưa số <code>5</code> vào, chỉ có điều <strong>ta chưa quyết định đấy là số 5 ở vị trí nào</strong>. Hay hiểu kiểu khác, trước tiên ta chọn <code>5</code> của <code>5 6</code>, nhưng do <code>5 7</code> có đầu <code>5</code> trùng với đuôi <code>5</code> của ta nên ta xóa <code>5</code> của <code>5 6</code> đi và thêm cả <code>5 7</code> vào.</p><p>Tóm tắt lại, thuật toán của ta như sau:Giả sử ta đã có $i$ chữ số $x_1, x_2, …, x_i$ ($x_i$ ở dãy $j$), ta sẽ có tập lựa chọn cho chữ số tiếp theo (dãy $p$ vị trí $q$) như sau:</p><ul><li>Nó phải thuộc dãy $p \ge j$. Hiển nhiên ta không thể lấy lại một dãy trước đó.</li><li>Sau nó phải có ít nhất $K - i - 1$ chữ số (từ nó về cuối dãy, và tổng tất cả dãy phía sau).</li><li>$p = j$ và nó là chữ số đứng sau $x_i$, <em>hoặc</em></li><li>$p &gt; j$, $x_{i - k} = A[p][q - 1 - k]$ với mọi $0 \le k &lt; q - 1$. Khi chọn lựa chọn này, ta xóa tất cả $x_{i - q + 2}..x_i$ và thêm vào $A[p][1..q]$.</li></ul><p>Dễ dàng chứng minh ở mỗi bước, ta đều lấy được chữ số lớn nhất có thể lấy được khi có prefix dựng từ bước trước đó (do vậy, nếu prefix tối ưu thì theo phép so sánh số, dãy mới là tối ưu). Do ở bước đầu (prefix rỗng), lựa chọn là tối ưu, nên theo quy nạp thuật toán tham là tối ưu.</p><p>Ta có thể cài thuật toán này trong độ phức tạp $O(SK)$.</p><h3 id="Mot-chut-thong-ke"><a href="#Mot-chut-thong-ke" class="headerlink" title="Một chút thống kê"></a>Một chút thống kê</h3><p><img src="/images/score_number.png" alt=""></p><p>Về điểm số:</p><ul><li>Có một bạn duy nhất được <strong>99</strong> điểm (Bùi Hồng Đức). Xin chúc mừng Đức đã ra được thuật toán đúng cho subtask cuối. Thật vậy, Đức chỉ còn 1 test lắt léo duy nhất: Đề bài yêu cầu in ra số tạo từ $K$ chữ số đã chọn, mà đã là số thì phải không có số <code>0</code> ở đầu :( Kể ra bài đã khó, test cũng khó, sorry mọi người vì cái test quái gở này.</li><li>Có 12 bạn được <strong>73-76</strong> điểm. Khi sinh test mình đã tính đến việc các bạn sử dụng tham lam của subtask 3, đưa thẳng vào subtask 6 (chỉ qua nhận xét đầu tiên). Đây là số điểm các bạn nhận được :) Kể ra không cho điểm nào thì cũng hơi ác, nhưng cho nhiều điểm quá thì cũng không đáng (nhớ rằng tối ưu bignum chỉ được thêm 10 điểm). Thật sự 6 điểm khá là nhiều cho một thuật sai khá là rõ ràng, và còn vài bạn còn cài sai thuật đó nữa…</li><li>6 bạn được <strong>70</strong> điểm. Chúc mừng 6 bạn đã qua được mốc quan trọng của một bài khó: cắn nhiều nhất có thể. Đây là chiến thuật hữu dụng nhất khi thi quốc gia!</li><li>Còn lại 71 bạn có điểm dương, trải dài khá đều từ 1 đến 65 điểm. Rất tuyên dương cố gắng của các bạn! Hãy cố lên! Đặc biệt với những bạn được 1 điểm, mình không hiểu tại sao có thể được 1 điểm…</li></ul><p>Về bộ test:</p><ul><li>Bản thân mình khá hài lòng về bộ test mình sinh ra. Có đủ điểm cho người liều lĩnh, đủ điểm cho người chắc ăn, đủ lỗi để hành người sai,…</li><li>Trong bộ test (sau này sẽ được up), có 2 test được sinh ra để giết một nhận xét tham lam của subtask 6… Đố bạn nào biết đó là nhận xét gì :)</li></ul><h2 id="race"><a href="#race" class="headerlink" title="race"></a>race</h2><ul><li>Author: Nguyễn Đinh Quang Minh</li><li>Tester: Nguyễn Hoàng Hải Minh</li></ul><h3 id="Bai-toan-lop-bon-va-thuat-toan-O-N-3"><a href="#Bai-toan-lop-bon-va-thuat-toan-O-N-3" class="headerlink" title="Bài toán lớp bốn và thuật toán O(N^3)"></a>Bài toán lớp bốn và thuật toán O(N^3)</h3><blockquote><p>Ba người $A$, $B$, $C$ xuất phát ở ba vị trí $x_A$, $x_B$, $x_C$ trên một đường thẳng, cùng đi về một hướng với vận tốc $v_A$, $v_B$, $v_C$. Hỏi có thời điểm nào người $B$ nằm ở trung điểm 2 người còn lại hay không?</p></blockquote><p>Thầy Phương từng đố mình bài toán trên. Nếu bỏ qua dữ kiện ‘đây là bài toán lớp bốn’ thì chúng ta (tất nhiên kể cả mình) đều sẽ cầm bút giải phương trình bậc nhất rồi tìm nghiệm. Nhưng hãy thử nghĩ <em>như một học sinh lớp bốn</em> xem sao…</p><p>Cách giải của các bé lớp bốn cho bài toán này như sau: giả sử có thêm một người $D$ di chuyển sao cho $D$ <em>luôn nằm ở trung điểm</em> của $A$ và $C$, khi đó nếu $B$ gặp $D$ tức là <strong>$B$ nằm ở trung điểm $AC$</strong>. Vị trí xuất phát và vận tốc của $D$ như thế nào cho hợp lý? Hiển nhiên là trung bình cộng của $A$ và $C$, tức là $x_D = \dfrac{x_A + x_C}{2}$, $v_D = \dfrac{vA + vC}{2}$.</p><p>Khi đã có người D rồi thì có 3 trường hợp xảy ra:</p><ol><li>$B$ luôn chạy trùng với $D$: có vô hạn thời điểm thỏa mãn;</li><li>$B$ không gặp $D$ (kết quả tăng 0);</li><li>$B$ có gặp $D$ (kết quả tăng 1).</li></ol><p>Điều kiện cụ thể cho từng trường hợp xảy ra như sau:</p><table><thead><tr><th></th><th>$v_B &lt; v_D$</th><th>$v_B = v_D$</th><th>$v_B &gt; v_D$</th></tr></thead><tbody><tr><td>$x_B &lt; x_D$</td><td>0</td><td>0</td><td>1</td></tr><tr><td>$x_B = x_D$</td><td>1</td><td>vô hạn</td><td>1</td></tr><tr><td>$x_B &gt; x_D$</td><td>1</td><td>0</td><td>0</td></tr></tbody></table><p>Như vậy thuật giải $O(N^3)$ chỉ đơn giản là duyệt tất cả các bộ ba <em>phân biệt</em> rồi kiểm tra theo bảng trên.</p><h3 id="Dieu-kien-tren-nhin-quen-quen"><a href="#Dieu-kien-tren-nhin-quen-quen" class="headerlink" title="Điều kiện trên nhìn quen quen?"></a>Điều kiện trên nhìn quen quen?</h3><p>Để tối ưu thuật toán, ta sẽ nghĩ đến việc duyệt 2 người $A$ và $C$, tính được thông tin người $D$, rồi tìm số người $B$ thỏa mãn. Cụ thể hơn:</p><ul><li>Nếu tồn tại người B sao cho x_B = x_D, v_B = v_D thì trả về kết quả là <code>infinity</code>.</li><li>Cộng vào kết quả số người B thỏa mãn $x_B \le X_D$, $v_B &gt; v_D$.</li><li>Cộng vào kết quả số người B thỏa mãn $x_B \ge x_D$, $v_B &lt; v_D$.</li></ul><p>Hai điều kiện trên (trừ điều kiện in ra <code>infinity</code> rất dễ) đều khá quen thuộc: ý tưởng của nó giống với <a href="https://natsukagami.github.io/2017/05/01/HSGSO-2016-Editorial/#polylines" target="_blank" rel="noopener">bài polylines của năm ngoái</a>. Ta có thể sort tất cả những người $B$ và $D$ theo chiều $v$ tăng dần rồi sử dụng cấu trúc dữ liệu BIT cho chiều $x$.</p><h3 id="Khong-biet-cai-BIT-thi-sao"><a href="#Khong-biet-cai-BIT-thi-sao" class="headerlink" title="Không biết cài BIT thì sao?"></a>Không biết cài BIT thì sao?</h3><p>Thì <del>bạn nên học cài BIT</del> ta sẽ thử một thuật giải không sử dụng BIT <del>mà sẽ sử dụng IT</del>.</p><p>Trước hết, chúng ta chỉ quan tâm đến giá trị $x$ và $v$ của mỗi người <em>đứng thứ mấy</em> nên ta hoàn toàn có thể sort các giá trị $x$ và $v$ lại rồi “đánh số” lại theo thứ tự của giá trị trong dãy được sort.Bây giờ khi có một người $D$ nào đó, ta có thể biết $x_D$ đứng ở vị trí thứ mấy trong mảng $x$ bằng chặt nhị phân, tương tự với $v_D$. Điều này sẽ giúp ta giải quyết bài toán bằng mảng cộng dồn 2 chiều thay vì BIT.</p><p>Trước hết, ta lập một mảng $A[1..N][1..N]$, $A[i][j] = 1$ có nghĩa là tồn tại một người có giá trị $x$ đứng thứ $i$ và giá trị $v$ đứng thứ $j$, ngược lại $A[i][j] = 0$. Giả sử xét một người $D$ có $x_D$ đứng ở vị trí thứ $X$, $v_D$ đứng ở vị trí thứ $V$. Như vậy, số người thỏa mãn $x_B \le x_D$, $v_B &gt; v_D$ chính là tổng các số trong hình chữ nhật con có góc trên trái là $(1, V)$, góc dưới phải là $(X, N)$ và được tính trong $O(1)$ bằng mảng cộng dồn.</p><h3 id="One-more-thing"><a href="#One-more-thing" class="headerlink" title="One more thing"></a>One more thing</h3><p>Để cài đặt cho tiện, bạn nên nhân đôi tất cả tọa độ và vận tốc lên ¯\_(ツ)_/¯</p><h3 id="Score-Distribution"><a href="#Score-Distribution" class="headerlink" title="Score Distribution!"></a>Score Distribution!</h3><p><img src="/images/score_race.png" alt=""></p><h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><ul><li>Author: Phạm Đức Thắng</li><li>Tester: Nguyễn Hoàng Hải Minh</li></ul><h3 id="N-1"><a href="#N-1" class="headerlink" title="$N = 1$!"></a>$N = 1$!</h3><p>Trước tiên, cần phải để ý nếu $N = 1$ thì đỉnh duy nhất phải có bậc <strong>0</strong>. Khi đó, đường đi dài nhất là 1.</p><p>Rất nhiều bạn đã chết test này!</p><h3 id="Subtask-nho"><a href="#Subtask-nho" class="headerlink" title="Subtask nhỏ"></a>Subtask nhỏ</h3><ul><li>Subtask 1 ($N \le 15$), bạn có thể backtrack mọi cách dựng cây?</li></ul><h3 id="Dung-duoc-cay-khong"><a href="#Dung-duoc-cay-khong" class="headerlink" title="Dựng được cây không?"></a>Dựng được cây không?</h3><p>Điều kiện sau là điều kiện cần và đủ để tồn tại cây:</p><ul><li>Tổng bậc là $2N - 2$</li><li>Không đỉnh nào có bậc quá $N - 1$.</li><li>Không đỉnh nào có bậc dưới $1$.</li></ul><p>Dễ dàng chứng minh điều kiện này bằng quy nạp.</p><p>Subtask 2 sinh ra để bạn kiểm tra việc dựng cây nếu không biết điều này :D</p><h3 id="Dung-toi-uu"><a href="#Dung-toi-uu" class="headerlink" title="Dựng tối ưu!"></a>Dựng tối ưu!</h3><p>Gọi $x$ là số nút có bậc lớn hơn 1 (tức không phải lá). Ta sẽ chứng minh nếu $N \ge 2$ thì đáp số là $x + 1$.</p><p>Thật vậy, ta gọi tập đỉnh không phải lá là $A_1, A_2, …, A_x$. Trước tiên, dựng tập cạnh như sau:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lá - A[1] - A[2] - ... - A[x] - lá</span><br></pre></td></tr></table></figure></p><p>Dễ dàng nhận thấy tổng bậc còn lại của các đỉnh không phải lá là $(2N - 2) - (N - x) - 2x = N - x - 2$, số lá còn lại là $N - x - 2$. Như vậy ta có thể thêm lá vào các bậc còn thiếu của từng đỉnh. Cây đã dựng xong! Đường đi dài nhất trên cây này chắc chắn là $x + 1$.</p><p>Không khó để chứng minh đáp số không thể lớn hơn $x + 1$ (đường đi đơn không thể đi qua 3 lá). Vì vậy $x + 1$ là đáp án tối ưu.</p><h3 id="Phan-bo-diem"><a href="#Phan-bo-diem" class="headerlink" title="Phân bố điểm"></a>Phân bố điểm</h3><p>Rất nhiều bạn AC bài này, tuy nhiên cũng rất nhiều người bị 98 điểm do thiếu $N = 1$. Hãy cẩn thận với những trường hợp biên!</p><p><img src="/images/score_tree.png" alt=""></p><h2 id="inversion"><a href="#inversion" class="headerlink" title="inversion"></a>inversion</h2><ul><li>Author: Nguyễn Thành Vinh</li><li>Tester: Nguyễn Hoàng Hải Minh</li></ul><h3 id="Chay-trau"><a href="#Chay-trau" class="headerlink" title="Chạy trâu!"></a>Chạy trâu!</h3><p>For từng đoạn con, tính cặp nghịch thế trâu, $O(N^4)$ ăn sub 1. Ta có thể cải tiến hơn, tính nghịch thể trong $O(N \log N)$ bằng BIT, tuy nhiên vẫn chưa đủ để ăn subtask 2.</p><h3 id="Tinh-tien-Level-1"><a href="#Tinh-tien-Level-1" class="headerlink" title="Tịnh tiến Level 1"></a>Tịnh tiến Level 1</h3><p>Nhận thấy, mỗi lần for đoạn con là một lần tính lại. Đoạn $(i, j)$ chỉ khác đoạn $(i, j + 1)$ một lượng là số phần tử trong khoảng $(i, j)$ mà lớn hơn $A[j + 1]$. Như vậy, ta có thể for $i$ rồi vừa tăng $j$ vừa tính thêm, giảm độ phức tạp xuống $O(N^2 \log N)$.</p><h3 id="Tinh-tien-Level-2"><a href="#Tinh-tien-Level-2" class="headerlink" title="Tịnh tiến Level 2"></a>Tịnh tiến Level 2</h3><p>Từ việc tịnh tiến trên, ta nhận thấy rằng nếu $i \le j &lt; k$ thì $(i, j)$ luôn có số nghịch thế không quá số nghịch thế của $(i, k)$.</p><p>Đồng thời, nhận xét cũng đúng với $(j, i)$ và $(k, i)$ nếu $k &lt; j \le i$.</p><p>Giả sử $j$ là số lớn nhất sao cho $(i, j)$ có số nghịch thế $&lt; K$. Dễ dàng nhận thấy tất cả $(i, j’)$ với $j &lt; j’ \le N$ đều là đáp án. Như vậy với mỗi $i$ ta chỉ cần tìm $j$ là đủ.</p><p>Lại có $(i, j)$ có số nghịch thế $&lt; K$, vì thế $(i + 1, j)$ chắc chắn có số nghịch thế $&lt; K$. Ta không cần for các giá trị nhỏ hơn $j$ để kiểm tra nữa. Thay vì for lại $j$, ta xóa $i$ khỏi đoạn, giảm số nghịch thế đi 1 lượng là số số nhỏ hơn $A[i]$.</p><p>2 con trỏ $i$ và $j$ đều tăng từ 1 đến $N$, mỗi lần tăng con trỏ phải update mất $O(\log N)$. Độ phức tạp của thuật toán là $O(N \log N)$.</p><h3 id="Phan-bo-diem-1"><a href="#Phan-bo-diem-1" class="headerlink" title="Phân bố điểm"></a>Phân bố điểm</h3><p>Đây là một bài khá cơ bản, dù vậy điểm khá là thấp so với bọn mình kì vọng, chủ yếu mọi người chỉ dừng ở subtask 2.</p><p><img src="/images/score_inversion.png" alt=""></p><h2 id="matrix"><a href="#matrix" class="headerlink" title="matrix"></a>matrix</h2><ul><li>Author: Nguyễn Đinh Quang Minh</li><li>Tester: Phạm Cao Nguyên, Nguyễn Hoàng Hải Minh</li></ul><h3 id="Cac-subtask-nho-1"><a href="#Cac-subtask-nho-1" class="headerlink" title="Các subtask nhỏ"></a>Các subtask nhỏ</h3><ul><li><strong>Subtask 1</strong> ($N = 1$), đây là subtask cho điểm vì bản thân cả bảng đã được chứa trong mảng $B[]$. Nếu xor tất cả phần tử trong mảng $B[]$ bằng $A[1]$ thì có 1 đáp án chính là mảng $B[]$. Nếu không thì không có đáp án nào cả. Độ phức tạp $O(M)$.</li><li><strong>Subtask 2</strong> ($NM \le 20$), từ điều kiện ta suy ra $\min(N, M) \le \sqrt{20} \le 5$. Không mất tính tổng quát ta giả sử $M \le 5$ (nếu không ta xoay bảng lại), ta có thể quy hoạch động $f[i][mask]$ là số cách tạo các hàng từ 1 đến $i$, với tổng xor từng cột được biểu diễn trong $mask$. Sau đó ta có thể for tất cả các mask $m$ có thể của hàng $i + 1$, update vào $f[i + 1][mask \oplus m]$. Độ phức tạp là $O(N \times (2^M)^2)$. Hoặc ta có thể backtrack giá trị của tất cả phần tử của bảng, độ phức tạp là $O(2^{N + M})$.</li><li><strong>Subtask 3</strong> ($N \le 10$, $M \le 2000$), ta sẽ cải tiến thuật toán quy hoạch động phía trên. Thay vì mỗi lần ta thêm cả cột (mất $O(2^N)$), ta chỉ thêm từng ô. Gọi $f[i][j][mask]$ là số cách điền các ô từ $(i, j)$ trở đi (theo từng cột, rồi từng hàng), và xor các phần tử đã đặt vào trước đó của mỗi hàng được biểu diễn trong mask. Ta tính từ $f[i + 1][j][mask’]$ hoặc $f[1][j + 1][mask’]$, với điều kiện là khi điền xong mỗi cột thì xor cột đó phải bằng $B[j]$. Ta có thể kiểm tra điều này bằng cách kiểm tra $X = B[1] \oplus B[2] \oplus … \oplus B[j]$ có bằng xor các bit trong $mask$ không. Độ phức tạp là $O(NM2^N)$.</li></ul><h3 id="Dung-mot-dap-an"><a href="#Dung-mot-dap-an" class="headerlink" title="Dựng một đáp án"></a>Dựng một đáp án</h3><p>Trước khi tìm hiểu xem có bao nhiêu đáp án thỏa mãn, ta cần phải kiểm tra xem có tồn tại đáp án không đã.</p><p>Hiển nhiên nếu tổng xor của $A[]$ khác tổng xor của $B[]$ thì không thể tồn tại bảng thỏa mãn. Còn lại, ta sẽ chứng minh luôn tồn tại bảng thỏa mãn.</p><p>Gọi tổng xor cả bảng là $S$.</p><p>Xét bảng $N \times M$ được dựng như sau:</p><ul><li>Với $i &lt; N$ và $j &lt; M$: điền <code>0</code>.</li><li>Với $i = N$ và $j &lt; M$: điền $B[j]$.</li><li>Với $i &lt; N$ và $j = M$: điền $A[i]$.</li><li>Xét ô $(N, M)$. Ta có giá trị $b[N][M] = A[N] \oplus B[1] \oplus B[2] \oplus … \oplus B[M - 1]$, hay $b[N][M] = A[N] \oplus S \oplus B[M]$. Tất nhiên phân tích theo cột ta cũng sẽ ra công thức này, và vì $S$ xác định nên có duy nhất 1 cách điền ô $(N, M)$. </li></ul><p>Vậy tồn tại bảng thỏa mãn.</p><h3 id="Co-bao-nhieu-bang-thoa-man"><a href="#Co-bao-nhieu-bang-thoa-man" class="headerlink" title="Có bao nhiêu bảng thỏa mãn?"></a>Có bao nhiêu bảng thỏa mãn?</h3><p>Giả sử ta có bảng $b[][]$ thỏa mãn. </p><p>Nếu ta flip giá trị $b[i][j]$ ($i &lt; N$, $j &lt; M$), ta có thể flip cả $b[i][M]$, $b[N][j]$ và $[N][M]$ để ra một bảng mới vẫn đúng. (mỗi hàng mỗi cột ảnh hưởng đều bị flip tổng xor 2 lần).</p><p>Nếu ta giữ nguyên $b[i][j]$ với mọi $i &lt; N$ và $j &lt; M$, dễ dàng chứng minh cách điền các ô còn lại là duy nhất. Thật vậy, $b[i][M]$ ($i &lt; M$) phải xác định duy nhất để tổng xor các ô trong hàng $i$ bằng $A[i]$, tương tự với $b[N][j]$ ($j &lt; N$). Còn lại ô $(N, M)$, tất nhiên vì hàng và cột cuối cũng có tổng xor xác định nên giá trị của ô cũng chỉ có tối đa một.</p><p>Từ 2 nhận xét trên, ta thấy với mỗi cách điền bảng $(N - 1)\times (M - 1)$ ở góc trái trên ta có duy nhất 1 cách điền nốt thỏa mãn. Vậy số bảng thỏa mãn là $2^{(N - 1)(M - 1)}$. </p><p>Kiểm tra điều kiện tồn tại mất $O(N + M)$, tính số bảng mất $O(\log(NM))$, dựng 1 bảng thỏa mãn mất $O(NM)$.</p><h3 id="Thong-ke"><a href="#Thong-ke" class="headerlink" title="Thống kê"></a>Thống kê</h3><p>Subtask 2 là một subtask rất đơn giản (backtrack lấy 20 điểm), vậy mà số bạn làm được khá là ít. Subtask 3 đòi hỏi kỹ thuật quy hoạch động khó hơn, không nhiều bạn làm được. </p><p>Chúc mừng 4 bạn làm được 100 điểm!</p><p><img src="/images/score_matrix.png" alt=""></p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ul><li>Author: Vương Hoàng Long</li><li>Tester: Nguyễn Hoàng Hải Minh</li></ul><h3 id="Subtask-nho-1"><a href="#Subtask-nho-1" class="headerlink" title="Subtask nhỏ"></a>Subtask nhỏ</h3><p>Do độ dài của 2 xâu không quá $10^8$ nên ta có thể thực hiện for trâu để giải subtask này. Tất nhiên có một số điều sau phải chú ý:</p><ul><li>Tuyệt đối không dựng cả xâu. Dựng xâu mất thời gian hằng số rất lớn, có thể làm bạn bị TLE trước cả khi thực hiện so sánh. Chỉ for các chỉ số lặp lại.</li><li>Để tăng tốc, không dùng phép mod để tính nhanh chỉ số. </li></ul><p>Độ phức tạp là $O(|A|)$.</p><h3 id="Subtask-lon"><a href="#Subtask-lon" class="headerlink" title="Subtask lớn"></a>Subtask lớn</h3><p>Để đơn giản cho việc mod ta coi xâu đánh số từ 0.</p><p>Nhận thấy phần tử thứ $i$ của xâu $X$ sẽ được so sánh với các phần tử $i \mod |Y|, (i + |X|) \mod |Y|, …, (i + (n - 1)|X|) \mod |Y|$ của $Y$.</p><p>Không khó để nhận ra dãy này có chu trình độ dài $|Y| / \gcd(|X|, |Y|)$. Không khó để chứng minh điều này: $|X||Y| / \gcd(|X|, |Y|)$ chính là <em>bội chung nhỏ nhất</em> của $|X|$ và $|Y|$, bội dương đầu tiên của $|X|$ chia hết cho $|Y|$.</p><p>Như vậy, ta chỉ cần chia $Y$ thành các chu trình tương ứng, sau đó tính trước số kí tự từng loại là có thể so sánh 1 vị trí của $X$ với 1 chu trình trong $O(1)$.</p><p>Độ phức tạp là $O(|Y| + |X|)$.</p><h3 id="Thong-ke-1"><a href="#Thong-ke-1" class="headerlink" title="Thống kê"></a>Thống kê</h3><p>Đây là bài dễ của ngày 2. Tuy vậy mình không nghĩ là có ít người AC như vậy. Có lẽ tại vì không nhiều người biết đến việc chu trình BCNN? </p><p><img src="/images/score_string.png" alt=""></p><h2 id="p2grp"><a href="#p2grp" class="headerlink" title="p2grp"></a>p2grp</h2><ul><li>Author: Nguyễn Khánh</li><li>Tester: Nguyễn Hoàng Hải Minh</li></ul><h3 id="Subtask-1"><a href="#Subtask-1" class="headerlink" title="Subtask 1"></a>Subtask 1</h3><p>Với $n$ và $m$ không quá 20, các cạnh không quá $2^{m-1}$, chúng ta có thể dựng đồ thị rồi sử dụng thuật toán tìm đường đi ngắn nhất bất kì (Floyd, Dijkstra hoặc thậm chí là backtrack). Kết quả không vượt quá số nguyên 64 bit nên cũng không có gì bận tâm về cách cài đặt.</p><h3 id="Subtask-2"><a href="#Subtask-2" class="headerlink" title="Subtask 2"></a>Subtask 2</h3><p>Thuật toán Floyd tìm đường đi ngắn nhất cho mọi cặp đỉnh chạy trong độ phức tạp $O(n^3)$ nên hoàn toàn có thể vượt qua subtask này. Tuy nhiên, kết quả không còn đủ nhỏ để lưu dưới dạng số nguyên nữa, vì vậy ta cần cài thêm hàm cộng 2 dãy nhị phân.</p><h3 id="Subtask-3"><a href="#Subtask-3" class="headerlink" title="Subtask 3"></a>Subtask 3</h3><p>Tất nhiên, ngoài Floyd, chúng ta có thể chạy thuật toán Dijkstra từ mỗi đỉnh của đồ thị. Mỗi lần chạy Dijkstra có độ phức tạp $O((n+m) * \log n)$, nên tổng độ phức tạp sẽ là $O(n(n+m)\log n \times C)$, trong đó $C$ là chi phí cộng 2 dãy nhị phân.</p><p>Nếu cộng từng bit một của 2 dãy nhị phân lại với nhau thì $C$ sẽ rơi vào khoảng 1000 phép tính, không đủ để qua subtask này. Cách tốt hơn là cứ $x$ bit của dãy nhị phân, ta nhóm lại thành một số rồi thực hiện cộng (hiệu quả nhất là $x = 63$).</p><h3 id="Subtask-4"><a href="#Subtask-4" class="headerlink" title="Subtask 4"></a>Subtask 4</h3><p>Điều kiện $m &lt; n$ cho ta biết đồ thị là một cây. Giữa 2 đỉnh bất kì trên cây chỉ có duy nhất một đường đi đơn, và hiển nhiên đó là đường đi ngắn nhất.</p><p>Việc duyệt qua mỗi cặp đỉnh rồi tính đường đi ngắn nhất có vẻ không hiệu quả và cũng khó tối ưu được. Do đó chúng ta nghĩ đến việc thay đổi bài toán:</p><blockquote><p>Với mỗi cạnh, có bao nhiêu cặp đỉnh mà đường đi ngắn nhất đi qua cạnh đó?</p></blockquote><p>Hiển nhiên nếu ta trả lời được câu hỏi trên thì sẽ dễ dàng tính được đáp án.</p><p>Câu trả lời thực ra cũng rất đơn giản. Mỗi cạnh trên cây, nếu cắt đi sẽ tạo ra 2 cái cây nhỏ. Dễ thấy một cặp đỉnh mà mỗi đỉnh nằm ở một cây thì đường đi giữa chúng bắt buộc phải đi qua cạnh vừa bị cắt. Do vậy số cặp đỉnh có đường đi đi qua cạnh đó sẽ bằng tích độ lớn 2 cây con.</p><p>Ta đặt gốc cây ở đỉnh 1. Giả sử cạnh đang xét nối giữa đỉnh $u$ và cha của nó, thì 1 trong 2 cây con sẽ chính là cây con gốc $u$. Việc tính độ lớn cây con gốc u có thể giải quyết bằng DFS trong thời gian $O(n)$.</p><h3 id="Nhung-canh-khong-quan-trong"><a href="#Nhung-canh-khong-quan-trong" class="headerlink" title="Những cạnh không quan trọng"></a>Những cạnh không quan trọng</h3><p>Đọc kĩ lại đề bài, chúng ta phát hiện ra còn một chi tiết nữa mà cả 4 subtask trước đều chưa phải dùng đến: các cạnh có độ lớn $2^w$ và có trọng số <strong>phân biệt</strong>. Liệu đây có phải mấu chốt để giải quyết subtask cuối?</p><p>Để ý rằng trọng số của một cạnh lớn hơn hẳn tổng trọng số của các cạnh nhỏ hơn nó (vì $2^0 + 2^1 + … + 2^{x-1} &lt; 2^x$). Điều đó chứng tỏ nếu 2 đường đi có cạnh lớn nhất khác nhau thì đường đi nào có cạnh lớn nhất nhỏ hơn chắc chắn có tổng nhỏ hơn.</p><p>Như vậy, ta có thể lần lượt các cạnh vào đồ thị theo thứ tự trọng số tăng dần. Giả sử khi thêm cạnh $(u, v)$ mà giữa $u$ và $v$ đã có đường đi thì cạnh $(u, v)$ sẽ không nằm trong bất kì đường đi ngắn nhất nào (thay vì đi cạnh $(u, v)$ ta có thể đi đường đi ngắn nhất từ $u$ đến $v$ đã tìm được trước đó). Do đó, ta có thể bỏ cạnh $(u, v)$.</p><h4 id="Subtask-5-Subtask-4-D"><a href="#Subtask-5-Subtask-4-D" class="headerlink" title="Subtask 5 = Subtask 4 ?? :D ??"></a>Subtask 5 = Subtask 4 ?? :D ??</h4><p>Sau khi loại bỏ các cạnh không quan trọng, đồ thị ta thu được là một cây (!). Lí do là ta sẽ không thêm cạnh $(u, v)$ mà $u$ đã có đường đi tới $v$, tức là đồ thị sẽ không thể có chu trình. Đến đây thì subtask 5 có thể giải y hệt subtask 4 rồi :D</p><h3 id="Thong-ke-2"><a href="#Thong-ke-2" class="headerlink" title="Thống kê"></a>Thống kê</h3><p>Đây là một bài khá lằng nhằng để ăn điểm những sub nhỏ, nhưng thuật toán chuẩn không cần quá nhiều chi tiết cài đặt. Vì thế bài có nhiều người AC, nhưng lượng ăn subtask nhỏ nhỏ hơn.</p><p>Chúc mừng 8 bạn đã AC! Fun fact: 4/8 bạn giải được bài này là của THPT Chuyên Lương Thế Vinh.</p><p><img src="/images/score_p2grp.png" alt=""></p><h2 id="turtle"><a href="#turtle" class="headerlink" title="turtle"></a>turtle</h2><ul><li>Author: Nguyễn Đinh Quang Minh</li><li>Tester: Nguyễn Hoàng Hải Minh</li></ul><h3 id="BFS-trang-thai"><a href="#BFS-trang-thai" class="headerlink" title="BFS trạng thái"></a>BFS trạng thái</h3><p>Subtask 1 có giới hạn $N \le 10$, nên chỉ có $10! = 3.628.800$ trạng thái, hơn nữa từ một trạng thái có thể đi được đến tối đa là $N-1$ trạng thái khác. Vì vậy chỉ cần BFS để tìm đường đi ngắn nhất từ trạng thái hiện tại đến trạng thái đích.</p><h3 id="N-le-20"><a href="#N-le-20" class="headerlink" title="$N \le 20$?"></a>$N \le 20$?</h3><p>Mình thành thật xin lỗi các bạn đã bỏ công để nghĩ cách lấy 60% số điểm từ subtask 2, vì thực ra mình cũng không có cách giải nào (không phải thuật chuẩn) mà qua được subtask này cả :( . Có lẽ một thuật backtrack đặt cận tốt có thể ăn được một vài test của subtask này, nhưng mình không chắc chắn lắm.</p><h3 id="pos-a-i-i"><a href="#pos-a-i-i" class="headerlink" title="pos[a[i]] = i"></a><code>pos[a[i]] = i</code></h3><p>Thoạt nhìn, bước biến đổi hoán vị trong bài toán có vẻ khá phức tạp. Tuy nhiên, để ý kĩ bạn sẽ thấy, thực ra bước biến đổi bao gồm 2 thao tác:</p><ol><li>Giảm các số có giá trị từ 2 đến $K$ đi 1.</li><li>Gán số đang có giá trị 1 thành $K$.</li></ol><p><em>Fun fact</em>: Khi viết đề, mình đã cố giải thích bước biến đổi theo kiểu chú rùa 1 sẽ hút độ rùa của $K-1$ chú rùa còn lại nhưng cảm thấy hơi kì kì nên thôi ¯\_(ツ)_/¯</p><p>Chưa nhìn ra sự kì diệu của bài toán? Gợi ý: <code>pos[a[i]] = i</code> là một dòng vô cùng quan trọng trong code của mình.</p><p>Nếu bạn vẫn chưa nghĩ ra, hãy đọc tiếp phần bên dưới. Còn nếu nghĩ ra rồi thì cứ đọc tiếp để chắc chắn thuật toán của mình đúng.</p><h3 id="Thuat-toan-O-N"><a href="#Thuat-toan-O-N" class="headerlink" title="Thuật toán O(N)"></a>Thuật toán O(N)</h3><p>Nếu gọi $pos[i]$ là vị trí của số $i$ trong hoán vị, thì mảng $pos$ cũng là một hoán vị. Vậy ta thử xem thao tác trong bài toán thay đổi mảng $pos$ như thế nào?</p><ol><li>Giảm các số có giá trị từ 2 đến $K$ đi 1. Như vậy thì chính là gán $pos[1] = pos[2], pos[2] = pos[3], …, pos[K-1] = pos[K]$.</li><li>Gán số đang có giá trị 1 thành $K$. Vậy là gán $pos[K] = pos[1]$ (cũ).</li></ol><p>Nói tóm lại, phép biến đổi này thay đổi hoán vị $pos$ bằng cách chèn $pos[1]$ vào bất kì vị trí $K$ nào đó trong $pos$. Ta muốn đưa hoán vị $pos$ về hoán vị đơn vị (1, 2, …, $N$). Điều đó cũng có nghĩa là ta chỉ đụng vào mỗi phần tử trong hoán vị không quá một lần, bởi vì ta chỉ cần đặt nó vào một vị trí $K$ hợp lí nào đấy và không còn quan tâm đến nó nữa. </p><p>Vậy những số nào không cần đặt vào chỗ khác?Giả sử ta thực hiện thao tác $x$ lần, tức là các số $pos[x+1..N]$ không bị thay đổi. Điều đó chứng tỏ ban đầu $pos[x+1] &lt; pos[x+2] &lt; … &lt; pos[N]$. Điều ngược lại cũng đúng: nếu $pos[x+1] &lt; pos[x+2] &lt; … &lt; pos[N]$ thì ta có thể dừng thao tác ở lần thứ $x$ bằng cách chèn các số $pos[1..x]$ vào các vị trí hợp lý để nhận được hoán vị đơn vị.Như vậy, thuật toán của bài này thực ra rất đơn giản, tìm vị trí $x$ nhỏ nhất sao cho $pos[x+1] &lt; pos[x+2] &lt; … &lt; pos[N]$ rồi in ra $x$.</p><h3 id="Thong-ke-3"><a href="#Thong-ke-3" class="headerlink" title="Thống kê"></a>Thống kê</h3><p><img src="/images/score_turtles.png" alt=""></p><h4 id="In-ra-a-1-1-duoc-45-diem"><a href="#In-ra-a-1-1-duoc-45-diem" class="headerlink" title="In ra $a[1] - 1$ được 45 điểm???"></a>In ra $a[1] - 1$ được 45 điểm???</h4><p>Trong lúc sinh test, mình gặp phải vấn đề sau: nếu sinh test random thì khả năng số $N-1$ đứng sau số $N$ ($pos[N-1] &gt; pos[N]$) là rất lớn, vì vậy sẽ có chừng 50% số test đáp án là $N-1$. Mặt khác, để đáp án là $K$ thì $pos[K+1] &lt; pos[K+2] &lt; … &lt; pos[N]$, do đó sinh random thì khả năng có đáp án bé gần như bằng không. Vậy mình đã giải quyết như nào?</p><p>Mình quyết định sinh test bằng cách: sinh trước vị trí của $K+1, K+2, …, N$ rồi sinh random các số còn lại (tất nhiên còn thêm vài test tay nữa). Nhưng một vấn đề khác lại nảy sinh: nếu $K$ quá nhỏ so với $N$ (giả sử, $K = 100$ và $N = 500000$), thì khả năng $a[1] = K+1$ là vô cùng lớn ($= 1 - K/N$). Cách cuối cùng để giải quyết vấn đề là thêm phần truy vết các thao tác. Tuy nhiên vào phút chót, mình quyết định không làm phức tạp thêm bài toán nữa vì mình cho rằng thời gian 3.5 tiếng là khá ít, cần phải khuyến khích những người nghĩ ra đáp án hơn là đánh đố họ. Dù sao thì việc in $a[1] - 1$ được nhiều điểm hơn cả subtask 1 cũng làm mình khá buồn :(</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Đây chắc là một trong những bài viết được chờ đợi nhất sau kì thi HSGSO 2017 vừa rồi. Ngoài chữa bài, mình sẽ đưa ra một số thống kê về đ
      
    
    </summary>
    
      <category term="Editorials" scheme="http://blog.nkagami.me/categories/Editorials/"/>
    
    
      <category term="vietnamese" scheme="http://blog.nkagami.me/tags/vietnamese/"/>
    
      <category term="editorial" scheme="http://blog.nkagami.me/tags/editorial/"/>
    
      <category term="hsgso" scheme="http://blog.nkagami.me/tags/hsgso/"/>
    
  </entry>
  
  <entry>
    <title>2017-05-03 Training</title>
    <link href="http://blog.nkagami.me/2017/05/03/2017-05-03-Training/"/>
    <id>http://blog.nkagami.me/2017/05/03/2017-05-03-Training/</id>
    <published>2017-05-03T14:00:00.000Z</published>
    <updated>2017-10-07T12:05:03.013Z</updated>
    
    <content type="html"><![CDATA[<p>Hôm nay bài không phải là khó.</p><h1 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h1><h2 id="ballmachine"><a href="#ballmachine" class="headerlink" title="ballmachine"></a>ballmachine</h2><p>Cho một cây $N$ đỉnh có gốc, mỗi đỉnh chứa tối đa1 quả bóng. Quả bóng từ cha sẽ rơi xuống nútcon nếu có thể. Nếu có nhiều nút con thỏa mãn,chọn nút con có cây con chứa nút có số thứ tựnhỏ nhất.Thực hiện $Q$ truy vấn 1 trong 2 loại:</p><ul><li>Lần lượt cho $k$ quả bóng vào đỉnh gốc. In ranút chứa quả cuối cùng khi bóng rơi xong.</li><li>Lấy quả bóng từ đỉnh $u$ ra. Đếm số quả bóngbị rơi xuống.</li></ul><h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N, Q \le 10^5$</p><h2 id="numbers"><a href="#numbers" class="headerlink" title="numbers"></a>numbers</h2><p>Cho 2 số $A$ và $B$.Đếm số các số $x$ thỏa mãn:</p><ul><li>$A \le x \le B$</li><li>Nếu coi $x$ là một xâu,không tồn tại một xâu con nào của $x$ có độdài lớn hơn 1 và đối xứng.</li></ul><h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$0 \le A \le B \le 10^{18}$</p><h2 id="pipes"><a href="#pipes" class="headerlink" title="pipes"></a>pipes</h2><p>Cho đồ thị $N$ đỉnh $M$ cạnh. Mỗi cạnh có mộtchỉ số $A_i$ chưa biết.Cho biết với mỗi đỉnh giá trị $B_i$ là tổngcác $A_i$ của các cạnh kề với đỉnh đó.Kiểm tra xem có tồn tại duy nhất 1 nghiệmthỏa mãn, và in ra nếu có.</p><h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 10^5$, $1 \le M \le 5 \times 10^5$</p><p>Trong 25% số test input là cây.</p><h2 id="brunhilda"><a href="#brunhilda" class="headerlink" title="brunhilda"></a>brunhilda</h2><p>Cho một tập $N$ số nguyên tố $A_i$.Với số $x$, ta có thể biến đổi như sau trongmột bước để ra số $y$:</p><ul><li>Chọn $k = A_i$ với $i$ bất kì</li><li>$y = x - x \mod k$</li></ul><p>Có $Q$ truy vấn, mỗi truy vấn cho một số $X$.Tìm số bước nhỏ nhất để biến đổi $X$ thành 0.(Số bước có thể là vô tận)</p><h4 id="Gioi-han-3"><a href="#Gioi-han-3" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 10^5$, $1 \le Q \le 10^4$,$1 \le A_i, X \le 10^7$</p><h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="ballmachine-1"><a href="#ballmachine-1" class="headerlink" title="ballmachine"></a>ballmachine</h2><h3 id="Tinh-min-cay-con"><a href="#Tinh-min-cay-con" class="headerlink" title="Tính min cây con"></a>Tính min cây con</h3><p>Theo đúng yêu cầu của bài toán, trước tiênta tính $V[u]$ - min chỉ số tất cả các nútcủa cây con gốc $u$. Việc này có thể làm đơngiản bằng 1 lần dfs, độ phức tạp $O(N)$.</p><h3 id="Tim-thu-tu-dat"><a href="#Tim-thu-tu-dat" class="headerlink" title="Tìm thứ tự đặt"></a>Tìm thứ tự đặt</h3><p>Ta có thể tóm tắt thuật toán đặt bóng nhưsau, từ một cây đã dồn bóng xuống. Giảsử ta đang ở nút $v$:</p><ul><li>Sort các cạnh $(v, u)$ theo $V[u]$ tăng dần</li><li>Với mỗi cạnh $(v, u)$ theo thứ tự:<ul><li>Tìm chỗ đặt ở $u$</li><li>Nếu tìm thấy: thoát. Nếu không, tiếp tục</li></ul></li><li>Không có cây con nào còn chỗ. Nếu $v$ cóchỗ, đặt ở $v$. Nếu không, trả về không đặt.</li></ul><p>Ta có thể chỉnh sửa một chút để tạo ra mảng từngnút theo “priority” như sau, giả sử ta đangở $v$:</p><ul><li>Sort các cạnh $(v, u)$ theo $V[u]$ tăng dần</li><li>Với mỗi cạnh $(v, u)$ theo thứ tự:<ul><li>dfs xây mảng xuống $u$</li></ul></li><li>Đẩy $v$ vào mảng</li></ul><p>Ta sẽ được một dãy $P$ theo kiểu postfix, dễ dàngnhận thấy nếu $i &lt; j$ thì quả bóng luôn đượcrơi xuống $P_i$ trước $P_j$.</p><p><img src="../images/ballmachine_tree.png" alt="Xây test mẫu ta được 5 8 6 3 7 4 2 1"></p><p>Như vậy, việc đặt thêm bóng chỉ đơn giản làtìm $i$ bé nhất mà $P_i$ chưa có bóng, và đặtvào đó. Việc này có thể làm trong $O(1)$, với1 mảng đánh dấu.</p><h3 id="Xoa-nhu-the-nao"><a href="#Xoa-nhu-the-nao" class="headerlink" title="Xóa như thế nào?"></a>Xóa như thế nào?</h3><p>Ta nhận thấy một nút $v$ không thể rỗng nếu nhưtồn tại một tổ tiên $p_v$ có bóng.Do vậy, từ $v$ lên gốc sẽ là một đoạn liêntiếp có bóng, kế theo là các nút không cóbóng lên đến gốc.Vì thế, bảnchất việc “dồn bóng” chỉ là tìm tổ tiên $p_v$cao nhất vẫn chứa bóng, và đưa quả bóng vào$v$ - hay nói cách khác, thay vì xóa $v$ taxóa $p_v$.</p><p>Để tìm $p_v$, ta chỉ cần sử dụng chặt nhị phân,sau đó kiểm tra xem tổ tiên ta chặt có chứabóng hay không. Ta có thể dễ dàng cài đặtthuật toán này bằng nhảy 2 mũ, với độ phức tạp$O(\log N)$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// par[v][i] là cha 2 mũ i của v</span></span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>, cur = v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="comment">// 2^17 + 2^16 + ... + 1 = 2^18 - 1 &gt; 1e5</span></span><br><span class="line"><span class="keyword">if</span> (par[cur][i] != <span class="number">0</span> &amp;&amp; ball[par[cur][i]]) &#123;</span><br><span class="line"><span class="comment">// ^ cha này tồn tại  ^ có bóng</span></span><br><span class="line">len += (<span class="number">1</span> &lt;&lt; i); cur = par[cur][i];</span><br><span class="line"><span class="comment">// ^ khoảng cách tăng 2^i</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, len); <span class="comment">// khoảng cách chính là số bóng rơi</span></span><br><span class="line">removeBall(cur); <span class="comment">// xóa bóng ở cur</span></span><br></pre></td></tr></table></figure><p>Như vậy ta có thuật toán $O(N \log N + Q \log N)$.Phần $N \log N$ bị tạo ra do việc tính cha 2 mũ.</p><h2 id="numbers-1"><a href="#numbers-1" class="headerlink" title="numbers"></a>numbers</h2><h3 id="Tinh-chat-doi-xung"><a href="#Tinh-chat-doi-xung" class="headerlink" title="Tính chất đối xứng"></a>Tính chất đối xứng</h3><p>Một xâu đối xứng sẽ thuộc 1 trong 2 loại:</p><ul><li>Xâu chẵn, nửa đầu bằng nửa sau lật lại.</li><li>Xâu lẻ, bỏ phần tử giữa ta có xâu đối xứng chẵn.</li></ul><p>Ta nhận thấy, trong trường hợp thứ nhất, luôntồn tại 2 kí tự liên tiếp giống nhau (2 kítự ở giữa). Trong trường hợp 2, có thêmmột kí tự khác nằm giữa 2 kí tự giống nhau.</p><p>Như vậy, điều kiện không tồn tại xâu con đốixứng rất đơn giản:</p><ul><li>Không tồn tại $d_i = d_{i + 1}$, <em>và</em></li><li>Không tồn tại $d_i = d_{i + 2}$</li></ul><p>Với $d_i$ là chữ số thứ $i$ của số cần tìm.</p><h3 id="Quy-hoach-dong"><a href="#Quy-hoach-dong" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Để đơn giản hóa việc đếm trong đoạn $[A..B]$ta có thể tính số phần tử nhỏ hơn $B + 1$rồi trừ đi số phần tử nhỏ hơn $A$. Việcchỉ viết 1 hàm qhđ sẽ đơn giản hóa bài toán.Ta tập trung vào bài tính số phần tử thỏamãn nhỏ hơn $X$.</p><h4 id="Cong-thuc"><a href="#Cong-thuc" class="headerlink" title="Công thức"></a>Công thức</h4><p>Gọi $f[i][a][b][sm]$ là số các số đã xây$i$ chữ số đầu tiên, 2 chữ số cuối cùng đãxây là $a$ và $b$, và $sm$ là biến quản líviệc so sánh số đang xây với $X$ (1 nếu đãnhỏ hơn, 0 nếu vẫn bằng nhau).</p><p>Từ đây ta sẽ chuyển trạng thái bằng cáchchọn chữ số điền tiếp theo ($n$) thỏa mãn:</p><ul><li>$n \neq a$ và $n \neq b$</li><li>$sm = 1$ hoặc $n \le X_{i + 1}$</li></ul><p>Độ phức tạp sẽ là $O(\log_{10}N \times 10^3)$.Tất nhiên do tính chất phải lưu 2 chữ sốnên phần cài đặt sẽ lằng nhằng, đồng thờiđể dễ dàng xét số chữ số của số đang qhđ tacũng cần một số ý tưởng kì dị để quản lí(ví dụ, bạn phải xây các số 0 phía trướcvà cho phép đối xứng).</p><h4 id="Quan-li-trang-thai"><a href="#Quan-li-trang-thai" class="headerlink" title="Quản lí trạng thái"></a>Quản lí trạng thái</h4><p>Mình hay làm theo kiểu coi $X$ và số cầntìm như các số có 20 chữ số với số 0 đứng đầukhi qhđ chữ số. Tuy nhiên riêng với bài nàyviệc xử lí trở nên khó khăn hơn khi các số0 đứng đầu không tạo ra xâu con đối xứng.Vì vậy, mình làm như sau:</p><ul><li>Thay vì gọi chữ số 0 ở đầu là 0 gây nhầmvới số 0 ở giữa số, ta gọi số này là <strong>-1</strong></li><li>Mình cho phép đặt thêm -1 thoải mái, nhưngchỉ khi số ngay trước cũng là -1.</li><li>Tất nhiên, chữ số đầu tiên không phải -1phải là một chữ số khác 0.</li><li>Và cuối cùng, yêu cầu trên sẽ xóa bỏ số 0khỏi tập thỏa mãn, vì vậy về sau bạn nênthêm riêng số này nếu cần.</li></ul><p>Để đơn giản ta coi $f[0][-1][-1][0] = 1$,do ta có thể coi có vô tận chữ số -1 phíatrước. Đáp số sẽ là tổng các $f[20][a][b][1]$.</p><h2 id="pipes-1"><a href="#pipes-1" class="headerlink" title="pipes"></a>pipes</h2><h3 id="Giai-tren-cay"><a href="#Giai-tren-cay" class="headerlink" title="Giải trên cây"></a>Giải trên cây</h3><p>Ta có cách giải sau trên cây:</p><ul><li>Chọn một lá $v$. Hiển nhiên nếu cây cótrên 1 đỉnh thì sẽ tồn tại 1 lá.</li><li>Xét cạnh $(v, p_v)$. Hiển nhiên trọng sốcạnh này chính là $B[v]$. Ta giải đượccạnh này, và xóa $v$ khỏi cây, giảm $B[p_v]$.</li><li>Đồ thị còn lại cũng là một cây, tatiếp tục làm đến khi không còn cạnh nào.</li></ul><p>Do ở mỗi bước, trọng số cạnh là xác định,nên trên cây luôn tồn tại 1 đáp án duy nhất.Ta có thể giải với độ phức tạp $O(N)$.</p><h3 id="Do-thi…-lua-dao"><a href="#Do-thi…-lua-dao" class="headerlink" title="Đồ thị… lừa đảo"></a>Đồ thị… lừa đảo</h3><p>Vì mỗi thành phần liên thông không liên quanđến nhau, ta có thể giải riêng. Do vậy từđây ta coi đồ thị là liên thông.</p><p>Với bài toán đã cho,ta có thể coi đây là một hệ $N$ phương trình$M$ ẩn. Hiển nhiên nếu $M &gt; N$ thì hệ sẽ cóvô số nghiệm. Vì vậy, ta chỉ cần xét bàitoán khi $M \le N$.</p><p>Nếu $M &lt; N$ và đồ thị liên thông thì đây làcây, ta giải được ở trên.Vậy ta chỉ cần quan tâm đến $M = N$, tức đồthị “mặt trời”: một chu trình đơn, với mỗi đỉnhtrong chu trình có thể là gốc một cây.</p><h3 id="Chu-trinh"><a href="#Chu-trinh" class="headerlink" title="Chu trình"></a>Chu trình</h3><p>Với phần cây “tua rua” trên mỗi đỉnh, cách giảigiống hệt như giải từng cây ở trên. Bài toánchỉ còn lại một chu trình đơn duy nhất.</p><p>Trước tiên, ta cần biết nếu chu trình có độdài chẵn thì sẽ có vô số nghiệm. Thật vậy, giảsử ta tìm được một nghiệm. Theo chiều kim đồnghồ, tăng các cạnh chẵn thêm 1 và giảm các cạnhlẻ đi 1. Ta thấy tổng của tất cả các đỉnh đềukhông đổi. Vì vậy, từ một nghiệm ta có thể tạora vô số nghiệm khác.</p><p>Như vậy, ta chỉ giải trường hợp độ dài lẻ.Ta tính tổng sau:</p><p>$$P = B_1 + B_2 + … + B_{2k + 1}$$$$ = (A_{2k + 1} + A_1) + (A_1 + A_2) +… + (A_{2k} + A_{2k + 1})$$$$ = 2(A_1 + A_2 + … + A_{2k + 1})$$</p><p>Và</p><p>$$ Q = B_2 + B_4 + … + B_{2k} $$$$ = (A_1 + A_2) + (A_3 + A_4) + … +(A_{2k - 1} + A_{2k}) $$</p><p>Dễ dàng nhận thấy $A_{2k + 1} = P / 2 - Q$.Khi đã có $A_{2k + 1}$, ta có thể tính đượctất cả các số còn lại với độ phức tạp là $O(N)$.</p><p>Như vậy tổng cộng thuật toán của ta là $O(N)$.</p><h2 id="brunhilda-1"><a href="#brunhilda-1" class="headerlink" title="brunhilda"></a>brunhilda</h2><h3 id="Quy-hoach-dong-1"><a href="#Quy-hoach-dong-1" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Gọi $f[i]$ là số bước nhỏ nhất để đưa $i$về 0. Ta có:</p><ul><li>$f[0] = 0$</li><li>$f[i] = \min\limits_{i \mod A[j] &gt; 0}^{1 \le j \le N}f[i - i \mod A[j]] + 1$</li></ul><p>Ta sẽ cần tính $f[i]$ với mọi $1 \le i \le 10^7$.Sau khi tính thì mỗi truy vấn ta trả lờitrong $O(1)$. Độ phức tạp sẽ là $O(10^7N)$,quá lớn, cần cải tiến.</p><h3 id="So-lan-thay-doi-gia-tri"><a href="#So-lan-thay-doi-gia-tri" class="headerlink" title="Số lần thay đổi giá trị"></a>Số lần thay đổi giá trị</h3><p>Xét $1 \le i \le N$. Giá trị tối ưu của$f[k \times A[i]]$ sẽ được cập nhật chocác số từ $k A[i] + 1$ đến $(k + 1)A[i] - 1$.Như vậy, có $10^7 / A[i]$ lần hàm thay đổigiá trị.</p><p>Do $A[i]$ là các số nguyên tố khác nhau, nênchỉ có $10^7 / 2 + 10^7 / 3 + … \le 29 \times 10^6$(10^5 số nguyên tố đầu) lần đổi giá trị.</p><p>Hơn nữa, ta cũng có thể thấy$f[kA[i]] \le f[(k + 1)A[i]] \le f[kA[i]] + 1$.Ta sẽ tìm cách sử dụng tính chất này khi tối ưu.</p><h3 id="Tinh-nhanh"><a href="#Tinh-nhanh" class="headerlink" title="Tính nhanh"></a>Tính nhanh</h3><p>Trước tiên, nếu một số là bội của tất cảcác số $A[i]$ thì chắc chắn số đó không thểbiến đổi được, ta sẽ không tính trường hợp đó.</p><p>Không khó để nhận ra $f[i]$ là hàm không giảmkhi $i$ tăng, vì thế ta có thể giữ lại mộtdeque các $f[j]$ còn thỏa mãn đứng trước, vàxóa dần đuôi khi chúng không còn được tính nữa.</p><p>$f[j]$ không được tính nữa khi với mọi $A[k]$là ước của $j$ thì $i \ge A<a href="j / A[k] + 1">k</a>$.</p><p>Ta có thể lưu lại bộ đếm của từng $j$, tiếndeque khi phần tử đầu tiên có bộ đếm về 0.</p><p>Tổng độ phức tạp sẽ là $O(29 \times 10^6 + N)$.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hôm nay bài không phải là khó.&lt;/p&gt;
&lt;h1 id=&quot;Tom-tat-de-bai&quot;&gt;&lt;a href=&quot;#Tom-tat-de-bai&quot; class=&quot;headerlink&quot; title=&quot;Tóm tắt đề bài&quot;&gt;&lt;/a&gt;Tóm tắ
      
    
    </summary>
    
      <category term="Training" scheme="http://blog.nkagami.me/categories/Training/"/>
    
    
      <category term="apio" scheme="http://blog.nkagami.me/tags/apio/"/>
    
      <category term="vietnamese" scheme="http://blog.nkagami.me/tags/vietnamese/"/>
    
      <category term="thầy Phương" scheme="http://blog.nkagami.me/tags/thay-Phuong/"/>
    
      <category term="Training" scheme="http://blog.nkagami.me/tags/Training/"/>
    
  </entry>
  
  <entry>
    <title>HSGSO 2016 Editorial</title>
    <link href="http://blog.nkagami.me/2017/05/01/HSGSO-2016-Editorial/"/>
    <id>http://blog.nkagami.me/2017/05/01/HSGSO-2016-Editorial/</id>
    <published>2017-05-01T10:00:00.000Z</published>
    <updated>2017-10-07T12:05:03.066Z</updated>
    
    <content type="html"><![CDATA[<p>Trong năm vừa rồi có kha khá nhiều bạn hỏi mìnhcũng như các bạn khác trong BTC HSGSO 2016 (mônTin) về solution của contest. Vì hồi đó không cóthời gian (<em>thực ra là lười</em>) nên bọn mình chưacó dịp chữa bài. Lần này mình quyết định làm chochót.</p><h1 id="De-bai"><a href="#De-bai" class="headerlink" title="Đề bài"></a>Đề bài</h1><p>Các bạn có thể tải đề bài gốc tại <a href="https://drive.google.com/file/d/0ByCMlnXUqIAIVmpSUWh6dHo1a2c/view" target="_blank" rel="noopener">đây</a>.</p><h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="Muc-luc"><a href="#Muc-luc" class="headerlink" title="Mục lục"></a>Mục lục</h2><ol><li><a href="#color">color</a></li><li><a href="#domino">domino</a></li><li><a href="#gift">gift</a></li><li><a href="#letter-o">letter-o</a></li><li><a href="#paren">paren</a></li><li><a href="#polylines">polylines</a></li><li><a href="#socket">socket</a></li><li><a href="#zigzag">zigzag</a></li></ol><h2 id="color"><a href="#color" class="headerlink" title="color"></a>color</h2><p><strong>Author</strong>: Nguyễn Đinh Quang Minh</p><h3 id="An-diem"><a href="#An-diem" class="headerlink" title="Ăn điểm"></a>Ăn điểm</h3><p>Để có 10% đầu tiên cho bài này ta nhận thấy chỉcó cách tô duy nhất là so le với $K = 2$, nhưvậy chỉ cần in $0$ khi $K = 1$ và $2$ khi $K = 2$ là bạn đã cầm trong tay 1 điểm đầu tiên.</p><h3 id="Bieu-dien-trang-thai"><a href="#Bieu-dien-trang-thai" class="headerlink" title="Biểu diễn trạng thái"></a>Biểu diễn trạng thái</h3><p>Ta sẽ tiếp cận bài toán, đầu tiên bằng phươngpháp quy hoạch động. Qhđ thường là hướng giảiđúng đối với những bài toán đếm. Để có thểtriển khai qhđ, ta cần biết cách biểu diễnmột trạng thái đang xây.</p><p>Để ý giới hạn của bảng là $3 \times N$. Vì chỉcó 3 ô nên ta hoàn toàn có thể biểu diễn trạngthái của một cột bằng một $K-$mask - một sốcó 3 chữ số trong đó các chữ số trong khoảng$0$ đến $K - 1$ (theo cơ số $K$). 2 chữ sốliên tiếp phải khác nhau, nên số trạng tháithỏa mãn một cột sẽ là $5 \times 4 \times 4 =80$ trạng thái với $K = 5$.</p><p>Ta có thể có hàm quy hoạch động đơn giản$f[i][mask]$ là số cách điền $i$ cột đầu tiên,trong đó cột cuối cùng có trạng thái là $mask$.Từ $f[i][mask]$ ta chuyển trạng thái sang$f[i + 1][mask’]$, for hết $mask’$ thỏa mãn.Ta có thể thấy cách này có độ phức tạp$O(80^2 N)$, chưa đủ thỏa mãn cả subtask 2.Kể cả khi ta chỉ lọc ra các $mask’$ thỏa mãnvà for chúng, ta vẫn có độ phức tạp $O(3380 N)$,vẫn chưa thể thỏa mãn subtask 2.</p><h3 id="Cai-tien-quy-hoach-dong"><a href="#Cai-tien-quy-hoach-dong" class="headerlink" title="Cải tiến quy hoạch động"></a>Cải tiến quy hoạch động</h3><p>Thay vì chuyển trạng thái cả cột cùng lúc, tacó thể thay bằng việc mỗi lần chỉ điền 1 ô, lầnlượt từ cột đầu sang cột cuối, mỗi cột điềntừ trên xuống dưới. Trạng thái ta lưu lại sẽlà trạng thái của $K$ ô cuối cùng ta điền.</p><p>Tại sao lại lưu như vậy? Thực chất, khi điền lầnlượt, ta chỉ cần quan tâm đến ô phía trên vàbên trái nó, tức ô cách ô hiện tại $1$ và $K$bước điền. Nhưng do ta cần tính cả các ô phíasau nên ta phải lưu trạng thái của cả $K$ ôtrước đó.</p><p>Gọi $f[i][j][mask]$ là số cách điền các ô từđầu đến $(i, j)$, với $K$ cuối cùng mình điềnđược lưu trong $mask$. Để chuyển sang ô tiếptheo, ta cần for một trong $K$ màu của ôtiếp theo ô $(i, j)$. Như vậy đpt sẽ là$O(100 <em> N </em> K * 3)$ ($5^2 \times 4$ trạng thái, dokhi lưu như này có thể tồn tại 2 ô liên tiếpcùng màu), vừa khít qua subtask 2. Code hơi trâunhưng không sao, worth it, vì ta đã có 50% sốđiểm.</p><p>Bạn có thể xem thêm 1 bài mình đã chữa có cáchqhđ tương tự ở <a href="https://natsukagami.github.io/2017/04/21/2017-04-20-Training/" target="_blank" rel="noopener">đây (bài Domino)</a>.</p><h3 id="Nhan-ma-tran"><a href="#Nhan-ma-tran" class="headerlink" title="Nhân ma trận"></a>Nhân ma trận</h3><p>Đối với những bạn đã biết về nhân ma trận, tacó thể bỏ qua phần quy hoạch động cải tiến phíatrên và thay vào đó, cải tiến qhđ $O(80^2 N)$thành nhân ma trận $O(80^3 \log N)$. Việcchuyển đổi không khó, thực chất ta chỉ cầndựng bảng chuyển đổi $80 \times 80$ xem 2 trạngthái nào có thể chuyển được cho nhau, mũ $N-1$lần lên rồi lấy ma trận $1 \times 80$ toàn 1(thể hiện hàng đầu) nhân cùng tích ban nãy,ra được một ma trận $1 \times 80$ mới, đáp sốchính là tổng các phần tử.</p><p>Việc nhân ma trận như nào chỉ là kĩ thuật cơbản nên mình sẽ không nói nhiều.</p><p>Kiến thức nhân ma trận, so với tối ưu quy hoạchđộng như trên, là phổ thông hơn nhiều, vì thếsubtask 3 không cho nhiều điểm như subtask 2.</p><h3 id="1-ti-mau"><a href="#1-ti-mau" class="headerlink" title="1 tỉ màu??"></a>1 tỉ màu??</h3><p>Đọc đến subtask 4 hẳn tất cả sẽ ngạc nhiên khi$K$ thay đổi đáng ngạc nhiên: từ $\le 5$ vàlà mấu chốt giải bài toán, thành $10^9$ -không còn đưa được vào độ phức tạp nữa. Để đàosâu vào subtask này, ta cần có một nhận xétvề tương quan các màu giữa các cột.</p><h4 id="Tuong-quan-cac-mau"><a href="#Tuong-quan-cac-mau" class="headerlink" title="Tương quan các màu"></a>Tương quan các màu</h4><p>Trong một cột, chỉ có 2 loại tương quan sau:</p><ul><li>$a,b,c$ - tức 3 ô trong cột khác nhau</li><li>$a,b,a$ - tức 2 ô đầu và cuối giống nhau</li></ul><p>Hơn nữa, số cách chọn màu cho cột $i + 1$ chỉphụ thuộc vào tương quan của hàng $i$, theo bảngsau:</p><ul><li>Từ $a, b, c$:<ul><li>Sang $a, b, c$: có $(K-1)+2(K-2)^2+(K-3)(K-1)+(K-3)(K-2)^2$ cách.</li><li>Sang $a, b, a$: có $(K-1)+(K-3)(K-2)$ cách.</li></ul></li><li>Từ $a, b, a$:<ul><li>Sang $a, b, c$: có $(K-1)+(K-3)(K-2)$ cách.</li><li>Sang $a, b, a$: có $(K-1)+(K-2)^2$ cách.</li></ul></li></ul><p>Việc chứng minh chỉ là công thức tổ hợp, mình sẽkhông chứng minh để chống dài dòng.</p><p>Như vậy ta không cần lưu cụ thể các màu, mà chỉcần tương quan giữa các màu, tức chỉ còn 2 trạngthái để quản lí chứ không nhiều như trưóc. Việc qhđ để ăn sub 4(độ phức tạp $O(2^2 N)$) hay nhân ma trận để ănsub 5 (độ phức tạp $O(2^3 \log N)$) có thể đượcthực hiện đơn giản.</p><h2 id="domino"><a href="#domino" class="headerlink" title="domino"></a>domino</h2><p><strong>Author</strong>: thầy Hồ Đắc Phương</p><h3 id="Backtrack"><a href="#Backtrack" class="headerlink" title="Backtrack"></a>Backtrack</h3><p>Ở subtask 1, đơn giản ta chỉ cần backtracktất cả các cách đặt domino. Do bảng chỉ có$2 \times 20$ nên không có đến $2^{20}$ cách đặtlà tối đa. Độ phức tạp sẽ là $O(2^N)$.</p><h3 id="Bo-de-lat-gach-co-ban"><a href="#Bo-de-lat-gach-co-ban" class="headerlink" title="Bổ đề: lát gạch cơ bản"></a>Bổ đề: lát gạch cơ bản</h3><p><strong>Đếm số cách lát gạch vào bảng $2 \times N$</strong></p><p>Có lẽ đây là bài toán nổi tiếng trong giớiVNOI. Cách giải khá đơn giản: quy hoạch động$f[i]$ là số cách lát $i$ cột đầu tiên. Tacó 2 cách lát: 1 viên dọc (chuyển xuống$f[i - 1]$) hoặc 2 viên ngang (chuyển xuống$f[i - 2]$). Độ phức tạp là $O(N)$, hoặc vìđây là phương trình đệ quy tuyến tính nênta có thể nhân ma trận $O(2^3 \log N)$.</p><p>Không khó để nhận ra $f[i]$ cũng chính làsố fibonacci, ta cũng có 1 số cách tínhchính xác khác trong $O(\log N)$.</p><h3 id="Cach-dien-duy-nhat"><a href="#Cach-dien-duy-nhat" class="headerlink" title="Cách điền duy nhất?"></a>Cách điền duy nhất?</h3><p>Để giải <em>tất cả subtask sau</em>, ta cần có chút quansát về các ô cấm:</p><ul><li>Nếu một cột bị cấm cả 2 ô, hiển nhiên tacó bên trái và bên phải là 2 bài toán riêngbiệt, ta chỉ cần tính riêng 2 bên rồi nhânvào nhau.</li><li>Nếu một cột bị chặn 1 ô, hiển nhiên ô đóthuộc một viên domino ngang. Ta sẽ phải lựachọn viên ngang đó nằm lệch về bên trái haybên phải.</li></ul><p>Ngạc nhiên thay, cách chọn ô đó là duy nhất.Để hiểu rõ tại sao, hãy xét 3 trường hợp sau:</p><h5 id="Nhan-1-ben"><a href="#Nhan-1-ben" class="headerlink" title="Nhận 1 bên"></a>Nhận 1 bên</h5><p><img src="/images/domino_one.png" alt="TH 1. Ô đỏ là ô cấm"></p><p>Hiển nhiên trong trường hợp này, số cách điềnlà 0. Đơn là vì có lẻ ô.</p><h5 id="Nhan-2-ben-dien-duoc"><a href="#Nhan-2-ben-dien-duoc" class="headerlink" title="Nhận 2 bên, điền được"></a>Nhận 2 bên, điền được</h5><p><img src="/images/domino_two.png" alt="TH 2, cách điền duy nhất"></p><p>Xét cột thứ nhất, ta có cách điền domino duynhất. Con domino này chắn 1 ô của cột thứ hai,làm cho bài toán đệ quy xuống. Tại mỗi bướcchỉ có một cách điền duy nhất nên với cả đoạncũng chỉ tồn tại 1 cách điền.</p><h5 id="Nhan-2-ben-khong-dien-duoc"><a href="#Nhan-2-ben-khong-dien-duoc" class="headerlink" title="Nhận 2 bên, không điền được"></a>Nhận 2 bên, không điền được</h5><p><img src="/images/domino_three.png" alt="TH 3"></p><p>Giống như trường hợp trên, nhưng vì khi đặtcon domino cuối cùng, ta bị đặt trùng lên ôcấm, nên ta không thể điền trường hợp này.</p><p>Phân biệt với TH 2 như nào? Ta điền đượckhi và chỉ khi:</p><ul><li>Cả đoạn độ dài chẵn <strong>và</strong> 2 ô cấm cùng hàng,<em>hoặc</em></li><li>Cả đoạn độ dài lẻ <strong>và</strong> 2 ô cấm khác hàng</li></ul><h3 id="Cach-tinh"><a href="#Cach-tinh" class="headerlink" title="Cách tính"></a>Cách tính</h3><p>Xét một đoạn bị chắn 2 đầu là cột 2 ô cấm (hoặcbiên, ta có thể coi 2 biên là 2 cột 2 ô cấm).Gọi $P_1, P_2, …, P_K$ là vị trí các cột có1 ô cấm, từ trái sang phải.</p><p>Hiển nhiên nếu $K$ lẻ thì có 0 cách điền vì cólẻ ô.</p><p><img src="/images/domino_all.png" alt="$P_1 = 3$, $P_2 = 5$, số cách điền là $f[2] \times 1 \times f[3]$"></p><p>Ta có:</p><ul><li>Xét đoạn $1..P_1$: Hiển nhiên viên ở $P_1$ sẽđặt sang phải vì nếu không ta sẽ có TH 1. Sốcách điền đoạn $1..P_1-1$ là $f[P_1 - 1]$.</li><li>Xét đoạn $P_1..P_2$: Vì viên ở $P_1$ đặt trọntrong đoạn nên $P_2$ cũng vậy, nếu không sẽbị TH 1. Số cách điền là 0 hoặc 1 phụ thuộcvào nó là TH 2 hay 3.</li><li>Xét đoạn $P_2..P_3$, vì viên ở $P_2$ nằmtrọn bên trái nên trường hợp này như đoạn$1..P_1$, số cách chọn là $f[P_3 - P_2 - 1]$.</li><li>Vân vân, xét đến khi ta gặp $P_{2k}..N$thì cũng như đoạn đầu, số cách là $f[N - 2k]$.</li></ul><p>Số cách điền cả đoạn sẽ là tích số cách điềntừng đoạn con.</p><p>Độ phức tạp là $O(N \log 10^9)$, vì ta tính$f[i]$ trong $O(\log i)$.</p><h3 id="Tai-sao-lai-chia-subtask-nhu-vay"><a href="#Tai-sao-lai-chia-subtask-nhu-vay" class="headerlink" title="Tại sao lại chia subtask như vậy?"></a>Tại sao lại chia subtask như vậy?</h3><p>Với $K = 4$, bạn có thể mập mờ nhìn ra tínhchất trên khi chia tất cả trường hợp 4 ô cấm.Bọn mình muốn hướng suy nghĩ phải theo mạchtự nhiên, không bị gò bó.</p><h2 id="gift"><a href="#gift" class="headerlink" title="gift"></a>gift</h2><p><strong>Author</strong>: Nguyễn Đức Duy</p><h3 id="Thuat-toan-backtrack"><a href="#Thuat-toan-backtrack" class="headerlink" title="Thuật toán backtrack"></a>Thuật toán backtrack</h3><p>Với $N \le 10$, ta có thể thực hiện backtrack,mỗi bước cho phần tử $i$ cho Alice, Bob hoặcgiữ lại. Đến cuối, nếu có đáp án, ta in ravà thoát chương trình.</p><p>Do mỗi bước ta có 3 lựa chọn nên độ phức tạplà $O(3^N)$.</p><h3 id="22-phan-tu"><a href="#22-phan-tu" class="headerlink" title="22 phần tử"></a>22 phần tử</h3><p>Với $N$ lớn hơn, hẳn là lượng tập concàng lớn so với giới hạn, vì thể xác suấttồn tại đáp số càng lớn.Ta sẽ chứng minh chỉ với 22 phần tử, luônluôn tồn tại đáp số.</p><p>Hiển nhiên, với 22 phần tử, ta có $2^{22} - 1$tập con không rỗng.Đồng thời, các tổng nằm trong khoảng $1..22 \times 10^5$.Vì $2^22 - 1 &gt; 22 \times 10^5$ nên theo địnhlí Dirichlet ta luôn có 2 tập có cùng tổng.</p><p>Gọi 2 tập này là $x$ và $y$. Chắc chắn 2 tậpnày không phải tập con của nhau, vì mỗi phầntử đều lớn hơn 0. Như vậy chắc chắn tồn tạiít nhất 1 phần tử của mỗi tập mà không tồntại trong tập kia.</p><p>Ta loại đi các phần tử có trong cả 2 (vìchúng cùng trừ cả 2 bên đi 1 lượng), vàcòn lại 2 tập không rỗng. Đây chính là đáp số.</p><p>Như vậy, với $N \ge 22$, ta chỉ cần bốc ra22 phần tử rồi tính tất cả tổng tập con, lấy2 tập bằng nhau và loại đi các phần tử trùnglà sẽ ra đáp số.</p><p>Độ phức tạp là $O(2^{22})$.</p><h3 id="N-“at-o”"><a href="#N-“at-o”" class="headerlink" title="$N$ “ất ơ”"></a>$N$ “ất ơ”</h3><p>Vậy với $10 &lt; N &lt; 22$ thì sao? Rất tiếc bọnmình không chuẩn bị được test mà giết đượcthuật ở trên. Tuy nhiên, ta vẫn có thểbacktrack gặp nhau ở giữa, lần lượt backtrack$3^{10}$ trường hợp ở đầu và $3^{N - 10}$trường hợp ở cuối, sau đó ghép 2 số cóhiệu trái dấu.Như vậy độ phức tạp sẽ không quá $O(3^{N / 2})$.</p><h2 id="letter-o"><a href="#letter-o" class="headerlink" title="letter-o"></a>letter-o</h2><p><strong>Author</strong>: mình</p><p>Lưu ý đây là bài output-only, vì vậy bạn có5 tiếng để chạy chứ không phải 1 giây.</p><h3 id="Thuat-toan-O-N-4"><a href="#Thuat-toan-O-N-4" class="headerlink" title="Thuật toán $O(N^4)$"></a>Thuật toán $O(N^4)$</h3><p>Thực ra thuật toán $O(N^4)$ khá đơn giản, tachỉ cần for 2 góc của hình chữ nhật và kiểmtra liệu 4 cạnh của chúng có chứa toàn cùngkí tự không. Để kiểm tra ta có thể tínhtrước mảng cộng dồn $O(N^2)$.</p><p>Lấy thuật $O(N^4)$ có thể chạy 1s đến input 5,và ăn 50% số điểm.Bài thật là dễ!</p><h3 id="Thuat-toan-O-N-3"><a href="#Thuat-toan-O-N-3" class="headerlink" title="Thuật toán $O(N^3)$"></a>Thuật toán $O(N^3)$</h3><p>Ta nhận thấy, nếu ta for trước 2 cạnh song songcủa hình chữ nhật, thì chỉ cần xét các vị trímà có toàn kí tự <code>x</code> nào đó trong cả đoạn nằmgiữa 2 cạnh. Ta sẽ chọn 2 điểm xa nhau nhất mà2 điểm đó dọc 2 cạnh đều là các kí tự giống nhau.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">11111</span><br><span class="line">10021</span><br><span class="line">10311</span><br><span class="line">11111</span><br><span class="line">10231</span><br><span class="line">11111</span><br><span class="line">10230</span><br><span class="line">11111</span><br></pre></td></tr></table></figure><p>Xét ví dụ trên, chọn 2 cột đầu cuối. Ta thấychỉ có các hàng 1, 4, 6 và 8 có thể làm 2cạnh ngang của hình chữ nhật. Ngoài ra,chỉ có 1, 4, 6 được nối với nhau. Ta chọnhình lớn nhất (1 - 6).</p><p>Việc lựa chọn có thể được thực hiện chỉ trong$O(N)$ bằng một vòng for lưu max. Như vậy tacó thuật $O(N^3)$ đủ ăn input 6.</p><h3 id="Suc-manh-cua-input"><a href="#Suc-manh-cua-input" class="headerlink" title="Sức mạnh của input!"></a>Sức mạnh của input!</h3><p>Đối với input 7 và 8, đáp số được đảm bảo làlớn, nên bạn có thể sử dụng chiến thuật chỉbài output-only mới có: sử dụng mắt.</p><p>Với mỗi số ta có thể in ra vị trí của chúng(và để trống những vị trí khác). Việc nhìnbằng mắt cũng sẽ cho ta thấy một số hình lớn,chỉ việc thử vào đáp số.</p><h3 id="Tim-kiem-pattern"><a href="#Tim-kiem-pattern" class="headerlink" title="Tìm kiếm pattern"></a>Tìm kiếm pattern</h3><p>Nếu nhìn kỹ, bạn có thể nhận ra input 9 có patternkhá dị, khi chỉ có một số hình chữ nhật. Bạn cóthể nhìn tay và chỉ chạy các miền có hình chữ nhậtthỏa mãn.</p><h3 id="…-hoac-khong"><a href="#…-hoac-khong" class="headerlink" title="… hoặc không"></a>… hoặc không</h3><p>Để giải input 10, bạn cần phải nhận ra quy tắcquan trọng nhất: bạn không bị giới hạn bởi thờigian chạy của máy chấm. Vì thế hãy nhập input10 vào, đặt cận đáp số và chờ 15-20 phút chomáy chạy. Tính trên máy trường mình, chỉ mất1h để chạy tất cả input với $O(N^3)$ đặt cậnđáp số! Bạn có 5 tiếng cơ mà, chạy trâu rồilàm bài khác… đó là chiến thuật của bài này.</p><h2 id="paren"><a href="#paren" class="headerlink" title="paren"></a>paren</h2><p><strong>Author</strong>: thầy Hồ Đắc Phương &amp; Phạm TùngDương.</p><h3 id="De-quy"><a href="#De-quy" class="headerlink" title="Đệ quy"></a>Đệ quy</h3><p>Thực chất đây chỉ là một bài tính toán cóchút lằng nhằng. Phương thức tính toán nhưsau, xét đoạn ngoặc $l..r$ là 1 cặp ngoặc:</p><ul><li>Tính tất cả các cặp ngoặc con $l_1..r_1, …, l_p..r_p$</li><li>Độ cao của $l..r$ là max độ cao của các cặp ngoặc con, cộng 1</li><li>Độ dài của $l..r$ là tổng độ dài của các cặpngoặc con, cộng $p-1$ khoảng cách ở giữa,cộng 2 hoặc 4 tùy loại ngoặc của $l..r$</li><li>Phần tô màu của $l..r$ là:<ul><li>Nếu viền ngoài cùng của $l..r$ là đen:độ dài $\times$ độ cao $-$ diện tích các hình con</li><li>Nếu không thì là 0</li><li>Sau đó cộng thêm phần tô màu các hình con</li></ul></li></ul><h3 id="Dung-cay"><a href="#Dung-cay" class="headerlink" title="Dựng cây"></a>Dựng cây</h3><p>Để có thể dựng quan hệ cha - con và tính đệ quytrong $O(N)$, ta sẽ cần dựng cây bằng stack.Cách dựng như sau:</p><ul><li>Duy trì 1 stack, lúc đầu stack rỗng</li><li>Đi từ trái sang phải, giả sử kí tự ta có là$S_x$:<ul><li>Nếu $S_x$ là mở ngoặc: Nếu stack không rỗng,thì cặp ngoặc $x$ có cha là đỉnh stack. Push$x$ vào stack.</li><li>Nếu $x$ là đóng ngoặc: xóa đỉnh stack.</li></ul></li></ul><p>Tổng độ phức tạp là $O(N)$.</p><h2 id="polylines"><a href="#polylines" class="headerlink" title="polylines"></a>polylines</h2><p><strong>Author</strong>: mình</p><h3 id="Quy-hoach-dong-trau-co-ban"><a href="#Quy-hoach-dong-trau-co-ban" class="headerlink" title="Quy hoạch động trâu cơ bản"></a>Quy hoạch động trâu cơ bản</h3><p>Để đơn giản ta coi điểm xuất phát là $0$,đích là $M + 1$.</p><p>Ta có công thức quy hoạch động: Gọi $f[i]$ làsố đường đi kết thúc ở $i$. Ta có</p><ul><li>$f[0] = 1$</li><li>$f[i] = \sum\limits_{X_j \le X_i, Y_j \le Y_i, i \neq j}f[j]$</li><li>Đáp số là $f[M + 1]$ - 1.</li></ul><p>Để có thứ tự qhđ ta chỉ cần sort các điểm theo cả 2 tọa độ tăngdần.Chỉ đơn giản vậy ta có thuật toán $O(N^2)$.</p><h3 id="Tang-toc"><a href="#Tang-toc" class="headerlink" title="Tăng tốc!"></a>Tăng tốc!</h3><p>Nhìn vào điều kiện của $j$ ở hàm qhđ, ta nhận thấy hoàn toàncó thể lấy nhanh tổng các $f[j]$ bằng 1 cấu trúcdữ liệu nào đó.</p><p>Nhận thấy, khi sort các phần tử theo $X$ rồi lấycác phần tử đứng trước, ta chỉ còn cần lọcđiều kiện $Y$ là đủ. Việc này ta hoàn toàn cóthể sử dụng BIT để lấy nhanh, sort tọa độ BITtheo $Y$ rồi get prefix, update điểm.</p><p>Độ phức tạp là $O(N \log N)$.</p><h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p><strong>Author</strong>: Nguyễn Đức Duy</p><h3 id="Tim-dap-an"><a href="#Tim-dap-an" class="headerlink" title="Tìm đáp án"></a>Tìm đáp án</h3><p>Không khó để nhận ra nếu chỉ có thể xếp được$K$ thiết bị, ta luôn lấy $K$ thiết bị cóđộ yêu cầu cao nhất. Vì vậy ta có thể sortthiết bị theo yêu cầu giảm dần rồi chặt nhịphân, kiểm tra xem có thể đặt $K$ thiết bịđầu tiên không.</p><h3 id="Xep-o-dien-nhu-nao"><a href="#Xep-o-dien-nhu-nao" class="headerlink" title="Xếp ổ điện như nào?"></a>Xếp ổ điện như nào?</h3><p>Ta có thể coi hệ thống ổ điện như một cây,trong đó gốc nối với nguồn. Xét 2 ổ điện$i$ và $j$, trong đó $i$ gần gốc hơn $j$.Nếu $A_i$ &lt; $A_j$, ta hoàn toàn có thểđổi chỗ $i$ và $j$ và đáp án không thểnhỏ hơn ban đầu. Vì thế, để xây cây từ gốc,ta đặt các ổ điện theo thứ tự $A_i$ giảm dần.</p><p>Với nhận xét trên, ta coi như $A_i$ đãđược xếp giảm dần. Giờ ta BFS theo từng tầng,dễ dàng nhận thấy khi xét tầng $x$:</p><ul><li>Nếu tồn tại $B_i = x$, lập tức phải đặt $i$vào tầng đó. Nếu không đặt được thì kiểmtra fail.</li><li>Mỗi lần ở tầng $x$ ta thêm ổ $j$ vào,thì bớt 1 chỗ ở tầng $x$ và thêm $A_j$ chỗở tầng $x + 1$. Vì $A_j$ dương nên sau khithêm ta luôn có nhiều chỗ ở tầng $x + 1$cho các $B_i &gt; x$ hơn ở tầng $x$. <em>Vì vậy,</em></li><li>Nếu $B_i &gt; x$, ta nhường cho ổ điện nếucòn, nếu không ta sẽ xét sau.</li></ul><h3 id="Tom-tat-thuat-toan"><a href="#Tom-tat-thuat-toan" class="headerlink" title="Tóm tắt thuật toán"></a>Tóm tắt thuật toán</h3><p>Ta chặt nhị phân $K$, kiểm tra xem có thểxếp $K$ thiết bị $B[1..K]$ vào không.</p><p>Để kiểm tra:</p><ul><li>Lúc đầu ở tầng 0 ta có 1 vị trí đặt (ổ điện)</li><li>Nếu có nhiều $B[i] = x$ hơn số vị trí đặt,kiểm tra fail. Nếu không, đặt hết $B[i] = x$.</li><li>Nếu còn chỗ ở tầng $x$ và còn ổ điện, đặt ổđiện cho tầng $x + 1$.</li><li>Nếu còn chỗ, coi như chúng của tầng $x + 1$.</li></ul><p>Độ phức tạp sẽ là $O((N + M) \log M)$, do các bướckiểm tra chỉ là $O(N + M)$.</p><h2 id="zigzag"><a href="#zigzag" class="headerlink" title="zigzag"></a>zigzag</h2><h3 id="Truong-hop-K-1"><a href="#Truong-hop-K-1" class="headerlink" title="Trường hợp $K = 1$"></a>Trường hợp $K = 1$</h3><p>Không khó để nhận thấy với 10 chữ số và điềukiện phải thăm mỗi số ít nhất 1 lần và khôngcần đúng thứ tự, ta sẽ cần sử dụng đến bitmask.Từ ngôi nhà nguồn, ta cần bfs đến các đỉnh, tìmđường đi ngắn nhất dựng ra đủ mask.</p><p>Trên đồ thị ta dựng ra các đỉnh $(i, j, mask)$,tức đứng ở ô $(i, j)$ và tập các số đã đi qua là$mask$. Từ đỉnh $(i, j)$ ta đi đến các đỉnh lâncận, thêm mask của đỉnh đó vào nếu cần, mất1 bước. Đáp số là khoảng cách đến đỉnh gần nhấtcó mask đầy đủ 10 bit.</p><p>Độ phức tạp là $O(NM2^{10})$.</p><h3 id="K-lon-hon"><a href="#K-lon-hon" class="headerlink" title="$K$ lớn hơn"></a>$K$ lớn hơn</h3><p>Với $K$ lớn đến $M \times N$, ta không thể chỉđơn giản là chạy thuật toán trên $K$ lần, vìnhư vậy là không thỏa mãn giới hạn bài toán.</p><p>Thay vào đó, ta cần một cách để có thể chạytất cả các truy vấn một lúc.</p><h3 id="Lat-nguoc-yeu-cau"><a href="#Lat-nguoc-yeu-cau" class="headerlink" title="Lật ngược yêu cầu"></a>Lật ngược yêu cầu</h3><p>Đề bài yêu cầu từ một ngôi nhà, ta đến mộtô bất kì, miễn là đủ mask trên đường đi. Tasẽ lật ngược yêu cầu lại, cho phép xuất pháttừ đỉnh bất kì, đi thoải mái, với điều kiệnkết thúc ở nhà và đủ mask trên đường đi.</p><p>Vậy điểm khác biệt là gì? Với bài toán không quantrọng đích với mỗi nguồn, ta cần BFS với từngnguồn riêng biệt. Tuy nhiên, với bài toán khôngquan trọng nguồn, ta có thể thực hiện BFS songsong nhiều nguồn, để tính khoảng cách từ <em>nguồngần nhất</em> tới mỗi đỉnh, với độ phức tạp chỉbằng 1 lần BFS.</p><p>Nói cách khác, thay vì ta xuất phát từ $(X_i,Y_i, 0)$, ta xuất phát từ tất cả các đỉnh$(i, j, 0)$ và tìm đường từ đỉnh bất kì đến$(X_i, Y_i, 1023)$. Để chạy song song, tưởngtượng có một nguồn ảo nối đến tất cả nguồnthật với trọng số 0. Như vậy, vì chỉ có 1nguồn (ảo), nên độ phức tạp chỉ là $O(NM2^{10})$.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Trong năm vừa rồi có kha khá nhiều bạn hỏi mình
cũng như các bạn khác trong BTC HSGSO 2016 (môn
Tin) về solution của contest. Vì hồi đó k
      
    
    </summary>
    
      <category term="Editorials" scheme="http://blog.nkagami.me/categories/Editorials/"/>
    
    
      <category term="vietnamese" scheme="http://blog.nkagami.me/tags/vietnamese/"/>
    
      <category term="editorial" scheme="http://blog.nkagami.me/tags/editorial/"/>
    
      <category term="hsgso" scheme="http://blog.nkagami.me/tags/hsgso/"/>
    
  </entry>
  
  <entry>
    <title>2017/04/28 Training</title>
    <link href="http://blog.nkagami.me/2017/04/28/2017-04-28-Training/"/>
    <id>http://blog.nkagami.me/2017/04/28/2017-04-28-Training/</id>
    <published>2017-04-28T13:00:00.000Z</published>
    <updated>2017-10-07T12:05:03.013Z</updated>
    
    <content type="html"><![CDATA[<p>Hôm nay có hai phần: bài thầy Hoàng và bàianh Khuê.Cả 2 đều cần một sự tay to nhất định.</p><h1 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h1><h2 id="select-thay-Hoang"><a href="#select-thay-Hoang" class="headerlink" title="select (thầy Hoàng)"></a>select (thầy Hoàng)</h2><p>Cho dãy $S$ gồm các kí tự <code>d</code> và <code>x</code>. 2 người lầnlượt chơi, mỗi lượt bốc 1 kí tự, kí tự này phải đứngcạnh 1 vị trí đã bị chọn trước đó (trừ nướcđầu tiên được chọn thoải mái). Khi trò chơikết thúc, người đi trước thắng khi có nhiều <code>d</code><strong>hơn hẳn</strong> người kia. Đếm số vị trí ban đầumà người đi trước có thể chọn mà vẫn đảm bảochiến thắng?</p><h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le |S| \le 1000$.</p><h2 id="eureka-thay-Hoang"><a href="#eureka-thay-Hoang" class="headerlink" title="eureka (thầy Hoàng)"></a>eureka (thầy Hoàng)</h2><p>Cho một hệ thống cân đĩa được biểu diễn nhưsau:</p><ul><li>Nếu chỉ gồm <code>-1</code>: Đây là một vị trí đặtquả cân.</li><li>Là một cái cân có dạng <code>x y A B</code> trong đó$x$ và $y$ lần lượt là độ dài cánh tay đònbên trái và bên phải của cân; $A$ và $B$ là2 hệ thống cân được treo vào bên trái vàbên phải của cân.</li></ul><p>Hình dưới biểu diễn hệ thống cân được biểu diễnbằng dãy <code>12 18 4 2 -1 -1 10 8 3 3 -1 -1 6 4-1 -1</code>:</p><p><img src="/images/eureka_exp.png" alt="Mô tả cân (các ô có nền xanh làcác quả cân)"></p><p>Trọng lượng các quả cân đều phải là sốnguyên dương.</p><p>Hãy tìm trọng lượng cho các quả cân của từng vịtrí đặt sao cho tất cả các cân đều thăng bằngvà tổng trọng lượng các quả cân phải đặt là nhỏnhất. Giả sử cân không có trọng lượng.</p><p>In ra tổng nhỏ nhất lấy dư cho $123456789$.</p><h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>Miêu tả được cho bởi dãy $A[1..N]$.</p><p>$1 \le N \le 3 \times 10^5$, $A[i] = -1$ hoặc$1 \le A[i] \le 100$.</p><h2 id="liondance-thay-Hoang"><a href="#liondance-thay-Hoang" class="headerlink" title="liondance (thầy Hoàng)"></a>liondance (thầy Hoàng)</h2><p>Cho 2 dãy số $A[1..N]$ và $B[1..N]$. Tìm dãycon chung dài nhất sao cho 2 phần tử liêntiếp chênh lệch nhau không quá $d$.</p><p>Nếu có nhiều dãy, in ra dãy có <strong>thứ tự từđiển</strong> lớn nhất.</p><h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 4000$, $1 \le A[i], B[i] \le 10^9$</p><h2 id="desert-thay-Hoang"><a href="#desert-thay-Hoang" class="headerlink" title="desert (thầy Hoàng)"></a>desert (thầy Hoàng)</h2><p>Trên mặt phẳng cho $N$ điểm. Tìm đường đi từ$1$ đến $N$ sao cho khoảng cách Manhattanlớn nhất giữa 2 điểm liên tiếp đi qua lànhỏ nhất.</p><h4 id="Gioi-han-3"><a href="#Gioi-han-3" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 10^5$, tọa độ $-10^9 \le X_i,Y_i\le 10^9$</p><h2 id="Tron-viec-anh-Khue"><a href="#Tron-viec-anh-Khue" class="headerlink" title="Trốn việc (anh Khuê)"></a>Trốn việc (anh Khuê)</h2><p>Cho dãy số $A[1..3N]$, chọn ra tập số cótổng lớn nhất sao cho trong $N$ số liêntiếp bất kì có không quá $K$ số được chọn.</p><h4 id="Gioi-han-4"><a href="#Gioi-han-4" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 200$, $1 \le K \le 10$, $1\le A[i] \le 10^6$</p><h2 id="Party1-anh-Khue"><a href="#Party1-anh-Khue" class="headerlink" title="Party1 (anh Khuê)"></a>Party1 (anh Khuê)</h2><p>Cho $N$ bạn nam và $M$ bạn nữ, và $K$ mốiquan hệ nam - nữ. Liệt kê tất cả bạn namvà bạn nữ chắc chắn sẽ xuất hiện trongcặp ghép cực đại.</p><h4 id="Gioi-han-5"><a href="#Gioi-han-5" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N, M \le 10^4$, $1 \le K \le 10^5$.</p><h2 id="Party2-anh-Khue"><a href="#Party2-anh-Khue" class="headerlink" title="Party2 (anh Khuê)"></a>Party2 (anh Khuê)</h2><p>Cho đồ thị $N$ đỉnh $M$ cạnh xanh $K$ cạnhđỏ, đỉnh $i$ có trọng số $A[i]$.Chọn một tập điểm có tổng trọng số lớn nhấtthỏa mãn:</p><ul><li>2 đỉnh có cạnh xanh nối giữa thì khôngđược cùng chọn.</li><li>2 đỉnh có cạnh đỏ nối giữa thì cùngđược chọn, hoặc cùng không được chọn.</li></ul><p>Đồng thời, đếm số cách chọn tối ưu.</p><h4 id="Gioi-han-6"><a href="#Gioi-han-6" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 250$, $0 \le M \le\frac{N(N-1)}{6}$,$\frac{N(N-1)}{3} \le K \le\frac{N(N-1)}{2}$</p><h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="Chuyen-doi-bai-toan"><a href="#Chuyen-doi-bai-toan" class="headerlink" title="Chuyển đổi bài toán"></a>Chuyển đổi bài toán</h3><p>Rất khó quản lí trạng thái thắng thua khibài toán yêu cầu so sánh số lượng. Vì vậy,ta sẽ biến đổi bài toán một chút - mặc dùtính chất thắng - thua không thay đổi.</p><p>Thay vì so sánh số lượng <code>d</code> của từng người,ta lấy số lượng <code>d</code> của người đi trước trừđi người đi sau. Hiển nhiên người đi trướcmuốn hiệu dương - tức <em>đối đa hóa</em> nó, vàngười đi sau muốn tối thiểu hóa nó.</p><p>Bởi vì đây là trò chơi hữu hạn bước, và2 người đều phải chơi tối ưu, nên ta sẽchỉ đi tìm một kết quả duy nhất: hiệu tối ưucủa trò chơi, với mỗi cách chọn bước đầu.</p><h3 id="Quy-hoach-dong"><a href="#Quy-hoach-dong" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Gọi $f[l][r]$ là hiệu tối ưu của trò chơi,nếu trò chơi bắt đầu với trạng thái đoạn$l..r$ bị khuyết. Ta có:</p><ul><li>Hiển nhiên $f[l][r] = 0$ nếu $l..r$ đãphủ toàn bộ vòng tròn.</li><li>Ta có thể hiểu độ dài $l..r$ sẽ tươngđương với số bước đã xảy ra, vì vậy ta cóthể biết được lượt đi tiếp theo là của ai.</li><li>Nếu đây là lượt của người đi trước, hẳnhắn ta sẽ muốn $f[l][r]$ lớn nhất có thể,tức hắn sẽ chọn vị trí $l - 1$ hay $r + 1$sao cho $f[l - 1][r]$ hoặc $f[l][r + 1]$,cộng vị trí hắn chọn nếu nó màu đỏ,sao cho tổng ấy lớn nhất có thể. Nóicách khác ta có:$$ f[l][r] = \max(f[l - 1][r] +(\text{S[l - 1] == ‘d’}), f[l][r + 1] +(\text{S[r + 1] == ‘d’}))$$</li><li>Ngược lại, người đi sau sẽ muốn lựachọn của mình là nhỏ nhất có thể, tức:$$ f[l][r] = \min(f[l - 1][r] -(\text{S[l - 1] == ‘d’}), f[l][r + 1] -(\text{S[r + 1] == ‘d’}))$$Lưu ý dấu <code>-</code>, bởi ta đang tối ưu hiệungười đi trước trừ người đi sau.</li></ul><p>Ta có thể tính tất cả các hàm $f[1][1]$,$f[2][2]$, …, $f[N][N]$ trong độ phứctạp $O(N^2)$.</p><h3 id="Dem-vi-tri-tot"><a href="#Dem-vi-tri-tot" class="headerlink" title="Đếm vị trí tốt"></a>Đếm vị trí tốt</h3><p>Một vị trí $i$ thỏa mãn đầu bài nếu nhưhiệu tối ưu lớn hơn $0$, bởi khi đó ngườithứ nhất luôn có thể làm cho mình có nhiều<code>d</code> hơn. Như vậy, ta chỉ cần thử hết cácvị trí $i$ và kiểm tra xem $f[i][i] &gt; 0$đúng không.</p><p>Tổng độ phức tạp của bài toán là $O(N^2)$.</p><h2 id="eureka"><a href="#eureka" class="headerlink" title="eureka"></a>eureka</h2><h3 id="Tinh-chat-cua-tong-trong-luong"><a href="#Tinh-chat-cua-tong-trong-luong" class="headerlink" title="Tính chất của tổng trọng lượng"></a>Tính chất của tổng trọng lượng</h3><p>Xét một hệ thống cân, không khó để chứngminh tổng trọng lượng của nó phải làmột bội của số $X$ tương ứng với từnghệ thống.</p><p>Nhiệm vụ của ta là đi tìm $X$ đó cho cả hệthống lớn, bằng cách tính từ các hệ thốngcon.</p><h3 id="Quy-nap"><a href="#Quy-nap" class="headerlink" title="Quy nạp"></a>Quy nạp</h3><p>Hiển nhiên quả cân có thể nhận trọng lượngbất kì, vậy quả cân là hệ thống cân có $X$là 1.</p><p>Ta xét hệ thống cân $a, b, X_l, X_r$ trongđó $X_l, X_r$ là các giá trị mình đã tínhtrước đó cho hệ thống cân bên trái và phải.Ta có:</p><ul><li>Tồn tại $(p, q) = 1$ sao cho $paX_l =qbX_r$. Hiển nhiên đây là $p$ và $q$ cótổng nhỏ nhất thỏa mãn.</li><li>Khi đó, $X = pX_l + qX_r$.</li></ul><p>Ta có thể nhận thấy $\frac{p}{q} =\frac{bX_r}{aX_l}$, vậy $p = bX_r / d$ và$q = aX_l / d$ với $d = \gcd(aX_l, bX_r)$.Như vậy $X = \dfrac{X_l X_r(a + b)}{d}$.</p><h3 id="So-lon"><a href="#So-lon" class="headerlink" title="Số lớn"></a>Số lớn</h3><p>Ta nhận thấy từ công thức trên rằngđáp số có thể rất lớn. Ta không cần phải insố lớn, tuy vậy các phép tính như $\gcd$không thể được tính khi số đã bị mod.</p><p>Tuy nhiên ta cũng không cần phải cài sốlớn: Mỗi lần ta nhân thêm một số $a + b\le 200$, nên thay vì lưu số lớn ta sẽlưu tập ước nguyên tố và số mũ. Khi đó,các phép nhân (cộng số mũ), chia (trừsố mũ), lấy $\gcd$ (lấy min số mũ) trởnên đơn giản, với độ phức tạp $O(A[i])$.</p><p>Ta có thuật toán đáp số với độ phức tạp$O(N * A[i])$.</p><h3 id="Cai-dat"><a href="#Cai-dat" class="headerlink" title="Cài đặt"></a>Cài đặt</h3><p>Một cách cài đặt ngắn gọn là sử dụngđệ quy, vừa đọc vừa làm.Ta thực hiện lần lượt:</p><ul><li>Đọc $a$ và kiểm tra xem có phải quả cânkhông. Nếu có trả về 1.</li><li>Đọc $b$.</li><li>Đệ quy giải bên trái $X_l$.</li><li>Đệ quy giải bên phải $X_r$.</li><li>Tính và trả về $X$.</li></ul><h2 id="liondance"><a href="#liondance" class="headerlink" title="liondance"></a>liondance</h2><h3 id="Quy-hoach-dong-1"><a href="#Quy-hoach-dong-1" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Về cơ bản, đây chỉ là bài toán LCS có thêmđiều kiện, vì vậy hướng suy nghĩ của tatất nhiên là cải thiện thuật toán quy hoạchđộng LCS, vì độ phức tạp yêu cầu cũng tươngđương.</p><p>Vậy làm sao để quản lí trạng thái vẫn là$[i][j]$ khi ta còn cần thông tin về 2 phầntử liên tiếp? Ta sẽ cần “gói” nhiều thôngtin hơn vào trạng thái $(i, j)$.</p><h3 id="Them-thong-tin"><a href="#Them-thong-tin" class="headerlink" title="Thêm thông tin!"></a>Thêm thông tin!</h3><p>Ta sẽ định nghĩa hàm quy hoạch động như sau:Gọi $f[i][j]$ là dãy con chung dài nhấtkhi sử dụng đoạn $A[i..N]$, đoạn $B[i + 1..N]$<strong>và $B[j]$ là phần tử cuối cùng được thêmở đầu đoạn</strong> (để đơn giản, ta không tínhcặp $B[j]$ - ?? vào đáp số, cũng như coi $B[0]$ là phần tử có thể ghép với mọi thứ).</p><h4 id="Tai-sao-lai-dinh-nghia-nhu-vay"><a href="#Tai-sao-lai-dinh-nghia-nhu-vay" class="headerlink" title="Tại sao lại định nghĩa như vậy?"></a>Tại sao lại định nghĩa như vậy?</h4><p>Nhờ có việc đánh dấu $B[j]$ là số được thêmvào cuối cùng, ta có thể quản lí giá trịcó thể thêm vào tiếp theo.Khi có $f[i][j]$, và $A[i] = B[k]$ ($k \gej + 1$), điều kiện duy nhất đẻ kiểm trachỉ là $|B[j] - B[k]| \le d$.</p><h4 id="Tai-sao-lai-tu-cuoi"><a href="#Tai-sao-lai-tu-cuoi" class="headerlink" title="Tại sao lại từ cuối?"></a>Tại sao lại từ cuối?</h4><p>Để giúp cho việc truy vết thứ tự từ điển,sau này mình sẽ nói đến.</p><p>Ta có thể tính hàm quy hoạch động này nhưsau - $f[i][j]$ có thể được tính từ các trạngthái:</p><ul><li>$f[i + 1][j]$, hiển nhiên</li><li>$f[i + 1][k] + 1$, với $k \ge j + 1$ và$A[i] = B[k]$.</li></ul><p>Độ phức tạp là $O(N^3)$. Ta sẽ cần một chútquan sát để hạ độ phức tạp.</p><h3 id="Nhay-xuong-O-N-2"><a href="#Nhay-xuong-O-N-2" class="headerlink" title="Nhảy xuống $O(N^2)$"></a>Nhảy xuống $O(N^2)$</h3><p>Khi xét $f[i][j]$, ta có thể thấy nếu$k \le k’$ và $A[i] = B[k] = B[k’]$ thì$f[i + 1][k] \ge f[i + 1][k’]$. Chứng minhrất đơn giản: $B[k + 1..N]$ dài hơn$B[k’ + 1..N]$, mà điều kiện ghép không đổi.</p><p>Vì vậy, thực chất ta chỉ cần tìm $k$ nhỏnhất thỏa mãn $k \ge j + 1$ và $A[i] = B[k]$để cập nhật vào $f[i][j]$. Việc này có thểthực hiện bằng việc đánh dấu khi for ngược$i$ và $j$, nên độ phức tạp chỉ còn $O(N^2)$.</p><h3 id="Thu-tu-tu-dien"><a href="#Thu-tu-tu-dien" class="headerlink" title="Thứ tự từ điển"></a>Thứ tự từ điển</h3><p>Khi quy hoạch động $f[i][j]$, ta sẽ lưu thêm$nx[i][j]$ là chỉ số $B[k]$ mà mình chọn làmkí tự tiếp theo. Do điều kiện của dãy đáp sốlà phụ thuộc vào <em>giá trị</em> chứ không phảichỉ số, ta sẽ phải thêm vào các điều kiện sauđây để đảm bảo lựa chọn chỉ số tiếp theo chotruy vết:</p><ul><li>Hiển nhiên nếu $f[i + 1][j] \neq f[i + 1][k]$thì ta chọn cái nào lớn hơn, vì được dãy dàihơn.</li><li>Nếu bằng nhau, hiển nhiên trong $B[nx[i + 1][j]]$và $B[k]$ cái nào lớn hơn ta chọn.</li><li>Nếu vẫn bằng nhau, ta nhận thấy chắc chắn$nx[i + 1][j] \ge k$, do vậy từ $(i + 1, k)$ta có nhiều lựa chọn hơn (và có tất cả lựachọn của) $(i + 1, nx[i + 1][j])$, nên tasẽ chọn $(i + 1, k)$.</li></ul><p>Khi đã có mảng $nx[i][j]$, việc truy vết trởthành đơn giản.</p><h2 id="desert"><a href="#desert" class="headerlink" title="desert"></a>desert</h2><h3 id="Cay-khung-Manhattan"><a href="#Cay-khung-Manhattan" class="headerlink" title="Cây khung Manhattan"></a>Cây khung Manhattan</h3><p>Bản chất của việc dựng đường đi sao chocạnh $\max$ là $\min$ chính là dựng cây khungnhỏ nhất của đồ thị.</p><p>Từ việc chăm chỉ đọc wiki, ta cũng biết cóthể dựng lên cây khung giữa các đỉnh theokhoảng cách Manhattan với độ phức tạp$O(N \log N)$. Thực chất đây chỉ là bàiyêu cầu implement thuật toán đó.</p><h3 id="Dung-cay-khung-nhu-nao"><a href="#Dung-cay-khung-nhu-nao" class="headerlink" title="Dựng cây khung như nào?"></a>Dựng cây khung như nào?</h3><p>Ta có thể <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/line-sweep-algorithms/" target="_blank" rel="noopener">chứng minh</a>rằng, để dựng cây khung Manhattan, với mỗiđiểm ta chỉ cần nối cạnh đến đỉnh gần nó nhấttrong mỗi <a href="https://www.wikiwand.com/en/Octant_(plane_geometry" target="_blank" rel="noopener">góc phần tám</a>).Vậy tìm chúng như thế nào?</p><h4 id="Tim-diem-gan-nhat-trong-goc-phan-tam"><a href="#Tim-diem-gan-nhat-trong-goc-phan-tam" class="headerlink" title="Tìm điểm gần nhất trong góc phần tám"></a>Tìm điểm gần nhất trong góc phần tám</h4><p>Giả sử ta sẽ giải bài toán cho góc phần támcó $X \le X_0$, $Y \le Y_0$ và $X - Y \le X_0 - Y_0$.</p><p>Ta sắp xếp các điểm theo thứ tự $X_i - Y_i$giảm dần, và thêm vào một IT có tọa độ đượcxếp theo $X_i$ giá trị $X_i + Y_i$ lấy $\max$.</p><p>Với mỗi điểm, ta <code>get</code> trong IT giá trị$X_j + Y_j$ lớn nhất với $X_j \le X_i$, rồicập nhật điểm đó vào IT. Điểm <code>get</code> rasẽ là điểm gần nhất theo góc phần tám này.</p><p>Để hiểu tại sao sắp xếp như vậy lại đúng,xem hình dưới.</p><p><img src="/images/desert_tree_upd.png" alt="Phần được gọi khi xét điểm $A$. Phầntô màu đã được thêm vào IT, phần màu xanhthể hiện phần được get trong IT"></p><p>Dễ dàng làm với góc phần tám đối diện, chỉcần for tập điểm ngược lại.</p><h4 id="Giai-nhanh-tat-ca-cac-phan"><a href="#Giai-nhanh-tat-ca-cac-phan" class="headerlink" title="Giải nhanh tất cả các phần"></a>Giải nhanh tất cả các phần</h4><p>Thay vì cài tất cả các trường hợp góc phầntám, ta có thể chỉ cần giải 2 góc đối diệnnhư trên, rồi thực hiện <a href="https://quizlet.com/6704360/rotation-rules-for-mrs-nelsons-geometry-flash-cards/" target="_blank" rel="noopener">phép quay 90 độ</a>cho tất cả các điểm theo gốc, và tiếp tục giải.</p><p>Hiển nhiên sau khi xoay 3 lần ta sẽ giải đủ 8góc phần tám.</p><h2 id="Tron-viec"><a href="#Tron-viec" class="headerlink" title="Trốn việc"></a>Trốn việc</h2><h3 id="Lien-tuong"><a href="#Lien-tuong" class="headerlink" title="Liên tưởng"></a>Liên tưởng</h3><p>Trong một hệ thống $N$ máy song song, ta phảiđảm bảo trong khoảng thời gian $M$ bất kìkhông có quá $N$ thao tác được thực hiện trênbất cứ máy nào.Ta sẽ làm như nào?</p><p>Một cách đơn giản là ra lệnh cho một máy,sau khi thực hiện một thao tác, sẽ ngủ trong$M$ giây. Như vậy, không có khoảng thời gian$M$ nào có một máy chạy 2 lần, vì thế khôngcó chuyện có nhiều hơn $N$ thao tác được chạy.</p><p>Ta sẽ sử dụng ý tưởng này cho bài toán.</p><h3 id="Bien-doi-bai-toan"><a href="#Bien-doi-bai-toan" class="headerlink" title="Biến đổi bài toán"></a>Biến đổi bài toán</h3><p>Đề bài yêu cầu ta chọn một tập lớn nhất saocho cứ $N$ phần tử liên tiếp bất kì có khôngquá $K$ phần tử được chọn. Ta sẽ biến bàitoán thành: Cho phép chạy $K$ máy lựa chọnsong song, mỗi phần tử chỉ được cho một máylựa chọn, trong khoảng $N$ bất kì khôngcó máy nào chọn liên tiếp 2 phần tử.</p><p>Nếu $K = 1$, ta có thể sử dụng quy hoạch động$f[i] = \max(f[i - 1], f[i - N] + A[i])$. Với$K$ lớn hơn, ta sẽ phải tìm cách khác để đảmbảo mỗi phần tử chỉ được tối đa một máy lựa chọn.</p><p>Hãy tưởng tượng một đường ống $3N + 1$ đoạn liêntiếp nối thành một đường thẳng. Ngoài rađường ống thứ $i$ còn được nối với $\min(i + N, 3N + 1)$. Từ đỉnh 1 ta cho $K$ robotchạy về hướng $3N + 1$. Các robot có thểđi đường $i$ - $i + 1$ thoải mái, nhưngmỗi đường đi $i$ - $i + N$ chỉ có thể cho1 robot đi qua, đồng thời sẽ thu về $A[i]$đồng tiền. Ta cần thu về nhiều tiền nhấtcó thể.</p><p>Nghe rất giống một bài luồng max cost.</p><h3 id="Dung-luong"><a href="#Dung-luong" class="headerlink" title="Dựng luồng"></a>Dựng luồng</h3><p>Ta áp dụng toàn bộ ý tưởng của đường ống vàoluồng.</p><ul><li>$3N + 2$ đỉnh, $0$ là nguồn $3N + 1$ là đích.</li><li>$0$ =&gt; $1$: cap = $K$, cost = $0$</li><li>Với $i &gt; 0$, $i$ =&gt; $i + 1$: cap = $inf$, cost = $0$</li><li>Với $i &gt; 0$, $i$ =&gt; $\min(i + N, 3N + 1)$: cap = $1$, cost = $A[i]$</li></ul><p>Trên mạng, ta tìm luồng max cost. Hiển nhiênluồng cực đại là $K$, nhưng ta chỉ cần quantâm đến cost tối đa. Cost chính là đáp số.</p><p>Độ phức tạp là <code>O(luồng 600 đỉnh 1000 cạnh)</code>.</p><h2 id="Party1"><a href="#Party1" class="headerlink" title="Party1"></a>Party1</h2><h3 id="Thay-doi-muc-tieu"><a href="#Thay-doi-muc-tieu" class="headerlink" title="Thay đổi mục tiêu"></a>Thay đổi mục tiêu</h3><p>Thay vì đi tìm những đỉnh mà xuất hiện trongmọi cặp ghép cực đại, ta sẽ tìm những đỉnhkhông có tính chất đó. Thật vậy, ta sẽ cầntìm những đỉnh mà khi bỏ nó đi, kích cỡ cặp ghépcực đại vẫn không thay đổi.</p><h3 id="Tinh-chat-cua-cap-ghep"><a href="#Tinh-chat-cua-cap-ghep" class="headerlink" title="Tính chất của cặp ghép"></a>Tính chất của cặp ghép</h3><p>Đầu tiên, ta dựng cặp ghép cực đại trên đồ thịđã cho. Hiển nhiên các đỉnh không thuộc cặpghép là các đỉnh cần tìm. Ta sẽ chỉ xét đếncác đỉnh thuộc cặp ghép.</p><p>Giả sử $v_0$ là một đỉnh không được ghép.Xét đường tăng $v_0, v_1,…, v_{2k}$. Hiểnnhiên độ dài đường tăng phải chẵn, nếu khôngta có thể tăng số cặp ghép, không thỏa mãntính chất cặp ghép cực đại.</p><p>Ta nhận thấy, nếu xóa đi 1 trong các đỉnh$v_2, v_4, …,v_{2k}$, ta sẽ tách đường tănghiện tại ra thành 1 đường tăng lẻ, đồng thời số cặp ghép giảm đi 1.Tuy nhiến, do tồn tại đường tăng lẻ nên tacó thể đảo lại, làm tăng số cặp ghép về nhưcũ. Vì vậy $v_2, v_4, …, v_{2k}$ đều làcác đỉnh cần tìm.</p><p>Nếu một đỉnh $x$ khi xóa đi không tạo rađường tăng lẻ nào (nhưng làm giảm số cặp ghép),chắc chắn nó không phải đỉnh cần tìm.</p><p><img src="/images/party1_exp.png" alt="Các cạnh xanh là cạnh cặp ghép. Xétđường tăng DHCGBFA (tím xanh), nếu bỏ B, đường tăngDHCG sẽ là đường lẻ, tăng cặp ghép về như cũ.Tương tự với C và A. Đường tăng JEI (xanh dương-xanh) cũng vậy."></p><h3 id="Thuat-toan"><a href="#Thuat-toan" class="headerlink" title="Thuật toán"></a>Thuật toán</h3><p>Trước tiên, tìm cặp ghép. Sau đó, ta BFS từ cácđỉnh không được cặp ghép, đi theo các đường tăng,đánh dấu các đỉnh cùng phía được thăm.</p><p>Do tính chất của đồ thị 2 phía nên ta chỉ cần 2lần BFS, mỗi lần xuất phát từ tất cả các đínhkhông được thăm trên cùng 1 phía.</p><p>Độ phức tạp sẽ là $O(K \sqrt{N + M})$ do cặpghép.</p><h2 id="Party2"><a href="#Party2" class="headerlink" title="Party2"></a>Party2</h2><h3 id="Nen-do-thi"><a href="#Nen-do-thi" class="headerlink" title="Nén đồ thị"></a>Nén đồ thị</h3><p>Với tập đỉnh đỏ, ta sẽ gộp tất cả các đỉnh liênthông lại thành một, cộng tất cả các trọng số lại.Bài toán trở thành tìm tập độc lập cực đại trênđồ thị cạnh xanh.</p><p>Đây là một bài <strong>NP-Hard</strong>, chưa thể giải vớigiới hạn $N \le 250$.</p><h3 id="So-luong-dinh"><a href="#So-luong-dinh" class="headerlink" title="Số lượng đỉnh"></a>Số lượng đỉnh</h3><p>Một chi tiết quan trọng là số lượng cạnh đỏrất lớn. Với $N = 250$ và $K = \frac{N(N-1)}{3}$,chỉ có tối đa $46$ đỉnh đã gộp (bao gồm 205đỉnh có clique và 45 đỉnh bậc 0).</p><p>Từ đây, ta có chút hi vọng với thuật backtrack.</p><h3 id="Dat-can"><a href="#Dat-can" class="headerlink" title="Đặt cận!"></a>Đặt cận!</h3><p>Đây là danh sách cận cần thiết để hi vọng quađược đống test(?):</p><ul><li>Sort các đỉnh theo bậc rồi backtrack dần</li><li>Xử lí nhanh các đỉnh bị cấm</li><li>Loại bỏ các trường hợp khi tổng các đỉnh cònlại không lớn hơn max hiện tại</li><li>Tính riêng các tplt rồi nhân với nhau</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hôm nay có hai phần: bài thầy Hoàng và bài
anh Khuê.
Cả 2 đều cần một sự tay to nhất định.&lt;/p&gt;
&lt;h1 id=&quot;Tom-tat-de-bai&quot;&gt;&lt;a href=&quot;#Tom-tat-
      
    
    </summary>
    
      <category term="Training" scheme="http://blog.nkagami.me/categories/Training/"/>
    
    
      <category term="training" scheme="http://blog.nkagami.me/tags/training/"/>
    
      <category term="apio" scheme="http://blog.nkagami.me/tags/apio/"/>
    
      <category term="vietnamese" scheme="http://blog.nkagami.me/tags/vietnamese/"/>
    
      <category term="thầy Hoàng" scheme="http://blog.nkagami.me/tags/thay-Hoang/"/>
    
      <category term="anh Khuê" scheme="http://blog.nkagami.me/tags/anh-Khue/"/>
    
  </entry>
  
  <entry>
    <title>2017/04/25 Training</title>
    <link href="http://blog.nkagami.me/2017/04/25/2017-04-25-Training/"/>
    <id>http://blog.nkagami.me/2017/04/25/2017-04-25-Training/</id>
    <published>2017-04-25T13:00:00.000Z</published>
    <updated>2017-10-07T12:05:03.012Z</updated>
    
    <content type="html"><![CDATA[<p>Hôm nay có khá nhiều bài trí tuệ.</p><h1 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h1><h2 id="wash"><a href="#wash" class="headerlink" title="wash"></a>wash</h2><p>Cho $N$ máy giặt và $M$ máy sấy chạy song song,thời gian giặt là $A[1..N]$, sấy là $B[1..M]$ chotừng máy. Tìm thời gian nhỏ nhất để giặt xong$L$ quần áo.</p><h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N, M \le 10^5$, $1 \le L \le 10^6$,$1 \le A[i], B[i] \le 10^9$.</p><h2 id="mars"><a href="#mars" class="headerlink" title="mars"></a>mars</h2><p>Cho $N$ nhà kho với sức chứa $C[1..N]$, banđầu các nhà kho rỗng. Trong ngày thứ $i$($1 \le i \le D$), nhà kho $j$ nhận thêm$A[i][j]$ món hàng, đồng thời bạn được chuyểntổng cộng $d[i]$ món hàng ra khỏi các nhà kho.Việc chuyển ra được thực hiện sau khi nhậnhàng. Hỏi sau $N$ ngày liệu có thể chuyểntất cả hàng hóa đã nhận không?</p><h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N, D \le 30$,$1 \le C[i], A[i][j], d[i] \le 10^6$</p><h2 id="government"><a href="#government" class="headerlink" title="government"></a>government</h2><p>Cho $N$ điểm, điểm $i$ có trọng số $A[i]$.Tìm cách đặt các điểm vào các tọa độ nguyêncủa đoạn thẳng $[1..M]$ (mỗi tọa độ chứakhông quá 1 điểm) để tối đa hóa:$$\sum\limits_{i = 1}^N \sum\limits_{j = i + 1}^N |x_i - x_j| \times A[i] \times A[j]$$</p><p>Với $x_i$ là tọa độ điểm $i$.</p><h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le M \le 10^6$, $1 \le N \le 1000$,$1 \le A[i] \le 100$.</p><h2 id="permutation"><a href="#permutation" class="headerlink" title="permutation"></a>permutation</h2><p>Xét một hoán vị $P$, gọi $R[i]$ là bán kính của$P_i$ nếu $R[i]$ là số lớn nhất thỏa mãn:</p><ul><li>$1 \le i - R[i]$ và $i + R[i] \le N$</li><li>$P_j &lt; P_i$ với mọi $i - R[i] \le j &lt; i$</li><li>$P_j &lt; P_i$ với mọi $i &lt; j \le i + R[i]$</li></ul><p>Cho số $N$ và dãy $R[1..N]$, đếm số hoán vị$P$ độ dài $N$ có bán kính của $P_i$ là $R[i]$với mọi $1 \le i \le N$.</p><h4 id="Gioi-han-3"><a href="#Gioi-han-3" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 1000$.</p><h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="wash-1"><a href="#wash-1" class="headerlink" title="wash"></a>wash</h2><h3 id="Tham-lam-tren-mot-may"><a href="#Tham-lam-tren-mot-may" class="headerlink" title="Tham lam trên một máy"></a>Tham lam trên một máy</h3><p>Giả sử bài toán chỉ có một loại máy (máy giặtchẳng hạn, phơi thôi sấy làm gì tốn điện), tacó thể sử dụng thuật toán tham lam: Với mỗibước ta chọn máy giặt mà có <strong>thời điểm hoànthành đồ tiếp theo</strong> (không phải đồ máy đóđang giặt - nếu có) là nhỏ nhất.</p><p>Không khó để chứng minh thuật toán này là tốiưu. Việc cài đặt cũng không khó khăn, chỉcần sử dụng 1 <code>priority_queue</code>.</p><p>Độ phức tạp là $O(L \log N)$.</p><p>Mạnh hơn thế, thuật toán này cho ta khôngchỉ đáp án tối ưu, mà từng phần tử cũng tốiưu: <strong>Không thể giặt đồ thứ $i$ xongtrước thời điểm $T[i]$.</strong></p><h3 id="Chat-nhi-phan-ket-qua"><a href="#Chat-nhi-phan-ket-qua" class="headerlink" title="Chặt nhị phân kết quả"></a>Chặt nhị phân kết quả</h3><p>Theo tính chất bài toán, ta có thể chặt nhịphân kết quả. Bài toán trở thành kiểm tra,liệu trong thời gian $X$ có thể giặt vàsấy $L$ quần áo không?</p><p>Để kiểm tra, đầu tiên ta sẽ tham lam theo thuậttoán trên để có tập thời gian giặt xong củatừng đồ, $T[i]$.</p><p>Sau đó, ta “lật ngược” trục trời gian lại,xuất phát từ thời điểm $L$ và thực hiện tínhtập thời gian sấy $V[i]$, <em>cũng bằng thuậttham lam trên</em>. Tại sao thuật tham lam vẫnđúng? Tại vì, với mỗi máy, ta chỉ cần đảongược thứ tự sấy các đồ của máy đó là tổngthời gian vẫn không đổi, các đồ được sấyđúng thứ tự xuôi trục thời gian.</p><p>Việc cuối cùng là dựng lên cặp ghép $T[i]$ - $V[i]$sao cho $i$ ghép với $j$ thì $T[i] + V[j] &lt; X$.Ta có thể tưởng tượng là giặt mất $T[i]$,đợi đến $X - V[j]$ rồi sấy mất $V[j]$.</p><p>Hiển nhiên cách ghép tối ưu nhất là ghép $T[i]$nhỏ nhất với $V[j]$ lớn nhất, nhỏ nhì với lớnnhì và vân vân…</p><p>Ta có thuật toán $O(L \log N \log 10^{15})$,chưa đủ mạnh.</p><h3 id="Khu-chat-nhi-phan"><a href="#Khu-chat-nhi-phan" class="headerlink" title="Khử chặt nhị phân"></a>Khử chặt nhị phân</h3><p>Ta nhận thấy việc tính mảng $T[i]$ và $V[i]$không liên quan đến việc chặt nhị phân, vìthế thực chất việc chặt nhị phân của tachỉ là tìm giá trị max của việc ghép cặp.</p><p>Như vậy, không cần chặt nhị phân, ta chỉcần tìm 2 mảng trên, thực hiện ghép cặprồi tìm giá trị max.</p><p>Độ phức tạp là $O(L \log N)$.</p><h2 id="mars-1"><a href="#mars-1" class="headerlink" title="mars"></a>mars</h2><h3 id="Luong"><a href="#Luong" class="headerlink" title="Luồng"></a>Luồng</h3><p>Ta có thể để ý, đề bài gồm một số đầu vào,một số đầu ra và yêu cầu kiểm tra xemcó thể truyền từ đầu vào sang đầu ra không.Đây chính là đặc điểm của bài toán luồngcực đại - vì thế đây là bài luồng cơ bản.</p><p>Ngoài ra, giới hạn nhỏ của đề bài cũngủng hộ ý tưởng luồng.</p><h3 id="Dung-luong-nhu-the-nao"><a href="#Dung-luong-nhu-the-nao" class="headerlink" title="Dựng luồng như thế nào?"></a>Dựng luồng như thế nào?</h3><ul><li>Với mỗi ngày ta chỉ có thể giữ lại $C_i$đơn vị ở nhà kho $i$ =&gt; Ta sẽ cần phảidựng đỉnh quản lí $V[i][j]$ quản lí nhàkho $i$ trong ngày $j$, từ $V[i][j]$ điđến $V[i][j + 1]$ với capacity $C_i$.</li><li>Trong ngày $i$ chỉ được chuyển $D_i$đơn vị =&gt; Ta dựng đỉnh $Q[i]$ quản lílượng chuyển ra trong ngày $i$. Từ $Q[i]$đến đích có capacity $D_i$, từ các$V[i][j]$ đến $Q[j]$ có capacity vô tận.</li><li>Kho $j$ ngày $i$ tăng thêm $A[i][j]$ đơnvị =&gt; từ nguồn vào $V[i][j]$ có capacity$A[i][j]$.</li><li>Chuyển vào trước khi chuyển ra:để xử lí phần này ta cần tách $V[i][j]$thành $V_in[i][j]$ và $V_out[i][j]$,từ $V_out[i][j - 1]$ vào $V_in[i][j]$như trên, $V_out[i][j]$ vào $Q[j]$ nhưtrên và $V_in[i][j]$ vào $V_out[i][j]$có capacity $C_i$.</li></ul><p>Sau đó ta tìm luồng cực đại và kiểm tranó có bằng tổng $A[i][j]$ không.</p><p>Độ phức tạp là <code>O(luồng 2000 đỉnh 2000 cạnh)</code>.</p><h2 id="government-1"><a href="#government-1" class="headerlink" title="government"></a>government</h2><h3 id="Bien-doi-cong-thuc"><a href="#Bien-doi-cong-thuc" class="headerlink" title="Biến đổi công thức"></a>Biến đổi công thức</h3><p>Ta có thể hiểu công thức chính là khoảng cáchcó trọng số của từng cặp. Sử dụng công thứcnày có điểm bất lợi là có quá nhiều biến.Ta sẽ biến đổi công thức một chút.</p><p>Giả sử các điểm $1..N$ đã được xếp từ tráisang phải, đáp số sẽ là$$ \sum\limits_{i = 1}^{N - 1}(x_{i + 1} - x_i)(\sum\limits_{j = 1}^i A[j])(\sum\limits_{k = i + 1}^N A[k])$$</p><p>Với mỗi đoạn liên tiếp, số lần nó bị tínhvào đáp số sẽ là tổng trọng số những điểmbến trái nó nhân với tổng trọng số nhữngđiểm bên phải.</p><h3 id="Don-ve-2-ben"><a href="#Don-ve-2-ben" class="headerlink" title="Dồn về 2 bên"></a>Dồn về 2 bên</h3><p>Giả sử ta đã có thứ tự các số $A[i]$, vậyđặt chúng vào đâu thì hợp lí nhất?</p><p>Dựa theo công thức phía trên, ta có: </p><ul><li>Tổng các $(x_{i + 1} - x_i)$ không quá $M$.Vì ta cần tối đa hóa nên ta coi tổng là$M$ luôn.</li><li>Vị trí có phần tích $A[i]$ lớn nhất làkhi tổng bên trái và bên phải gần nhau nhất.Gọi vị trí này là $(x_{l + 1} - x_l)$.</li></ul><p>Từ đây ta suy ra luôn có thể tối đa hóa đápán bằng cách tối đa hóa đoạn $l$, tức cho$(x_{l + 1} - x_l) = M - N + 1$ và các đoạncòn lại là 1. Nói cách khác, ta sẽ dồn tậpđiểm về 2 bên sao cho tổng trọng số củachúng gần nhau nhất, tức $l$ lớn nhấtthỏa mãn tổng $A[1..l - 1]$ bé hơn nửa tổng.</p><h3 id="Thu-tu-cua-tung-ben"><a href="#Thu-tu-cua-tung-ben" class="headerlink" title="Thứ tự của từng bên"></a>Thứ tự của từng bên</h3><p>Giả sử ta biết tập con của từng bên, làmsao để tìm thứ tự sắp xếp của chúng?</p><p>Xét tập bên trái $A[1..k]$.Dễ dàng nhìnthấy phần đáp số của các đoạn trong tậpchính là$$A[1] \times (S - A[1]) +(A[1] + A[2]) \times (S - A[1] - A[2]) + … +(A[1] + … + A[k - 1]) \times (S + A[k])$$</p><p>Ta nhận thấy $A[1]$, $A[1] + A[2]$, …đều sẽ nhỏ hơn số hạng còn lại tương ứng(theo nhận xét phía trên), vì vậy đểtổng các tích này max, thì $A[1]$, $A[1] + A[2]$,…, $A[1] + … + A[k - 1]$ đều phảilớn nhất có thể. Vậy dãy $A[1..K]$ phải đượcsắp xếp giảm dần.</p><p>Tương tự ta sẽ chứng minh được dãy bên phảiphải được sắp xếp <strong>tăng</strong> dần.</p><h3 id="Quy-hoach-dong"><a href="#Quy-hoach-dong" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Khi đã biết sắp xếp các phần tử, ta đã cóthứ tự quy hoạch động: ta sẽ thêm dần cácphần tử vào bên trái hoặc bên phải, theothứ tự $A[i]$ giảm dần.</p><p>Để có thể vận dụng công thức tính phần giữa,trong hàm qhđ ta cần lưu lại tổng của 1 bên.</p><p>Ta có $f[i][j]$ là tổng đáp số của 2 tập, saocho tập bên trái có tổng là $j$, cả 2 tậpgồm các phần tử từ 1 đến $i$, lớn nhất.Ta chuyển trạng thái từ $f[i][j]$ bằng cáchchọn $i + 1$ vào tập trái hay phải:</p><ul><li>Sang trái: chuyển sang $f[i + 1][j + A[i + 1]]$,tổng tăng thêm $j \times (S - j)$.</li><li>Sang phải: chuyển sang $f[i + 1][j]$, tổngtăng thêm: $(S[i] - j) * (S - S[i] + j)$, với$S[i]$ là tổng $A[1..i]$.</li></ul><p>Đáp số sẽ là$$ \max\limits_{i = 0}^{S}(f[N][i] + (M - N + 1)\times i \times (S - i))$$</p><p>Độ phức tạp là $O(N^2 * A[i])$.</p><h2 id="permutation-1"><a href="#permutation-1" class="headerlink" title="permutation"></a>permutation</h2><h3 id="Vi-tri-dat-so-N"><a href="#Vi-tri-dat-so-N" class="headerlink" title="Vị trí đặt số $N$"></a>Vị trí đặt số $N$</h3><p>Xét dãy $R_i$. Ta nhận thấy số $N$ có thể đặtở $i$ khi và chỉ khi:</p><ul><li>$R_i$ phủ đến 1 hoặc đến $N$.</li><li>Không có $R_j$ nào phủ $i$.</li></ul><p>Giả sử ta có một vị trí thỏa mãn $x$. Nếuđặt $x$ ở $N$, ta nhận thấy không có $j &lt; x$nào mà $R_j$ phủ qua $x$, cũng như khôngcó $j &gt; x$ nào thỏa mãn. Vì thế $R[1..x - 1]$và $R[x + 1..N]$ trở thành 2 bài toán riêngbiệt.</p><p>Ta có thể giải riêng 2 bài toán này, nhânsố cách với nhau, cùng với số cách chọn$x - 1$ số trong $N - 1$ số cho tập bên trái(và các số còn lại trong tập bên phải),tức $C^{x - 1}_{N - 1}$.</p><h3 id="Quy-hoach-dong-1"><a href="#Quy-hoach-dong-1" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Gọi $f[i][j]$ là số cách điền các số hoán vịthỏa mãn $R[i..j]$. Ta có:</p><ul><li>$x$ được gọi là thỏa mãn $i..j$ nếu:<ul><li>$i \le x \le j$</li><li>$R_x$ phủ $i$ hoặc phủ $j$</li><li>Không tồn tại $i \le k \le j$, $k \neq x$mà $R_k$ phủ $x$.</li></ul></li><li>Ta định nghĩa đoạn đúng:<ul><li>$R[1..N]$ là đoạn đúng nếu không có2 cặp nào phủ nhau.</li><li>Đoạn rỗng là đoạn đúng.</li><li>Nếu $R[i..j]$ đúng và $x$ thỏa mãn$i..j$ thì $R[i..x-1]$ và $R[x+1..j]$là đoạn đúng.</li></ul></li><li>$f[i][j] = 1$ nếu $R[i..j]$ là đoạn đúngvà $i = j$ hoặc $i = j + 1$.</li><li>$f[i][j] = \sum\limits_{x \text{ t/m } i..j}f[i][x - 1] \times f[x + 1][j] \times C^{x - 1}_{N - 1}$</li></ul><p>Đáp số là $f[1][N]$. Độ phức tạp là $O(N^3)$,do với mỗi đoạn ta cần tìm $x$ thỏa mãn.</p><p>Ta sẽ tối ưu việc lựa chọn này.</p><h3 id="So-luong-x-thoa-man"><a href="#So-luong-x-thoa-man" class="headerlink" title="Số lượng $x$ thỏa mãn"></a>Số lượng $x$ thỏa mãn</h3><p>Xét đoạn $i..j$. Gọi $L[i][j]$ là $k \le j$ lớnnhất thỏa mãn $R[k]$ phủ $i$, $R[i][j]$là $k \ge i$ nhỏ nhất thỏa mãn $R[k]$ phủ $j$.Hiển nhiên $L[i][j]$ phủ tất cả các sốphủ $i$ đứng trước nó, $R[i][j]$ phủ tấtcả các số phủ $j$ đứng sau nó. Vậy chỉ có$L[i][j]$ hoặc $R[i][j]$ có thể thỏa mãn.</p><p>Ta có thể tính được 2 mảng này trong$O(N^2)$, việc còn lại là kiểm tra tínhthỏa mãn của 2 phần tử này.</p><h3 id="Kiem-tra-thoa-man"><a href="#Kiem-tra-thoa-man" class="headerlink" title="Kiểm tra thỏa mãn"></a>Kiểm tra thỏa mãn</h3><p>Ta còn điều kiện thỏa mãn: Không có phầntử nào cùng đoạn phủ nó. Ta có thể dựng mảngtính như sau:</p><ul><li>$S[i][j] = 1$ nếu $i$ phủ $j$ và 0 nếu không.</li><li>Ta có thể for trâu từng số và đánh dấu, tổngđộ phức tạp sẽ là $O(N^2 \log N)$ do tính chấtcủa bán kính.</li><li>Khi kiểm tra ta cần tính tổng $S[x][i..j]$.Ta có thể sử dụng mảng tổng dồn để lấy tổngtrong $O(1)$.</li></ul><p>Như vậy ta có thuật toán $O(N^2 \log N)$.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hôm nay có khá nhiều bài trí tuệ.&lt;/p&gt;
&lt;h1 id=&quot;Tom-tat-de-bai&quot;&gt;&lt;a href=&quot;#Tom-tat-de-bai&quot; class=&quot;headerlink&quot; title=&quot;Tóm tắt đề bài&quot;&gt;&lt;/a&gt;Tóm
      
    
    </summary>
    
      <category term="Training" scheme="http://blog.nkagami.me/categories/Training/"/>
    
    
      <category term="training" scheme="http://blog.nkagami.me/tags/training/"/>
    
      <category term="apio" scheme="http://blog.nkagami.me/tags/apio/"/>
    
      <category term="anh Minh" scheme="http://blog.nkagami.me/tags/anh-Minh/"/>
    
      <category term="vietnamese" scheme="http://blog.nkagami.me/tags/vietnamese/"/>
    
  </entry>
  
  <entry>
    <title>2017/04/24 Training</title>
    <link href="http://blog.nkagami.me/2017/04/24/2017-04-24-Training/"/>
    <id>http://blog.nkagami.me/2017/04/24/2017-04-24-Training/</id>
    <published>2017-04-24T10:20:00.000Z</published>
    <updated>2017-10-07T12:05:03.012Z</updated>
    
    <content type="html"><![CDATA[<p>Hôm nay bài khá lằng nhằng, mình sẽ cố gắng chữa thật nhiều bước.</p><h1 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h1><h2 id="Heap-on-Trees-NAIPC-2017-bai-D"><a href="#Heap-on-Trees-NAIPC-2017-bai-D" class="headerlink" title="Heap on Trees, NAIPC 2017, bài D"></a><a href="https://naipc17.kattis.com/problems/heapstrees" target="_blank" rel="noopener">Heap on Trees, NAIPC 2017, bài D</a></h2><p>Cho một cây $N$ đỉnh, mỗi nút có một số $A_i$.Tìm tập con các nút lớn nhất thỏa mãn nếu $i$ là tổ tiên của $j$ và $i$, $j$ đều được chọn thì $A_i &gt; A_j$.</p><h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 10^5$, $1 \le A_i \le 10^9$</p><h2 id="Pieces-of-Parentheses-NAIPC-2017-bai-A"><a href="#Pieces-of-Parentheses-NAIPC-2017-bai-A" class="headerlink" title="Pieces of Parentheses, NAIPC 2017, bài A"></a><a href="https://naipc17.kattis.com/problems/piecesofparentheses" target="_blank" rel="noopener">Pieces of Parentheses, NAIPC 2017, bài A</a></h2><p>Cho $N$ dãy ngoặc (không nhất thiết đúng), chọnra một tập con các dãy ngoặc sao cho có thể ghéplại thành dãy ngoặc đúng dài nhất.</p><h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 300$, $1 \le |S_i| \le 300$</p><h2 id="Problem-Buyer-CCPC-2016-2017-Finals-bai-E"><a href="#Problem-Buyer-CCPC-2016-2017-Finals-bai-E" class="headerlink" title="Problem Buyer, CCPC 2016-2017 Finals, bài E"></a><a href="http://codeforces.com/gym/101206/attachments/download/5010/ccpc-20162017-finals-en.pdf" target="_blank" rel="noopener">Problem Buyer, CCPC 2016-2017 Finals, bài E</a></h2><p>Trên trục tọa độ cho $N$ điểm $C_i$ và $M$ đoạnthẳng $[A_i, B_i]$. Tìm $K$ nhỏ nhất sao cho vớimọi tập con độ lớn $K$ của tập đoạn thẳng ta luôntìm được cặp ghép hoàn hảo của tập điểm với đoạnthỏa mãn:</p><ul><li>Mỗi điểm ghép với đúng 1 đoạn thẳng</li><li>Mỗi đoạn thẳng ghép với tối đa 1 điểm</li><li>Nếu $C_i$ ghép với $[A_j, B_j]$ thì$A_j \le C_i \le B_j$.</li></ul><h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N, M \le 10^5$,$1 \le A_i \le B_i \le 10^9$,$1 \le C_i \le 10^9$.</p><h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="Heap-on-Trees"><a href="#Heap-on-Trees" class="headerlink" title="Heap on Trees"></a>Heap on Trees</h2><h3 id="Xac-dinh-phuong-huong"><a href="#Xac-dinh-phuong-huong" class="headerlink" title="Xác định phương hướng"></a>Xác định phương hướng</h3><p>Ta bắt đầu với một hàm quy hoạch động “trâu”chưa cần thiết thỏa mãn giới hạn.Gọi $F[v][j]$ là số đỉnh lớn nhất ta có thểchọn ở cây con gốc $v$ với giới hạn các số là$j$.Dễ dàng nhận thấy để tính $F[v][j]$, ta lầnlượt tính tổng $F[u][j]$ với $u$ là con của $v$.Ngoài ra nếu $A[v] \le j$ ta có một cách chọnlà $A[v]$ cùng với tổng các $F[u][A[v] - 1]$.$$ F[v][j] = \max(\sum\limits_{u \in child[v]}  {F[u][j]}, (A[v] \le j) \times  (1 + \sum\limits_    {u \in child[v]}{F[u][A[v] - 1]}))$$Đáp số chính là $F[root][inf]$.</p><p>Sau khi nén số, ta có hàm quy hoạch động $O(n^2)$.Ta sẽ tập trung vào cải tiến hàm quy hoạch độngnày.</p><h3 id="So-gia-tri-khac-nhau"><a href="#So-gia-tri-khac-nhau" class="headerlink" title="Số giá trị khác nhau"></a>Số giá trị khác nhau</h3><p>Xét một lá $v$. Hiển nhiên $F[v][j]$ chỉ có 2giá trị khác nhau với mọi $j$: <strong>0</strong> khi $A[v]&lt; j$ và <strong>1</strong> nếu ngược lại.</p><p>Khi cộng 2 hàm có 2 miền giá trị, ta sẽđược một hàm có 3 miền giá trị. Tổng quát hơn,khi cộng 2 hàm có $x$ và $y$ miền giá trị,ta được một hàm có $x + y - 1$ miền giá trị.</p><p>Nếu ta coi $F$ mỗi lá là một hàm có 2 miền giá trị,thì một cây con gốc $v$ sẽ có $F$ là một hàm có$size[v] + 1$ miền giá trị, với $size[v]$ là kíchcỡ của cây con gốc $v$.</p><p>Ngoài ra, xét các vị trí thay đổi giá trị củacác hàm. Ta nhận thấy khi cộng 2 hàm có $x$ và $y$miền giá trị, ta nhận được một hàm có $x + y - 1$miền giá trị, trong đó các mốc chính là các mốcthay đổi giá trị của 1 trong 2 hàm số hạng.Như vậy, trong hàm $F[v]$, các điểm mốc chính làcác giá trị $A[u]$ với $u$ là nút trong cây congốc $v$.</p><p>Như vậy, từ một đỉnh $v$, ta có thể dựng hàm $F[u]$với $u = parent[v]$ bằng cách “gộp” giá trị hàm$F[v]$ vào $F[u]$.</p><h3 id="Gop-ham"><a href="#Gop-ham" class="headerlink" title="Gộp hàm"></a>Gộp hàm</h3><p>Giả sử ta có $F[v]$ với $k$ mốc giá trị $X_1, X_2,…, X_k$, ta phải gộp vào hàm $F[u]$ ($u$ làcha của $v$). Theo đúng công thức quy hoạch động,giá trị của $F[v][X_i]$ sẽ được cộng vào các$F[u][p]$ thỏa mãn $X_i \le p &lt; X_{i + 1}$, hay$X_i \le p \le N$ nếu $i = k$.</p><p>Tất nhiên, hàm $F[u]$ cũng sẽ có các mốc $Y_1, Y_2,…, Y_l$ ($X \subseteq Y$). Nếu coi $F[u]$ nhưmột IT, ta có thể update bằng cách:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = lower_bound(Y.begin(), Y.end(), X[i]) - Y.begin();</span><br><span class="line"><span class="keyword">int</span> right = lower_bound(Y.begin(), Y.end(), X[i + <span class="number">1</span>]) - <span class="number">1</span> - Y.begin();</span><br><span class="line">F[u].add(left, right, F[v][X[i]]); <span class="comment">// Thêm F[v][X[i]] vào đoạn [left..right]</span></span><br></pre></td></tr></table></figure><p>Sau đó ta cần cập nhật trường hợp chọn $u$.Tất nhiên khi chọn $u$, tổng đáp số của cây congốc $u$ sẽ là $ans = (\max\limits_{i = 1}^{i &lt; A[u]}{F[u][i]}) + 1$.Ta cần gán <code>f[u][i] = max(f[u][i], ans)</code> với mọi$i \ge A[u]$. Tuy nhiên, do $F[u]$ là hàm tăng,thực chất ta chỉ cần cộng <strong>1</strong> vào các vị trí từ$A[u]$ đến trước vị trí $x$ có $F[u][x] = ans$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = F[u].get(A[u] - <span class="number">1</span>); <span class="comment">// hàm tăng</span></span><br><span class="line"><span class="keyword">int</span> right = F[u].lower_bound(ans) - <span class="number">1</span>;</span><br><span class="line">F[u].add(A[u], right, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>Các bước gộp hàm đã hoàn chỉnh. Tuy nhiên,độ phức tạp vẫn chưa thay đổi. Ta cần mộtbước tiếp theo: thuật toán gộp set (hay gộpIT).</p><h3 id="Thuat-toan-tap-lon-be"><a href="#Thuat-toan-tap-lon-be" class="headerlink" title="Thuật toán tập lớn - bé"></a>Thuật toán tập lớn - bé</h3><p>Xét bài toán: Cho $N$ tập hợp, lúc đầu mỗi tậphợp có 1 phần tử. Để chuyển cácphần tử từ tập hợp $A$ sang tập hợp $B$, ta mấtchi phí $|A|$. Xử lí các truy vấn ghép tập hợp.</p><p>Cách giải bài toán rất đơn giản: với mỗi truyvấn ta chỉ cần chuyển tất cả phần tử từ tậpnhỏ hơn vào tập lớn hơn, và tổng chi phí sẽ là$O(N\log{N})$. Tại sao?</p><p>Gọi $s(p)$ là độ lớn của tập hợp chứa phần tử$p$. Mỗi lần ta chuyển phần tử $p$ từ tập $X$sang tập $Y$ ($|X| \le |Y|$), $s(p)$ tăng ítnhất gấp đôi. Tuy vậy, $s(p)$ không thể vượtquá $N$ do chỉ có tổng cộng $N$ phần tử. Vìthế $p$ không thể bị chuyển quá $\log{N}$ lần.Mỗi phần tử không bị chuyển quá $\log{N}$lần, nên tổng chi phí vận chuyển không thểquá $N\log{N}$.</p><h3 id="Ap-dung-vao-bai-toan-ban-dau"><a href="#Ap-dung-vao-bai-toan-ban-dau" class="headerlink" title="Áp dụng vào bài toán ban đầu"></a>Áp dụng vào bài toán ban đầu</h3><p>Để ý khi ta gộp $F[v]$ vào $F[u]$, chi phílà $size[v] \times \log{N}$ và $size[u]$tăng thêm $size[v]$, giống với việc gộp set.Vì vậy ta có thể cải tiến thuật toán như sau.Giả sử ta đã tính xong mọi $F[v]$ với $v$ làcon của $u$:</p><ul><li>Gán $F[u] = F[v_1]$ (đây là phép gán con trỏ $O(1)$).</li><li>Với mỗi $v$ tiếp theo:<ul><li>Nếu $size[u] &lt; size[v_i]$, tráo $F[u]$ và $F[v_i]$(phép tráo con trỏ $O(1)$).  </li><li>Cập nhật $F[v_i]$ vào $F[u]$.</li></ul></li><li>Cập nhật đáp số khi chọn $u$ như trên.</li></ul><p>Ta sẽ có thuật toán $O(N\log^2{N})$. Tuy vậy, dovẫn sử dụng IT nên bộ nhớ của ta vẫn có thể lênđến $O(N^2)$.</p><h3 id="IT-bo-nho-dong"><a href="#IT-bo-nho-dong" class="headerlink" title="IT bộ nhớ động"></a>IT bộ nhớ động</h3><p>Việc biết trước kích thước tối đa và vị trí cácphần tử của IT cho phép ta dựng lên cây ITchỉ với $\min(2N, \log{N} * size)$ nút. Việcdựng nên IT này khá đơn giản, ta chỉ cầnthay vì sử dụng $2i$ và $2i + 1$ là con của $i$,ta lưu 2 con trỏ chỉ đến 2 nút trái và phải,và chỉ cấp phát bộ nhớ nếu cập nhật đến.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val, sum; <span class="comment">// dữ liệu của IT</span></span><br><span class="line">  node *l, *r; <span class="comment">// 2 con của IT*</span></span><br><span class="line">  node() &#123; l = r = <span class="literal">NULL</span>; val = sum = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(node &amp;*v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt; j || r &lt; i) <span class="keyword">return</span>; <span class="comment">// không dùng</span></span><br><span class="line">  <span class="keyword">if</span> (v == <span class="literal">NULL</span>) v = <span class="keyword">new</span> node(); <span class="comment">// chưa có v, cấp phát</span></span><br><span class="line">  <span class="keyword">if</span> (i &lt;= l &amp;&amp; r &lt;= j) &#123;</span><br><span class="line">    v-&gt;val += val; v-&gt;sum += val;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// gọi đến bản gốc của con trỏ, chỉnh sửa trực tiếp</span></span><br><span class="line">  update(v-&gt;l, l, mid, i, j, val);</span><br><span class="line">  update(v-&gt;r, mid + <span class="number">1</span>, r, i, j, val);</span><br><span class="line">  v-&gt;val = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (v-&gt;l != <span class="literal">NULL</span>) v-&gt;val = max(v-&gt;l-&gt;val + v-&gt;sum, v-&gt;val);</span><br><span class="line">  <span class="keyword">if</span> (v-&gt;r != <span class="literal">NULL</span>) v-&gt;val = max(v-&gt;r-&gt;val + v-&gt;sum, v-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(node *v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// chưa cấp phát, chứng tỏ không có giá trị gì</span></span><br><span class="line">  <span class="keyword">if</span> (l &gt; pos || r &lt; pos) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> v-&gt;val;</span><br><span class="line">  <span class="keyword">return</span> max(get(v-&gt;l, l, mid, pos), get(v-&gt;r, mid + <span class="number">1</span>, r, pos)) + v-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> mid</span></span><br></pre></td></tr></table></figure><p>Do luôn chỉ có tổng cộng $N$ mốc trên tất cả ITnên tổng bộ nhớ không quá $O(N\log{N})$.</p><p>Ngoài ra để đảm bảo điều này ta cũng cần thựchiện xóa nút để giải phóng bộ nhớ. Ta có thểthực hiện điều này sau khi chuyển xong.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(node &amp;*v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  clear(v-&gt;l); clear(v-&gt;r);</span><br><span class="line">  <span class="keyword">delete</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pieces-of-Parentheses"><a href="#Pieces-of-Parentheses" class="headerlink" title="Pieces of Parentheses"></a>Pieces of Parentheses</h2><h3 id="Thu-tu-quy-hoach-dong"><a href="#Thu-tu-quy-hoach-dong" class="headerlink" title="Thứ tự quy hoạch động"></a>Thứ tự quy hoạch động</h3><p>Thông thường để giải các bài ngoặc ta sẽ sử dụngquy hoạch động. Tuy nhiên, theo đề bài thì taphải chọn một tập con có thứ tự, tức ta khôngcó một thứ tự gốc để dựng hàm quy hoạch động.</p><p>Ý tưởng của ta sẽ là đi tìm một thứ tự để chạyphép qhđ.</p><h3 id="Bieu-dien-day-ngoac"><a href="#Bieu-dien-day-ngoac" class="headerlink" title="Biểu diễn dãy ngoặc"></a>Biểu diễn dãy ngoặc</h3><p>Điều kiện một dãy ngoặc đúng là</p><ul><li>Số mở ngoặc bằng số đóng ngoặc</li><li>Tại mọi thời điểm, số mở ngoặc không ít hơnsố đóng ngoặc. Nói cách khác, nếu thay <code>(</code>thành 1 và <code>)</code> thành -1 thì tổng dồn luônkhông âm.</li></ul><p>Như vậy, thực chất với mỗi dãy ngoặc con, tachỉ cần lưu lại 3 thông số: độ dài, vị trícó tổng dồn nhỏ nhất và tổng dồn cuối.Ta gọi 3 giá trị này là $S_i$, $A_i$ và $B_i$.</p><p>Để tạo ra dãy ngoặc đúng từ các dãy ngoặc conthì:</p><ul><li>$\sum\limits_{i = 1}^{k}B[i] = 0$</li><li>Với mọi $i$, $(\sum\limits_{j = 1}^{j &lt; i}B[j]) + A[i] \ge 0$</li><li>Tổng $S_i$ là lớn nhất có thể.</li></ul><h3 id="Phan-loai-day-ngoac"><a href="#Phan-loai-day-ngoac" class="headerlink" title="Phân loại dãy ngoặc"></a>Phân loại dãy ngoặc</h3><p>Để đơn giản hóa việc sắp xếp thứ tự, ta cóthể nghĩ đến việc phân loại các dãy ngoặc.Trong bài này ta sẽ phân thành 3 loại:</p><ul><li>$A[i] \ge 0$. Hiển nhiên $B[i] \ge 0$.Với các loại dãy ngoặc này đặt ở vị trí nàocũng thỏa mãn, vì vậy ta luôn đặt chúng ởđầu để tối đa hóa tổng $B[j]$. Thứ tự từngthành phần là không quan trọng.</li><li>$A[i] &lt; 0$ và $B[i] \ge 0$. Hiển nhiên$A[i]$ càng nhỏ càng nên đặt phía sau, bởicàng đứng sau thì tổng $B[j]$ càng lớn,càng dễ thỏa mãn $A[i]$. Ta đặt các dãy ngoặcloại này sau loại trên, sắp xếp các phần tửtheo thứ tự $A[i]$ giảm dần.</li><li>$A[i] &lt; 0$ và $B[i] &lt; 0$. Đây là loại phứctạp nhất, ta sẽ cần một nhận xét để sắp xếploại ngoặc này. Hiện giờ ta chỉ biết ta sẽxếp chúng sau cùng.</li></ul><h3 id="A-i-lt-0-va-B-i-lt-0"><a href="#A-i-lt-0-va-B-i-lt-0" class="headerlink" title="$A[i] &lt; 0$ và $B[i] &lt; 0$"></a>$A[i] &lt; 0$ và $B[i] &lt; 0$</h3><p>Giả sử ta có một dãy ngoặc đúng chứa $i$ và$i + 1$ là 2 phần tử loại 3 liên tiếp trongdãy. Điều kiện sau là thỏa mãn:</p><ul><li>$S + A[i] \ge 0$, với $S$ là tổng các $B[j]$đứng trước.</li><li>$S + B[i] + A[i + 1] \ge 0$.</li></ul><p>Từ đây ta có thể suy ra $S + A[i + 1] \ge 0$do $B[i] &lt; 0$.</p><p>Nếu $B[i + 1] + A[i] \ge B[i] + A[i + 1]$, tahoàn toàn có thể đổi chỗ $i$ và $i + 1$ bởikhi đó $S + B[i + 1] + A[i] \ge S + B[i] + A[i + 1] \ge 0$,cả 2 điều kiện đều thỏa mãn.</p><p>Từ đó ta chứng minh được đáp án luôn tồn tạisao cho với mọi cặp $i, j$ loại 3 ta đều có$B[j] + A[i] \le B[i] + A[j]$, hay nói cáchkhác, $A[i] - B[i] \le A[j] - B[j]$.</p><p>Như vậy, ta có thể sắp xếp các dãy ngoặc loại3 theo thứ tự $A[i] - B[i]$ tăng dần mà vẫnđảm bảo tìm được đáp án tối ưu.</p><h3 id="Cong-thuc-qhd"><a href="#Cong-thuc-qhd" class="headerlink" title="Công thức qhđ"></a>Công thức qhđ</h3><p>Khi đã có thứ tự, ta dựng công thức qhđ đơngiản: gọi $f[i][j]$ là dãy ngoặc dài nhấtghép được từ các đoạn từ 1 đến $i$ mà cóbậc là $j$. Ta chuyển trạng thái như sau:</p><ul><li>Không thêm đoạn $i + 1$, chuyển đến $f[i + 1][j]$.</li><li>Thêm đoạn $i + 1$, điều kiện là $j + A[i + 1] \ge 0$,chuyển trạng thái đến $f[i + 1][j + B[i + 1]]$, tăngthêm $S[i + 1]$ đơn vị.</li></ul><p>Ban đầu $f[0][0] = 0$, đáp số là $f[N][0]$.</p><p>Độ phức tạp là $O(N^2 * |S|)$, thỏa mãn bài toán.</p><h2 id="Problem-Buyer"><a href="#Problem-Buyer" class="headerlink" title="Problem Buyer"></a>Problem Buyer</h2><h3 id="Thuat-toan-tham-lam"><a href="#Thuat-toan-tham-lam" class="headerlink" title="Thuật toán tham lam"></a>Thuật toán tham lam</h3><p>Trước tiên ta cần phải biết thuật toán thamlam để tìm cặp ghép. Thuật toán như sau:</p><ul><li>Sắp xếp $C_i$ tăng dần.</li><li>Giữ một <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;</code></li><li>Duyệt từ 1 đến $N$, khi đến $i$ ta thêm hết các đoạncó $L_x \le C_i$ vào queue.</li><li>Tim phần tử trong queue có $R_x$ nhỏ nhất mà $\ge C_i$.Nếu có, ghép và xóa khỏi queue. Nếu không, không tồn tạicặp ghép đầy đủ.</li></ul><h3 id="Tao-ra-tap-sai"><a href="#Tao-ra-tap-sai" class="headerlink" title="Tạo ra tập sai"></a>Tạo ra tập sai</h3><p>Thay vì đi tìm $K$ nhỏ nhất sao cho mọi tập đều ghépđược, ta sẽ đi tìm $K’$ lớn nhất mà tồn tại 1 tậpkhông ghép được. Đáp số sẽ là $K’ + 1$.</p><h3 id="Vi-tri-fail"><a href="#Vi-tri-fail" class="headerlink" title="Vị trí fail"></a>Vị trí fail</h3><p>Dựa theo thuật toán tham lam, ta nhận thấy chỉcần ở 1 bước mà queue rỗng thì thuật toán sẽfail. Như vậy, khi xác định được vị trí failta có thể dựng dãy bằng cách lấy tất cả cácphần tử trừ các phần tử đứng trong queue hiệntại khi mô phỏng thuật toán.</p><p>Dễ dàng chứng minh đấy là cách tối ưu nhất đểlàm một bước $i$ xác định nào đó fail. Nhưvậy, thuật toán của ta chỉ là mô phỏng lạithuật tham lam, mỗi bước ta xác định sốphần tử phải xóa đi để bước đó fail (chính làsố phần tử trong queue lúc đó), và tìm vịtrí cần xóa ít phần tử nhất.</p><p>Đáp số sẽ là $N - x$ với $x$ là số phần tửbị xóa nhỏ nhất.Độ phức tạp là $O(N \log{N})$.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hôm nay bài khá lằng nhằng, mình sẽ cố gắng chữa thật nhiều bước.&lt;/p&gt;
&lt;h1 id=&quot;Tom-tat-de-bai&quot;&gt;&lt;a href=&quot;#Tom-tat-de-bai&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Training" scheme="http://blog.nkagami.me/categories/Training/"/>
    
    
      <category term="training" scheme="http://blog.nkagami.me/tags/training/"/>
    
      <category term="apio" scheme="http://blog.nkagami.me/tags/apio/"/>
    
      <category term="vietnamese" scheme="http://blog.nkagami.me/tags/vietnamese/"/>
    
      <category term="anh Hạnh" scheme="http://blog.nkagami.me/tags/anh-Hanh/"/>
    
  </entry>
  
  <entry>
    <title>2017/04/21 Training</title>
    <link href="http://blog.nkagami.me/2017/04/22/2017-04-21-Training/"/>
    <id>http://blog.nkagami.me/2017/04/22/2017-04-21-Training/</id>
    <published>2017-04-23T01:11:00.000Z</published>
    <updated>2017-10-07T12:05:02.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h1><h2 id="SEQUENCE"><a href="#SEQUENCE" class="headerlink" title="SEQUENCE"></a>SEQUENCE</h2><p>Cho dãy số <code>A[1..N]</code>. Mỗi lần xóa ta sẽ xóatất cả các số mang một giá trị <code>x</code> nào đó.Hỏi dãy dài nhất có thể tạo ra được mà khôngtồn tại <code>i &lt; j &lt; k</code> thỏa mãn<code>A[i] == A[k] &amp;&amp; A[i] != A[j]</code>?</p><h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 10^5</code>, <code>1 &lt;= A[i] &lt;= 100</code></p><h2 id="AVTOGAME"><a href="#AVTOGAME" class="headerlink" title="AVTOGAME"></a>AVTOGAME</h2><p>Cho xâu <code>S</code>. Mỗi bước ta có thể chọn một đoạn<code>l &lt; r</code> sao cho <code>S[l] == S[r]</code> và xóa đoạn đókhỏi xâu. Hỏi xâu ngắn nhất và dài nhất có thểtạo được (mà không thể xóa được tiếp) là baonhiêu?</p><h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>10 test, <code>1 &lt;= |S| &lt;= 100</code>, <code>&#39;a&#39; &lt;= S[i] &lt;= &#39;p&#39;</code></p><h2 id="DISKGAME"><a href="#DISKGAME" class="headerlink" title="DISKGAME"></a>DISKGAME</h2><p>Cho một đĩa gồm <code>N</code> tầng xoay, mỗi tầng có <code>K</code>nấc xoay như hình dưới.</p><p><img src="/images/diskgame_exp.png" alt="Một đĩa có 3 tầng, mỗi tầng có 8 nấc"></p><p>Mỗi bước ta được xoay 1 tầng sang trái hoặc phải1 nấc. Hỏi số bước nhỏ nhất để tạo ra 1 cột cócác số bằng nhau là bao nhiêu?</p><p><img src="/images/diskgame_sol.png" alt="Một cách giải hình trên"></p><h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N, K &lt;= 2000</code></p><h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="SEQUENCE-1"><a href="#SEQUENCE-1" class="headerlink" title="SEQUENCE"></a>SEQUENCE</h2><h3 id="Dieu-kien-cua-day-so"><a href="#Dieu-kien-cua-day-so" class="headerlink" title="Điều kiện của dãy số"></a>Điều kiện của dãy số</h3><p>Ta có thể thấy, 2 số <code>x</code> và <code>y</code> không được cùngtồn tại trong đáp án nếu số <code>x</code> bị “kẹp giữa” số<code>y</code> hoặc ngược lại. Ta cũng có thể dễ dàngchứng minh một dãy không tồn tại cặp <code>x, y</code>nào như vậy là một dãy thỏa mãn.</p><h4 id="Vi-du"><a href="#Vi-du" class="headerlink" title="Ví dụ"></a>Ví dụ</h4><p><code>1, 2, 1, 3, 1, 4</code> không thỏa mãn vì số <code>2</code> bịkẹp giữa 2 lần số <code>1</code>.</p><p>Bài toán của ta trở thành đi tìm một dãy khôngcó 2 số nào “kẹp” nhau.</p><h3 id="Dau-va-duoi"><a href="#Dau-va-duoi" class="headerlink" title="Đầu và đuôi"></a>Đầu và đuôi</h3><p>Xét ví dụ ở trên, ta có thể thấy <code>2</code> bị kẹpgiữa bởi 2 số <code>1</code> ở vị trí 1 và 3. Ta cũng cóthể nói <code>2</code> bị kẹp giữa bởi 2 số <code>1</code> ở 1 và 5.</p><p>Giả sử <code>x</code> kẹp giữa <code>y</code> ở 2 vị trí <code>a &lt;= b</code>,ta cũng có thể nói <code>x</code> kẹp ở 2 vị trí <code>first[x] &lt;= a</code>và <code>b &lt;= last[x]</code> (2 lần xuất hiện đầu và cuốicủa <code>x</code>). Như vậy điều kiện để <code>x</code> kẹp giữa <code>y</code>chỉ là tồn tại <code>y</code> nằm giữa 2 vị trí xa nhau nhấtchứa <code>x</code>.</p><p>Đi xa hơn, ta có thể thấy xét trên trục 1 chiều,tồn tại cặp <code>x</code>, <code>y</code> kẹp nhau khi và chỉ khi 2 đoạn<code>(first[x], last[x])</code> và <code>(first[y], last[y])</code>giao nhau.</p><h3 id="Quy-hoach-dong"><a href="#Quy-hoach-dong" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Như vậy, ta chỉ cần tìm 1 tập số sao cho tập<code>(first[x], last[x])</code> của các số không giao nhau.Đây là bài toán quy hoạch động cơ bản, có thể thựchiện quy hoạch động trong<code>O(N + M)</code> với <code>M</code> là số phần tử khác nhau.</p><p>Gọi <code>f[i]</code> là số đoạn thẳng nhiều nhất ta cóthể chọn trong khoảng <code>1..i</code>. Từ đây, ta có 2lựa chọn:</p><ul><li>Thêm khoảng không, cập nhật <code>f[i]</code> cho <code>f[i + 1]</code>.</li><li>Thêm một đoạn <code>(i + 1..j)</code>. Ta duyệt tất cả cácđoạn thẳng có đầu mút trái là <code>i + 1</code> và cập nhật<code>f[i] + 1</code> cho <code>f[j]</code>.</li></ul><p>Đáp số là <code>f[N]</code>.</p><h2 id="AVTOGAME-1"><a href="#AVTOGAME-1" class="headerlink" title="AVTOGAME"></a>AVTOGAME</h2><h3 id="Co-the-xoa-1-doan"><a href="#Co-the-xoa-1-doan" class="headerlink" title="Có thể xóa 1 đoạn?"></a>Có thể xóa 1 đoạn?</h3><p>Hiển nhiên các đoạn ta xóa sẽ không giao nhau,nên chỉ có 2 khả năng xảy ra để xóa đoạn <code>[a &lt; b]</code>:</p><ul><li>Nếu <code>S[a] == S[b]</code> ta xóa cả đoạn trong 1 bước.</li><li>Chọn 1 vị trí <code>a &lt; k &lt; b - 1</code>, xóa đoạn <code>a..k</code>rồi xóa đoạn <code>k+1..b</code>.</li></ul><p>Dựa vào nhận xét này, ta dễ dàng dựng nên mảng<code>canErase[l][r]</code> (có thể xóa đoạn <code>l..r</code> không?)trong <code>O(N^3)</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= N; ++l) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = l + <span class="number">1</span>; r &lt;= N; ++r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (S[l] == S[r]) canErase[l][r] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = l + <span class="number">1</span>; k + <span class="number">1</span> &lt; r; ++k) &#123;</span><br><span class="line">      canErase[l][r] = canErase[l][r] || (canErase[l][k] &amp;&amp; canErase[k + <span class="number">1</span>][r]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Chi-phi-xoa-het-nho-nhat"><a href="#Chi-phi-xoa-het-nho-nhat" class="headerlink" title="Chi phí xóa hết nhỏ nhất"></a>Chi phí xóa hết nhỏ nhất</h3><p>Thay vì giải bài toán xâu ngắn nhất còn lại,ta sẽ thay đổi bài toán bằng cách cho phép mộtkiểu xóa nữa: xóa <strong>1 kí tự</strong> với chi phí 1.Sau đó ta đi tìm chi phí nhỏ nhất để xóacả dãy. Ta có thể thấy tính chất các bướcxóa rời nhau không thay đổi.</p><p>Hiển nhiên chi phí sẽ bằng đáp án, vì ta khôngbao giờ xóa đơn lẻ 2 kí tự giống nhau.</p><p>Để giải được bài toán này, ta cải tiến thuậttoán kiểm tra tính xóa được phía trên, thànhchi phí nhỏ nhất để xóa đoạn <code>l..r</code>. Hiểnnhiên <code>cost[i][i] = 1</code> vì chỉ có 1 kí tự. Vớiđoạn <code>l..r</code> ta có 2 cách xóa:</p><ul><li>Nếu <code>S[l] == S[r]</code> ta xóa cả đoạn với chiphí 0.</li><li>Chọn <code>l &lt;= k &lt; r</code> rồi xóa 2 đoạn <code>l..k</code> và<code>k + 1..r</code> với tổng chi phí<code>cost[l][k] + cost[k + 1][r]</code>.</li></ul><p>Đáp số là <code>cost[1][N]</code>, độ phức tạp là <code>O(N^3)</code>.</p><h3 id="Cac-ki-tu-con-lai"><a href="#Cac-ki-tu-con-lai" class="headerlink" title="Các kí tự còn lại"></a>Các kí tự còn lại</h3><p>Để giải được bài toán dãy còn lại dài nhất,ta cần phải thấy tính chất của dãy còn lại.Tính chất khá đơn giản: không tồn tại 2 kítự giống nhau trong xâu. Như vậy, ta cầnnhặt ra 1 tập kí tự khác nhau sao cho các phầnở giữa có thể xóa được.</p><p>Điều kiện chỉ có 16 kí tự khác nhau cho tamột gợi ý: sử dụng bitmask để quản lí cáckí tự đã lấy.</p><h3 id="Quy-hoach-dong-1"><a href="#Quy-hoach-dong-1" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Gọi <code>bool f[i][mask]</code> là tính khả thi củaviệc chọn ra tập kí tự thỏa mãn <code>mask</code> trong đoạn<code>1..i</code> và xóa hết các kí tự còn lại, trong đókí tự cuối ta chọn chính là <code>S[i]</code>. Ta có 2 lựachọn:</p><ul><li>Chọn cả kí tự <code>S[i - 1]</code>, với điều kiện<code>S[i - 1] != S[i]</code> và <code>mask</code> có <code>S[i - 1]</code>. Talùi về trạng thái <code>f[i - 1][mask ^ S[i]]</code>.</li><li>Chọn một vị trí <code>j &lt; i</code> và lấy kí tự này làkí tự đứng ngay trước <code>S[i]</code>. Điều kiện là<code>S[j] != S[i]</code>, <code>mask</code> có <code>S[j]</code> và <code>j + 1..i - 1</code>xóa được. Ta lùi về trạng thái <code>f[j][mask ^ S[i]]</code>.</li></ul><p>Độ phức tạp sẽ là <code>O(N^2 * 2^16)</code>, chưa thểthỏa mãn bài toán. Ta cần một chút cải tiến đểxóa bớt <code>N</code>.</p><h3 id="Nhay-chon-va-xoa"><a href="#Nhay-chon-va-xoa" class="headerlink" title="Nhảy, chọn và xóa"></a>Nhảy, chọn và xóa</h3><p>Ta sẽ chỉnh sửa hàm quy hoạch động một chút: xóabỏ điều kiện <code>S[i]</code> là kí tự cuối cùng chọn.Thay vào đó, ta “nhảy” từng bước, chọn hoặc sửdụng duy nhất một phép xóa. Cụ thể, từ trạng thái<code>f[i][mask]</code>, ta có:</p><ul><li><code>S[i]</code> là kí tự được chọn. Điều kiện là <code>mask</code>chứa <code>S[i]</code>. Lùi về <code>f[i - 1][mask ^ S[i]]</code>.</li><li><code>S[i]</code> là kí tự cuối cùng bị xóa. Vậy ta cầnmột vị trí <code>j &lt; i</code> sao cho <code>S[i] == S[j]</code>, và lùivề <code>f[j - 1][mask]</code>.</li></ul><p>Thoáng qua, vẫn là <code>O(N^2 * 2^16)</code>. Làm sao đểcải tiến? Ta thấy, trong trường hợp 2, điều kiệnduy nhất là <code>S[j] == S[i]</code>, mà chỉ có 16 loại kí tự,vậy ta hoàn toàn có thể lưu lại tất cả các trườnghợp <code>f[j - 1][mask]</code> với mỗi lọai <code>S[j]</code> khác nhau.</p><p>Gọi <code>g[i][mask]</code> là tổng kết tất cả các trường hợp<code>f[j][mask]</code> thỏa mãn <code>S[j + 1] == i</code>. Ta có thểvừa đi vừa cập nhật <code>g[S[i + 1]][mask]</code>, đồng thờitrong trường hợp 2 ta chỉ cần lấy giá trị của<code>g[S[i]][mask]</code> trong <code>O(1)</code>.</p><p>Độ phức tạp giảm xuống còn <code>O(N * 2^16)</code>,thỏa mãn bài toán.</p><h2 id="DISKGAME-1"><a href="#DISKGAME-1" class="headerlink" title="DISKGAME"></a>DISKGAME</h2><h3 id="Chi-phi-xoay-cua-1-dia"><a href="#Chi-phi-xoay-cua-1-dia" class="headerlink" title="Chi phí xoay của 1 đĩa"></a>Chi phí xoay của 1 đĩa</h3><p>Hãy phân tích chi phí xoay của 1 đĩa để cósố <code>n</code> ở vị trí <code>p</code>. Hiển nhiên chi phí là<code>min(|x - p|)</code> với <code>x</code> là các vị trí xuất hiệncủa <code>n</code> trong đĩa.</p><p>Thực chất ta chỉ cần xét đến 2 vị trí gần nhấtbên trái và bên phải của <code>p</code>. Ta tạm gọi là<code>x</code> và <code>y</code> (để đơn giản ta coi <code>x &lt;= p &lt;= y</code>).Chi phí sẽ là <code>min(p - x, y - p)</code>. Dễ dàng nhậnthấy <code>p - x</code> là hàm tăng 1 đơn vị, <code>y - p</code> làhàm giảm 1 đơn vị với <code>x &lt;= p &lt;= y</code>. min của2 hàm này sẽ là “núi” góc 45 độ có chóp ở trungđiểm của <code>x</code> và <code>y</code> (hoặc có chóp ngang nếu trungđiểm không nguyên).</p><p>Nếu ta xét tất cả các cặp vị trí liên tiếp củasố, thì chi phí sẽ là nhiều “ngọn núi” như vậy.</p><p>Ta có thể thấy chi phí là một hàm như hình dưới,cho dãy <code>1 2 3 1 2 3 5 1 5</code> với <code>n = 1</code>. Lưu ýđoạn <code>8, 9, 1</code> cũng là 1 “ngọn núi”, vì thực chấtđĩa là hình tròn.</p><p><img src="/images/diskgame_func.png" alt="Hàm chi phí"></p><p>Ta có thể cắt hàm thành các đường chéo tăng vàgiảm 45 độ để đơn giản hóa việc tính toán chiphí cho tất cả các đĩa.</p><p>Tổng cộng 1 đĩa sẽ bị cắt thành <code>2K</code> đường chéo.</p><h3 id="Tinh-tong-chi-phi-cho-moi-dia"><a href="#Tinh-tong-chi-phi-cho-moi-dia" class="headerlink" title="Tính tổng chi phí cho mọi đĩa"></a>Tính tổng chi phí cho mọi đĩa</h3><p>Với mỗi vị trí <code>p</code> và một số <code>n</code>, ta cần tínhtổng chi phí xoay với mọi đĩa trong <code>O(1)</code>.Biết chúng là tổng các đường chéo, làm saođể tính nhanh?</p><p>Ta sẽ vận dụng tính chất chúng đều có dạng <code>x + b</code>hoặc <code>-x + b</code> và sử dụng đường quét để tínhvới mỗi <code>n</code>.</p><p>Ta thấy, khi có <code>k</code> đoạn <code>x + b[i]</code>, chi phí là<code>kx + sum(b[i])</code> với bước tăng là <code>k</code>.Vì vậy thực chất với mỗi vịtrí ta chỉ cần biết số đoạn tăng và tổng phầnhằng số của chúng. Ta hoàn toàn có thể làmđiều này khi quét bằng cách xét 2 đầu mút đầu(thêm đoạn) và cuối (xóa đoạn) sau đó xử lítừ trái sang phải.</p><p>Điều tương tự cũng đúng với hàm giảm.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b[N * K + <span class="number">1</span>]; <span class="comment">// tất cả b[i] của các đường tăng</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; add[K + <span class="number">2</span>], remove[K + <span class="number">2</span>]; <span class="comment">// các mốc thêm xóa</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSegment</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// thêm đoạn [l..r] = x + b[id]</span></span><br><span class="line">  add[l].push_back(id);</span><br><span class="line">  remove[r + <span class="number">1</span>].push_back(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> value = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p: add[i]) &#123;</span><br><span class="line">      value += b[p] + i - <span class="number">1</span>; <span class="comment">// giá trị của i trước đó</span></span><br><span class="line">      ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p: remove[i]) &#123;</span><br><span class="line">      value -= b[p] + i - <span class="number">1</span>;</span><br><span class="line">      --cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    value += cnt;</span><br><span class="line">    <span class="comment">// value là tổng ở vị trí i</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ta có thể thấy độ phức tạp với mỗi <code>n</code> là <code>O(K + số đoạn của n)</code>.Vì thế tổng độ phức tạp là <code>O(K^2 + NK)</code>, do có <code>2NK</code> đoạn tất cả.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tom-tat-de-bai&quot;&gt;&lt;a href=&quot;#Tom-tat-de-bai&quot; class=&quot;headerlink&quot; title=&quot;Tóm tắt đề bài&quot;&gt;&lt;/a&gt;Tóm tắt đề bài&lt;/h1&gt;&lt;h2 id=&quot;SEQUENCE&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="Training" scheme="http://blog.nkagami.me/categories/Training/"/>
    
    
      <category term="training" scheme="http://blog.nkagami.me/tags/training/"/>
    
      <category term="apio" scheme="http://blog.nkagami.me/tags/apio/"/>
    
      <category term="vietnamese" scheme="http://blog.nkagami.me/tags/vietnamese/"/>
    
      <category term="thầy Nghĩa" scheme="http://blog.nkagami.me/tags/thay-Nghia/"/>
    
  </entry>
  
  <entry>
    <title>2017/04/20 Training</title>
    <link href="http://blog.nkagami.me/2017/04/21/2017-04-20-Training/"/>
    <id>http://blog.nkagami.me/2017/04/21/2017-04-20-Training/</id>
    <published>2017-04-21T11:36:25.000Z</published>
    <updated>2017-10-07T12:05:02.969Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Lưu ý</strong>: Mình đã tóm tắt đề bài ở trên, ai không muốn bị spoil thì đừngkéo xuống lời giải vội.</p><p>Hôm nay có 5 bài của thầy Đông. Do mình không được nghe thầy chữa buổi chiều nên solution là của mình, mặc dù 99% là đúng nhưng không đảm bảo.Thực chất bài không phải là khó quá.</p><h1 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h1><h2 id="ACM"><a href="#ACM" class="headerlink" title="ACM"></a>ACM</h2><p>Có <code>N</code> đội, mỗi đội có 11 chỉ số <code>A[i][1..11]</code>. Chọn 3 đội sao cho <code>sum[i = 1..11][max(A[x, y, z][i])]</code> (tổng của max chỉ số từng loại của 3 đội) là lớn nhất.</p><h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 30000</code></p><h2 id="DOMINO-Bai-toan-thu-nhat"><a href="#DOMINO-Bai-toan-thu-nhat" class="headerlink" title="DOMINO (Bài toán thứ nhất)"></a>DOMINO (Bài toán thứ nhất)</h2><p>Cho một bảng <code>M x N</code> với <code>K</code> ô cấm.Điền 0 hoặc 1 vào các ô không bị cấm sao chovới ô <code>(i, j)</code>:</p><ul><li>Nếu <code>i + j</code> lẻ, thì ô <code>(i, j)</code> không nhỏhơn các ô không bị cấm xung quanh.</li><li>Nếu <code>i + j</code> chẵn, thì <code>(i, j)</code> không lớnhơn các ô không bị cấm xung quanh.</li></ul><h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= M, N &lt;= 16</code></p><h2 id="DOMINO-Bai-toan-thu-hai"><a href="#DOMINO-Bai-toan-thu-hai" class="headerlink" title="DOMINO (Bài toán thứ hai)"></a>DOMINO (Bài toán thứ hai)</h2><p>Lần này không có ô cấm. Điều kiện như bài toán thứ nhất.</p><h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 8</code>, <code>1 &lt;= M &lt;= 10^6</code></p><h2 id="GAMES"><a href="#GAMES" class="headerlink" title="GAMES"></a>GAMES</h2><p>Cho một dãy bit <code>N</code> phần tử chưa xác định và <code>M</code> điều kiện có dạngxor của <code>A[l..r]</code> là 0 hay 1. Tìm vị trí <code>x</code> đầu tiênmà điều kiện <code>x</code> mâu thuẫn với các điều kiện trên.</p><h4 id="Gioi-han-3"><a href="#Gioi-han-3" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 10^9</code>, <code>1 &lt;= M &lt;= 10^5</code></p><h2 id="HANOI"><a href="#HANOI" class="headerlink" title="HANOI"></a>HANOI</h2><p>Cho thuật toán giải bài toán tháp Hà Nội:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HanoiTower</span><span class="params">(height, From, Temp, To)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> height == <span class="number">1</span>:</span><br><span class="line">    <span class="comment"># Move one from `From` to `To`</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  HanoiTower(height - <span class="number">1</span>, From, To, Temp)</span><br><span class="line">  HanoiTower(<span class="number">1</span>, From, Temp, To)</span><br><span class="line">  HanoiTower(height - <span class="number">1</span>, Temp, From, To)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Call the function</span></span><br><span class="line">HanoiTower(N, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>)</span><br></pre></td></tr></table></figure></p><ul><li>Tìm trạng thái của 3 tháp sau <code>P</code> lần gọi hàm.</li><li>Cho trạng thái của 3 tháp, tính số bước đã gọi hàm<code>P</code>, hoặc in <code>-1</code> nếu không tồn tại trạng thái đó khi giải.</li></ul><h4 id="Gioi-han-4"><a href="#Gioi-han-4" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 100</code>. Lưu ý <code>P</code> có thể là số lớn.</p><h2 id="WG"><a href="#WG" class="headerlink" title="WG"></a>WG</h2><p>Cho một xâu <code>P</code> và một tập xâu <code>S[1..N]</code>. Dựng xâu <code>T</code> như sau:</p><ul><li>Đầu tiên chọn một xâu trong tập <code>S[]</code> và thêm vào <code>T</code></li><li>Sau đó, tìm xâu <code>S[i]</code> bất kì thỏa mãn <code>S[0] == T.back()</code> rồi thêm <code>S[i][1..]</code> vào.</li></ul><p>Hỏi xâu <code>T</code> ngắn nhất chứa dãy con không liên tiếp <code>P</code> là gì?</p><h4 id="Gioi-han-5"><a href="#Gioi-han-5" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= |P| &lt;= 250, 1 &lt;= |S[i]| &lt;= 10, 1 &lt;= N &lt;= 1000</code></p><h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="ACM-1"><a href="#ACM-1" class="headerlink" title="ACM"></a>ACM</h2><h3 id="Tom-tat-de-bai-1"><a href="#Tom-tat-de-bai-1" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Có <code>N</code> đội, mỗi đội có 11 chỉ số <code>A[i][1..11]</code>. Chọn 3 đội sao cho <code>sum[i = 1..11][max(A[x, y, z][i])]</code> (tổng của max chỉ số từng loại của 3 đội) là lớn nhất.</p><h4 id="Gioi-han-6"><a href="#Gioi-han-6" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 30000</code></p><h3 id="“Phuc-tap-hoa”-bai-toan"><a href="#“Phuc-tap-hoa”-bai-toan" class="headerlink" title="“Phức tạp hóa” bài toán"></a>“Phức tạp hóa” bài toán</h3><p>Rất khó để thực hiện việc chọnnếu mình sử dụng việc lấy max củatừng chỉ số. Vì thế ta có thểthay đổi bài toán thành <strong>chọn 3 độirồi mỗi chỉ số lấy của một đội</strong>.Ta có thể thấy khi có quản lí đơn giản hơn:chỉ cần mỗi đội một bitmask lựa chọn chỉ số.</p><p>Hiển nhiên khi đã xét tất cả trường hợpthì trường hợp tốt nhất luôn là lấy max.</p><h3 id="Ghep-bitmask"><a href="#Ghep-bitmask" class="headerlink" title="Ghép bitmask"></a>Ghép bitmask</h3><p>Giả sử ta đã chọn 3 đội <code>i</code>, <code>j</code> và <code>k</code>.Ta sẽ gán lần lượt 3 mask <code>x</code>, <code>y</code>, <code>z</code> cho 3 độinày. Các mask sẽ thỏa mãn:</p><ul><li>Đôi một rời rạc (<code>x &amp; y == 0</code>, <code>y &amp; z == 0</code>, <code>z &amp; x == 0</code>)</li><li>Ghép lại thì có đầy đủ (<code>x | y | z == (1 &lt;&lt; 11) - 1</code>)</li><li>Tổng chỉ số tương ứng lớn nhất.</li></ul><p>Ta có thể thấy, thực chất ta không cần quan tâmcác đội được chọn là đội nào.Với mask <code>x</code> được chọn trước, ta chỉ cần tính xemtrong các đội thì đội nào có tổng tương ứng mask <code>x</code>là lớn nhất.Việc 2 mask <code>x</code> và <code>y</code> bị chọn trùng đội không quan trọng:Ta có thể coi như khi đó có 1 người được chọn với mask <code>0</code>.</p><p>Ta có thể tính trước <code>max[x]</code> với mask <code>x</code> trong <code>O(N * 2^11)</code>.</p><h3 id="Chon-3-phan-tu"><a href="#Chon-3-phan-tu" class="headerlink" title="Chọn 3 phần tử"></a>Chọn 3 phần tử</h3><p>Trước tiên, ta có thể thấy nếu chỉ chọn 2 phần tử, tacó thể for tất cả cặp mask, kiểm tra trong <code>O((2^11)^2)</code>.Hiển nhiên do 2 mask đều chỉ có 11 bit nên khi <code>or</code> lại vớinhau (ghép bộ) thì mask mới vẫn chỉ có 11 bit. Vậy để chọn3 phần tử, ta có thể tiếp tục ghép cặp tập đã or với tập <code>max[x]</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> two[<span class="number">1</span> &lt;&lt; <span class="number">11</span>];</span><br><span class="line"><span class="keyword">int</span> three[<span class="number">1</span> &lt;&lt; <span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>); ++i) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>); ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(i &amp; j)) <span class="comment">// không có phần tử trùng</span></span><br><span class="line">      two[i | j] = max(two[i | j], max[i] + max[j]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>); ++i) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>); ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(i &amp; j)) <span class="comment">// không có phần tử trùng</span></span><br><span class="line">      three[i | j] = max(three[i | j], two[i] + max[j]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Đáp số chính là <code>three[(1 &lt;&lt; 11) - 1]</code>.Độ phức tạp sẽ là <code>O((2 ^ 11) ^ 2)</code>.</p><h2 id="DOMINO-Bai-toan-thu-nhat-1"><a href="#DOMINO-Bai-toan-thu-nhat-1" class="headerlink" title="DOMINO (Bài toán thứ nhất)"></a>DOMINO (Bài toán thứ nhất)</h2><h3 id="Tom-tat-de-bai-2"><a href="#Tom-tat-de-bai-2" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho một bảng <code>M x N</code> với <code>K</code> ô cấm.Điền 0 hoặc 1 vào các ô không bị cấm sao chovới ô <code>(i, j)</code>:</p><ul><li>Nếu <code>i + j</code> lẻ, thì ô <code>(i, j)</code> không nhỏhơn các ô không bị cấm xung quanh.</li><li>Nếu <code>i + j</code> chẵn, thì <code>(i, j)</code> không lớnhơn các ô không bị cấm xung quanh.</li></ul><h4 id="Gioi-han-7"><a href="#Gioi-han-7" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= M, N &lt;= 16</code></p><h3 id="Quy-hoach-dong"><a href="#Quy-hoach-dong" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Thực chất đây là một bài toán quy hoạchđộng bitmask cơ bản. Nhận xét rằng với mỗi ôta chỉ cần để ý bit ô bên trái và bên trên nó đểcó thể xét điều kiện thỏa mãn.</p><p>Khi quy hoạch động ta đi từng ô theo từng cột,trên xuống dưới trái qua phải.Gọi <code>f[i][j][mask]</code> là số cách lát kể từô <code>(i, j)</code> đến cuối cùng, với <code>mask</code> là trạng thái<code>N</code> ô cuối cùng đã đến trước <code>(i, j)</code> (tức các ô <code>(i - 1, j)</code>,<code>(i - 1, j + 1)</code>, …, <code>(i, j - 1)</code>). Xem hính dưới:</p><p><img src="/images/20170420_domino.png" alt="Bài Domino"></p><p>Hình thể hiện trạng thái khi đã đến ô <code>(i, j)</code>. Ô màu xanh lálà các ô đã lát, ô màu vàng thể hiện mask đang bị quản lí bởibit tương ứng trong mask, ô màu xanh dương thể hiện ô sắp điền,ô màu đỏ thể hiện các ô chưa lát.</p><p>Để chuyển trạng thái ta xác định bit của ô <code>(i, j)</code>, nếu nó thỏa mãnđiều kiện với ô trái và trên thì gọi đến trạng thái tiếp theo (<code>f[i][j + 1][mask mới]</code>hoặc <code>f[i + 1][1][mask mới]</code> nếu đó là ô cuối của cột).</p><h4 id="Chuyen-mask-nhu-nao"><a href="#Chuyen-mask-nhu-nao" class="headerlink" title="Chuyển mask như nào?"></a>Chuyển mask như nào?</h4><p>Ta để ý trên hình, bit <code>3</code>, kể từ ô tiếp theo, không cần biết đến nữa.Ta có thể xóa bit này và đẩy lên, cho bit của <code>(i, j)</code> vào cuối. Nhưvậy trạng thái của mình luôn có <code>N</code> bit.</p><p>Độ phức tạp là <code>O(N * M * 2^N)</code>.</p><h3 id="Cai-dat-nhu-nao"><a href="#Cai-dat-nhu-nao" class="headerlink" title="Cài đặt như nào?"></a>Cài đặt như nào?</h3><p>Nên gọi đệ quy có nhớ.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> f[<span class="number">20</span>][<span class="number">20</span>][<span class="number">1</span> &lt;&lt; <span class="number">16</span>];</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">20</span>][<span class="number">20</span>][<span class="number">1</span> &lt;&lt; <span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; M) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// trường hợp biên</span></span><br><span class="line">  <span class="keyword">if</span> (visited[i][j][mask]) <span class="comment">// đã tính</span></span><br><span class="line">    <span class="keyword">return</span> f[i][j][mask];</span><br><span class="line">  visited[i][j][mask] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ch = <span class="number">0</span>; ch &lt; <span class="number">2</span>; ++ch) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*kiểm tra điều kiện đặt bit ch ở (i, j)*/</span>) &#123;</span><br><span class="line">      f[i][j][mask] += cal(i + (j == N), j % N + <span class="number">1</span>, (mask &lt;&lt; <span class="number">1</span>) &amp; ((<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>) + ch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f[i][j][mask];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x &amp; ((1 &lt;&lt; N) - 1) để lấy x % (1 &lt;&lt; N), N bit cuối của x.</span></span><br><span class="line"><span class="comment">// (x &lt;&lt; 1) == x * 2, đẩy các bit sang phải 1 đơn vị.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = cal(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="DOMINO-Bai-toan-thu-hai-1"><a href="#DOMINO-Bai-toan-thu-hai-1" class="headerlink" title="DOMINO (Bài toán thứ hai)"></a>DOMINO (Bài toán thứ hai)</h2><p>Lần này không có ô cấm. Điều kiện như bài toán thứ nhất.</p><h4 id="Gioi-han-8"><a href="#Gioi-han-8" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 8</code>, <code>1 &lt;= M &lt;= 10^6</code></p><h3 id="Nhan-ma-tran"><a href="#Nhan-ma-tran" class="headerlink" title="Nhân ma trận"></a>Nhân ma trận</h3><p>Lần này không có ô cấm, nên với mỗi hàng ta chỉ cần quantâm mask của nó là gì. Từ đây ta có thể nghĩ đến việc nhânma trận.</p><p>Giới hạn <code>N</code> nhỏ, <code>M</code> lớn cũng mang đến cho ta gợi ý này.</p><h3 id="So-trang-thai"><a href="#So-trang-thai" class="headerlink" title="Số trạng thái"></a>Số trạng thái</h3><p><code>O((2 ^ N)^3 * log(M))</code> chưa thể thỏa mãn bài toán.Ta phân tích thêm một chút: với mỗi cột, ta có thể loại racác trạng thái không thỏa mãn các điều kiện giữa 2 ô liên tiếptrên cùng cột.</p><p>Việc thử nghiệm cho thấy với <code>N = 8</code> cũng chỉ có <strong>55</strong> trạng thái,có thể nhân ma trận.</p><h3 id="Dieu-kien-theo-i-j"><a href="#Dieu-kien-theo-i-j" class="headerlink" title="Điều kiện theo i + j"></a>Điều kiện theo <code>i + j</code></h3><p>Khi chuyển từ cột <code>2i</code> sang cột <code>2i + 1</code>,điều kiện bị thay đổi: thứ tự các ô trongcột đang từ <em>lẻ, chẵn, lẻ, …</em> thành <em>chẵn, lẻ, chẵn,…</em>Điều này làm cho việc chuyển trạng thái không thểthực hiện đơn thuần.</p><p>Ta có thể sửa điều này bằng cách thêm 1 bit chotrạng thái của cột, chỉ xem đây là trạng thái cho cột lẻhay chẵn.</p><p>Bảng chuyển đổi của mình sẽ chỉ cho phép chuyển từ cộtlẻ sang chẵn và ngược lại.</p><p>Để đơn giản từ giờ ta gọi số trạng thái là <code>P</code> (<code>P &lt;= 110</code>).</p><h3 id="Ma-tran-goc-va-dap-so"><a href="#Ma-tran-goc-va-dap-so" class="headerlink" title="Ma trận gốc và đáp số"></a>Ma trận gốc và đáp số</h3><p>Hiển nhiên ta trận gốc là một ma trận <code>1 x P</code>, trong đócác ô thể hiện trạng thái cột lẻ sẽ là <code>1</code>. Ta nhân ma trậngốc với bảng chuyển đổi đã lũy thừa <code>M - 1</code>, nhận được matrận đáp số <code>1 x P</code>. Đáp án chính là tổng các phần tử trongma trận.</p><p>Độ phức tạp là <code>O(P ^ 3 * log(M))</code>.</p><h2 id="GAMES-1"><a href="#GAMES-1" class="headerlink" title="GAMES"></a>GAMES</h2><h3 id="Tom-tat-de-bai-3"><a href="#Tom-tat-de-bai-3" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho một dãy bit <code>N</code> phần tử chưa xác định và <code>M</code> điều kiện có dạngxor của <code>A[l..r]</code> là 0 hay 1. Tìm vị trí <code>x</code> đầu tiênmà điều kiện <code>x</code> mâu thuẫn với các điều kiện trên.</p><h4 id="Gioi-han-9"><a href="#Gioi-han-9" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 10^9</code>, <code>1 &lt;= M &lt;= 10^5</code></p><h3 id="Chat-nhi-phan"><a href="#Chat-nhi-phan" class="headerlink" title="Chặt nhị phân"></a>Chặt nhị phân</h3><p>Để tìm vị trí đầu tiên mâu thuẫn, ta chặt nhị phân <code>x</code>để tìm vị trí xa nhất mà vẫn tồn tại một dãy thỏa mãncác điều kiện từ 1 đến <code>x</code>.</p><p>Bài toán trở thành kiểm tra xem có một dãy tồn tại không.</p><h3 id="Tinh-chat-mang-don"><a href="#Tinh-chat-mang-don" class="headerlink" title="Tính chất mảng dồn"></a>Tính chất mảng dồn</h3><p>Nếu ta xét mảng dồn <code>S[1..N]</code>, thì điều kiện tổng xor<code>l..r</code> bằng 0 hay 1 tương đương với <code>S[l - 1]</code> với <code>S[r]</code>bằng nhau hay khác nhau.</p><p>Ngoài ra, <code>S[i]</code> có thể nhận được bất kí giá trị nàokhông phụ thuộc vào <code>S[i - 1]</code> nên ta có thể thoải máigán một giá trị bất kì, nhưng chỉ <strong>một</strong> mà thôi.</p><p>Bài toán trở thành, liệu có thể gán dãy <code>S[1..N]</code> thỏamãn các điều kiện các nhau không?</p><h3 id="2-gia-tri-cho-1-bien"><a href="#2-gia-tri-cho-1-bien" class="headerlink" title="2 giá trị cho 1 biến"></a>2 giá trị cho 1 biến</h3><p>Ta có thể coi mảng <code>S[]</code> như một đồ thị <code>N</code> đỉnh. Gộpcác đỉnh cùng giá trị, ta thấy việc gán giá trị 0-1 chocác đỉnh còn lại giống như tô màu 2 phía.</p><p>Như vậy, ta có thể kiểm tra xem đồ thị có phải 2 phía không.</p><p>Độ phức tạp sẽ là <code>O(M + N)</code>.</p><h3 id="Giam-so-luong-dinh"><a href="#Giam-so-luong-dinh" class="headerlink" title="Giảm số lượng đỉnh"></a>Giảm số lượng đỉnh</h3><p>Có tận <code>10^9</code> đỉnh, tuy nhiên chỉ có <code>10^5</code> cạnh. Vì thếchỉ có tối đa <code>2 * 10^5</code> đỉnh có bậc khác 0, ta chỉ cầnquan tâm tới các đỉnh này.</p><p>Độ phức tạp chỉ còn <code>O(M)</code>, mang lại thuật toán <code>O(M * log(M))</code>.</p><h2 id="HANOI-1"><a href="#HANOI-1" class="headerlink" title="HANOI"></a>HANOI</h2><h3 id="Tom-tat-de-bai-4"><a href="#Tom-tat-de-bai-4" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho thuật toán giải bài toán tháp Hà Nội:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HanoiTower</span><span class="params">(height, From, Temp, To)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> height == <span class="number">1</span>:</span><br><span class="line">    <span class="comment"># Move one from `From` to `To`</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  HanoiTower(height - <span class="number">1</span>, From, To, Temp)</span><br><span class="line">  HanoiTower(<span class="number">1</span>, From, Temp, To)</span><br><span class="line">  HanoiTower(height - <span class="number">1</span>, Temp, From, To)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Call the function</span></span><br><span class="line">HanoiTower(N, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>)</span><br></pre></td></tr></table></figure></p><ul><li>Tìm trạng thái của 3 tháp sau <code>P</code> lần gọi hàm.</li><li>Cho trạng thái của 3 tháp, tính số bước đã gọi hàm<code>P</code>, hoặc in <code>-1</code> nếu không tồn tại trạng thái đó khi giải.</li></ul><h4 id="Gioi-han-10"><a href="#Gioi-han-10" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 100</code>. Lưu ý <code>P</code> có thể là số lớn.</p><h3 id="Cac-buoc-cua-thuat-toan"><a href="#Cac-buoc-cua-thuat-toan" class="headerlink" title="Các bước của thuật toán"></a>Các bước của thuật toán</h3><p>Ta có thể tóm tắt thuật toán trong 3 bước:</p><ul><li>Chuyển tháp <code>N - 1</code> từ A sang B dùng C làm đệm</li><li>Chuyển đĩa <code>N</code> từ A sang C</li><li>Chuyển tháp <code>N - 1</code> từ B sang C dùng A làm đệm</li></ul><p>Từ thuật toán, ta có thể xác định mình đang ở bước nàobằng cách xét vị trí của đĩa <code>N</code>.</p><ul><li>Nếu <code>N</code> còn ở <code>A</code> thì ta ở bước 1.</li><li>Nếu không ta ở bước 2 hoặc 3.</li></ul><p>Sau khi xác định được vị trí của <code>N</code>, ta có thể bỏ nó đivà đệ quy xuống bước dưới, coi như ta đang giải bài toánchuyển tháp <code>N - 1</code>.</p><h3 id="Tim-trang-thai-tu-P"><a href="#Tim-trang-thai-tu-P" class="headerlink" title="Tìm trạng thái từ P"></a>Tìm trạng thái từ <code>P</code></h3><p>Ta biết để chuyển tháp <code>x</code> sẽ mất <code>2^x - 1</code> bước,nên khi xét vị trí đĩa <code>N</code> ta có thể xác định xem tađang ở bước mấy của việc chuyển tháp <code>N</code>:</p><ul><li>Nếu <code>P &lt; 2^x</code> thì ta đang ở bước 1.</li><li>Nếu <code>P = 2^x</code> thì ta đang ở bước 2.</li><li>Nếu <code>P &gt; 2^x</code> thì ta đang ở lượt <code>P - 2^x</code> của bước 3.</li></ul><p>Tùy theo bước ta xác định vị trí của đĩa <code>N</code> rồi đệquy xuống bước tương ứng. Độ phức tạp là <code>O(N)</code>.Code khá giống bò trên BST.</p><h3 id="Tim-P-tu-trang-thai"><a href="#Tim-P-tu-trang-thai" class="headerlink" title="Tìm P từ trạng thái"></a>Tìm <code>P</code> từ trạng thái</h3><p>Việc tìm <code>P</code> không khác gì tìm trạng thái. Khi xét tháp<code>N</code>, ta kiểm tra xem mình ở bước nào tùy theo vị trí củađĩa <code>N</code>:</p><ul><li>Nếu <code>N</code> ở A, thì ta ở bước 1. Đệ quy vào bước 1.</li><li>Nếu <code>N</code> ở C, ta ở bước 2 hoặc 3. Cộng <code>P</code> thêm <code>2^x</code> (chobước 1+2) rồi đệ quy vào 3.</li></ul><p>Độ phức tạp cũng là <code>O(N)</code>.</p><h2 id="WG-1"><a href="#WG-1" class="headerlink" title="WG"></a>WG</h2><h3 id="Tom-tat-de-bai-5"><a href="#Tom-tat-de-bai-5" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho một xâu <code>P</code> và một tập xâu <code>S[1..N]</code>. Dựng xâu <code>T</code> như sau:</p><ul><li>Đầu tiên chọn một xâu trong tập <code>S[]</code> và thêm vào <code>T</code></li><li>Sau đó, tìm xâu <code>S[i]</code> bất kì thỏa mãn <code>S[0] == T.back()</code> rồi thêm <code>S[i][1..]</code> vào.</li></ul><p>Hỏi xâu <code>T</code> ngắn nhất chứa dãy con không liên tiếp <code>P</code> là gì?</p><h4 id="Gioi-han-11"><a href="#Gioi-han-11" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= |P| &lt;= 250, 1 &lt;= |S[i]| &lt;= 10, 1 &lt;= N &lt;= 1000</code></p><h3 id="Tham-lam-dung-xau"><a href="#Tham-lam-dung-xau" class="headerlink" title="Tham lam dựng xâu"></a>Tham lam dựng xâu</h3><p>Khi đã có xâu <code>T</code> có thể lấy ra được dãy con là prefix <code>x</code> của <code>P</code>,ta có thể xác định số lượng kí tự ghép thêm khi thêm xâu <code>S[i]</code>bằng cách đi từ trái sang phải, tham lam kí tự tiếp theo cần ghép.</p><p>Từ đó ta tính trước được mảng <code>nx[i][j]</code>, khi thêm xâu <code>i</code> với <code>j</code>kí tự đã ghép thì trạng thái mới là bao nhiêu. Độ phức tạp sẽ là<code>O(N * |P| * |S[i]|)</code>.</p><h3 id="Quy-hoach-dong-1"><a href="#Quy-hoach-dong-1" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Ta có thể quy hoạch động <code>f[i][j]</code> là độ dài xâu <code>T</code> ngắn nhất saocho xâu cuối cùng là <code>i</code> và đã ghép được <code>j</code> kí tự đầu tiên của <code>P</code>.Ta chọn thêm một xâu <code>S[k]</code> mới và chuyển trạng thái sang <code>f[k][nx[k][j]]</code>.Điều kiện là <code>S[i].back() == S[k][0]</code> và <code>nx[k][j] != j</code>.</p><p>Độ phức tạp sẽ là <code>O(N^2 * |P|)</code>, chưa thỏa mãn bài toán.</p><h3 id="Ki-tu-cuoi"><a href="#Ki-tu-cuoi" class="headerlink" title="Kí tự cuối"></a>Kí tự cuối</h3><p>Thực chất ta không cần lưu chiều <code>i</code> là xâu cuối cùng, vì ta chỉcần quan tâm đến kí tự cuối cùng của <code>T</code>, nên thay vào đó ta cóthể chỉ lưu <code>i</code> là kí tự cuối cùng.</p><p>Độ phức tạp giảm xuống còn <code>O(26 * |P| * N)</code>, thỏa mãn bài toán.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Lưu ý&lt;/strong&gt;: Mình đã tóm tắt đề bài ở trên, ai không muốn bị spoil thì đừng
kéo xuống lời giải vội.&lt;/p&gt;
&lt;p&gt;Hôm nay có 5 bài củ
      
    
    </summary>
    
      <category term="Training" scheme="http://blog.nkagami.me/categories/Training/"/>
    
    
      <category term="training" scheme="http://blog.nkagami.me/tags/training/"/>
    
      <category term="apio" scheme="http://blog.nkagami.me/tags/apio/"/>
    
      <category term="vietnamese" scheme="http://blog.nkagami.me/tags/vietnamese/"/>
    
      <category term="thầy Đông" scheme="http://blog.nkagami.me/tags/thay-Dong/"/>
    
  </entry>
  
  <entry>
    <title>2017/04/19 Training</title>
    <link href="http://blog.nkagami.me/2017/04/19/2017-04-19-Training/"/>
    <id>http://blog.nkagami.me/2017/04/19/2017-04-19-Training/</id>
    <published>2017-04-19T08:00:00.000Z</published>
    <updated>2017-10-07T12:05:02.968Z</updated>
    
    <content type="html"><![CDATA[<p>Thầy Phương cho 3 bài của <a href="http://orac.amt.edu.au/cgi-bin/train/hub.pl?expand=fario17#fario17" target="_blank" rel="noopener">FARIO 2017</a>. Bài 1 đã làm rồi, bài 3 là bài approximate nên mình chỉ chữa bài 2.</p><h2 id="Pyramid-Cake"><a href="#Pyramid-Cake" class="headerlink" title="Pyramid Cake"></a>Pyramid Cake</h2><h3 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho một chiếc hộp có đáy chữ nhật <code>M x N</code>, vị trí <code>(i, j)</code> có độ cao là <code>H[i][j]</code>. Ta dựng một chiếc bánh nhiều tần thỏa mãn:</p><ul><li>Các tầng là các hình chữ nhật chứa đỉnh <code>(1,1)</code></li><li>Tầng trên phải nằm bên trong mặt phẳng của tầng dưới</li><li>Không ô nào cao hơn vị trí tương ứng của hộp</li><li>Thể tích bánh là lớn nhất.<h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><code>1 &lt;= N, M &lt;= 1000</code>, <code>1 &lt;= H[i][j] &lt;= 10^8</code></li></ul><h3 id="Lua-chon-tang"><a href="#Lua-chon-tang" class="headerlink" title="Lựa chọn tầng"></a>Lựa chọn tầng</h3><p>Do mọi tầng đề chứa <code>(1, 1)</code>, bản chất ta chỉ cần tọa độ của góc còn lại là có thể xác định được duy nhất tầng hiện tại.</p><p>Tại sao ta chỉ cần quan tâm số tầng mà không phải độ cao? Hiển nhiên, với tầng <code>(i, j)</code> ta biết độ cao của tầng đó (nếu tính cả các tầng dưới nó) sẽ là <code>M[i][j] = min(H[i&#39;][j&#39;])</code> với <code>i&#39; &lt;= i, j&#39; &lt;= j</code>.</p><p>Khi nén tầng như vậy, ta có thể coi như tầng sau luôn nhỏ hơn tầng dưới, làm cho tập trạng thái không có chu trình và ta có thể quy hoạch động được.</p><p>Gọi <code>f[i][j]</code> là diện tích lớn nhất của hình có tầng dưới cùng là <code>(i, j)</code>. Hiển nhiên ta sẽ đặt tầng dưới cùng độ dày <code>M[i][j]</code>. Sau đó, ta chọn một tầng nhỏ hơn để qhđ:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cur = M[i][j] * i * j; <span class="comment">// Diện tích phần đáy</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i; ++k)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= j; ++l)</span><br><span class="line"><span class="keyword">if</span> (k != i || l != j)</span><br><span class="line">f[i][j] = max(f[i][j], cur + f[k][l] - M[i][j] * k * l);</span><br></pre></td></tr></table></figure><p>Tại sao ta trừ đi <code>M[i][j] * k * l</code>? Bởi phần diện tích này đã được tính vào đáy của hình dưới cùng.</p><p>Đáp số sẽ là <code>max(f[i][j])</code>, độ phức tạp là <code>O(N^4)</code>, chưa đủ để giải quyết bài toán.</p><h3 id="Thu-tat-ca"><a href="#Thu-tat-ca" class="headerlink" title="Thử tất cả?"></a>Thử tất cả?</h3><p>Ta có thể thấy, mỗi hình chữ nhật con đều nhỏ hơn đáy ban đầu ít nhất 1 hàng hoặc 1 cột. Vậy tại sao mình không chọn 1 trong 2 hình to nhất (<code>(i, j - 1)</code> và <code>(i - 1, j)</code>) để làm đáy tiếp theo?</p><p>Rất có thể mọi người sẽ nghĩ việc này không đúng vì có thể không điền đc thêm tầng nào - nhưng nếu ta nghĩ theo cách nhìn khác - ta thêm <strong>0</strong> tầng, thì lựa chọn vẫn hợp lí.</p><p>Có thể việc này không tối ưu không? Giả sử, lựa chọn <code>(x, y)</code> (<code>x &lt; i, y &lt; j</code>) là tối ưu. Hiển nhiên nó cũng sẽ tối ưu cho <code>(i, j - 1)</code>. Vậy ta hoàn toàn có thể chọn <code>(i, j - 1)</code> và nó sẽ chứa cả <code>(x, y)</code>, kết quả không đổi.</p><h3 id="Cai-thien-thuat-toan"><a href="#Cai-thien-thuat-toan" class="headerlink" title="Cải thiện thuật toán"></a>Cải thiện thuật toán</h3><p>Ta rút việc chọn tất cả cặp thành chọn một trong hai hình chữ nhật con lớn nhất. Độ phức tạp giảm xuống còn <code>O(N^2)</code>, thỏa mãn bài toán.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Thầy Phương cho 3 bài của &lt;a href=&quot;http://orac.amt.edu.au/cgi-bin/train/hub.pl?expand=fario17#fario17&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FAR
      
    
    </summary>
    
      <category term="Training" scheme="http://blog.nkagami.me/categories/Training/"/>
    
    
      <category term="training" scheme="http://blog.nkagami.me/tags/training/"/>
    
      <category term="apio" scheme="http://blog.nkagami.me/tags/apio/"/>
    
      <category term="vietnamese" scheme="http://blog.nkagami.me/tags/vietnamese/"/>
    
      <category term="thầy Phương" scheme="http://blog.nkagami.me/tags/thay-Phuong/"/>
    
  </entry>
  
  <entry>
    <title>2017/04/18 Training</title>
    <link href="http://blog.nkagami.me/2017/04/18/2017-04-18-Training/"/>
    <id>http://blog.nkagami.me/2017/04/18/2017-04-18-Training/</id>
    <published>2017-04-18T07:22:18.000Z</published>
    <updated>2017-10-07T12:05:02.968Z</updated>
    
    <content type="html"><![CDATA[<p>Hôm nay Hạnh dạy. Nói chung như mọi lần Hạnh dạy, bài thì hay nhưng có vẻ như Hạnh vẫn tốn rất nhiều thời gian giảng bài. Mình thực sự không muốn nghe cho lắm vì vẫn muốn nghĩ bài một mình, sau đó có reference của Hạnh để improve solution thì vẫn thích hơn.</p><h2 id="Stretching-Streamers-NAIPC-2017-bai-C"><a href="#Stretching-Streamers-NAIPC-2017-bai-C" class="headerlink" title="Stretching Streamers (NAIPC 2017, bài C)"></a><a href="https://naipc17.kattis.com/problems/naipc17.stretchingstreamers" target="_blank" rel="noopener">Stretching Streamers (NAIPC 2017, bài C)</a></h2><h3 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Có <code>N</code> điểm viết trên một đường tròn, điểm thứ <code>i</code> chứa số nguyên dương <code>A[i]</code>. 2 số có cạnh đến nhau khi ước chung lớn nhất lớn hơn 1. Không được chọn 2 cạnh đè lên nhau (trừ khi đè ở đầu mút), đếm số cách dựng cây khung <code>N</code> điểm mod <code>1e9 + 7</code>.</p><h5 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h5><p><code>3 &lt;= N &lt;= 300</code>, <code>2 &lt;= A[i] &lt;= 10^9</code>.</p><h3 id="Dung-cay-nhu-nao"><a href="#Dung-cay-nhu-nao" class="headerlink" title="Dựng cây như nào?"></a>Dựng cây như nào?</h3><p>Đơn giản ta có thể tóm tắt quá trình dựng cây như sau:</p><ul><li>Đầu tiên chọn đỉnh <code>1</code> làm gốc.</li><li>Từ đỉnh <code>1</code> chọn một tập đỉnh <code>X[1..M]</code> là con của đỉnh <code>1</code>. Hiển nhiên 1 phải có cạnh đến tất cả các đỉnh trong tập.</li><li>Mỗi đỉnh <code>X[i]</code> quản lí 1 đoạn <code>L[i] &lt;= X[i] &lt;= R[i]</code> sao cho <code>L[1] = 2</code>; <code>R[i] + 1 = L[i + 1]</code> và <code>R[M] = N</code>. (1)</li><li><p>Ta dựng cây cho mỗi đoạn <code>L[i]..R[i]</code>, với điều kiện không có cạnh <code>(x, y)</code> với <code>x &lt;= X[i] &lt;= y</code>. Để tính cái này ta làm tương đương, đệ quy xuống.</p><p>Tại sao lại có (1)? Đơn giản vì không thể tồn tại cạnh sao cho 2 đỉnh nằm 2 bên của một <code>X[i]</code> nào đó, vì chúng sẽ cắt qua cạnh <code>(1, X[i])</code>.</p></li></ul><h3 id="Bien-doi-doan-L-i-R-i"><a href="#Bien-doi-doan-L-i-R-i" class="headerlink" title="Biến đổi đoạn L[i]..R[i]."></a>Biến đổi đoạn <code>L[i]..R[i]</code>.</h3><p>Do có điều kiện không có cạnh <code>(x, y)</code> mà <code>x &lt;= X[i] &lt;= y</code> nên ta có thể chia đoạn <code>L[i]..R[i]</code> thành 2 đoạn <code>L[i]..X[i]</code> và <code>X[i]..R[i]</code> độc lập mà vẫn không thay đổi kết quả bài toán.</p><p>Khi đó, điều kiện đặc biệt biến mất và ta chỉ cần đệ quy xuống với các đoạn <code>L[1]..X[1]</code>, <code>X[1]..R[1]</code>, <code>L[2]..X[2]</code>, …, <code>X[M]..R[M]</code>.</p><h3 id="Cong-thuc-quy-hoach-dong"><a href="#Cong-thuc-quy-hoach-dong" class="headerlink" title="Công thức quy hoạch động"></a>Công thức quy hoạch động</h3><p>Từ các nhận xét trên, ta có công thức quy hoạch động sau:</p><p>Gọi <code>f[l][r]</code> là số cách dựng cây với các đỉnh thuộc đoạn <code>l..r</code>. Hiển nhiên <code>f[i][i] = 1</code>.</p><p>Ta có<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = l + <span class="number">1</span>; k &lt;= r; ++k)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> st = l + <span class="number">1</span>; st &lt;= k; ++st)</span><br><span class="line">    f[l][r] += f[l][st - <span class="number">1</span>] * f[st][k] * f[k][r];</span><br></pre></td></tr></table></figure></p><p>Việc chọn tập <code>X[]</code> cho <code>[l..r]</code> giống với việc từ đoạn <code>[l..st - 1]</code> đã dựng cây, ta thêm đoạn <code>[st..r]</code> bằng cách nối <code>(l, k)</code> (<code>st &lt;= k &lt;= r</code>) rồi dựng 2 cây như trên. Do đó công thức qhđ này hoàn toàn chính xác. Đáp số sẽ là <code>f[1][N]</code>. Tuy nhiên độ phức tạp là <code>O(N^4)</code>, chưa đủ để thỏa mãn đề bài.</p><h3 id="Toi-uu-xuong-O-N-3"><a href="#Toi-uu-xuong-O-N-3" class="headerlink" title="Tối ưu xuống O(N^3)"></a>Tối ưu xuống <code>O(N^3)</code></h3><p>Việc chọn đoạn yêu cầu 2 bước, xác định <code>X[i]</code> và đoạn <code>st..r</code>. Liệu ta có thể giảm thiểu số cách lựa chọn không?</p><p>Thực chất ta hoàn toàn có thể tách 2 bước này thành 2 công đoạn chọn đoạn, đầu tiên chọn <code>st..X[i]</code> thỏa mãn có cạnh <code>(l, X[i])</code> và chọn đoạn <code>X[i]..r</code>. Như vậy ta có thể chọn 2 đoạn so le, mỗi lần chuyển trạng thái chỉ mất <code>O(N)</code>.</p><p>Ta sửa lại công thức qhđ thành <code>f[i][j][k]</code>, thêm <code>k</code> là bước hiện tại của chúng ta (<code>0</code> - chọn nửa đoạn đầu - hay <code>1</code> - đã chọn xong). Công thức trở thành:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = l + <span class="number">1</span>; k &lt;= r; ++k) &#123;</span><br><span class="line">  <span class="keyword">if</span> (__gcd(l, r) &gt; <span class="number">1</span>) <span class="comment">// có cạnh từ l đến k</span></span><br><span class="line">    f[l][r][<span class="number">0</span>] += f[l][k - <span class="number">1</span>][<span class="number">1</span>] * f[k][r][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> (__gcd(l, k) &gt; <span class="number">1</span>)</span><br><span class="line">    f[l][r][<span class="number">1</span>] += f[l][k][<span class="number">0</span>] * f[k][r][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Lúc đầu <code>f[i][i][x] = x</code> và đáp số sẽ là <code>f[1][N][1]</code>. Độ phức tạp là <code>O(N^3)</code>.</p><h2 id="LISA-RCC-2017-1st-Qualification-Round-bai-E"><a href="#LISA-RCC-2017-1st-Qualification-Round-bai-E" class="headerlink" title="LISA - RCC 2017 1st Qualification Round, bài E"></a><a href="http://www.russiancodecup.ru/en/tasks/round/61/E/" target="_blank" rel="noopener">LISA - RCC 2017 1st Qualification Round, bài E</a></h2><h3 id="Tom-tat-de-bai-1"><a href="#Tom-tat-de-bai-1" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho <code>N</code> xâu và <code>Q</code> truy vấn. Mỗi truy vấn gồm 2 số <code>l, r</code> và yêu cầu trả lời số xâu khác nhau có thể tạo được bằng cách ghép 1 tiền tố khác rỗng với 1 hậu tố khác rỗng của xâu nào đó trong khoảng từ <code>l</code> đến <code>r</code>.</p><h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N, Q &lt;= 10^5</code>. Tổng độ dài xâu không quá <code>10^5</code>.</p><h3 id="Ghep-tien-to-va-hau-to"><a href="#Ghep-tien-to-va-hau-to" class="headerlink" title="Ghép tiền tố và hậu tố"></a>Ghép tiền tố và hậu tố</h3><p>Ta có thể thấy ngay nếu không có điều kiện “khác nhau”, đáp số chỉ là <code>(số tiền tố trong đoạn) * (số hậu tố trong đoạn)</code>. Tuy nhiên có 2 vấn đề sau xảy ra khi ta cần tìm những xâu khác nhau:</p><ul><li>Có thể tồn tại cặp tiền tố giống nhau - đây là phần dễ.</li><li>Tồn tại 2 cặp tiền tố - hậu tố khác nhau nhưng cho ra xâu ghép giống nhau.</li></ul><h3 id="Dieu-kien-dem"><a href="#Dieu-kien-dem" class="headerlink" title="Điều kiện đếm"></a>Điều kiện đếm</h3><p>Một trong những kĩ thuật tiêu biểu khi đếm để xử lí lặp là đặt thêm điều kiện cho bài toán sao cho chúng khử đi các trường hợp lặp.</p><p>Giả sử ta có 2 xâu <code>Pre[i]</code> và <code>Suf[j]</code>, ta có <code>X = Pre[i] + Suf[j]</code>. Vậy nếu tồn tại một cặp khác <code>X = Pre[k] + Suf[l]</code> thì ta có tính chất gì?</p><p>Không mất tính tổng quát, giả sử <code>|Pre[i]| &lt; |Pre[k]|</code>. Ta có thể thấy phần <em>thừa ra</em> của <code>Pre[k]</code> chính bằng phần <em>thừa ra</em> của <code>Suf[j]</code>.Như vậy, một cách nghĩ có thể là loại bỏ tất cả việc ghép của các xâu <code>Suf[l]</code> khi đã tồn tại một <em>phần thừa chung</em> như trên.</p><p>Bởi vì ta đã lấy ra tất cả tiền tố, nên nếu tồn tại 2 cặp xâu như trên thì sẽ luôn tồn tại <code>X = (Pre[i] + c) + (Suf[j][1..])</code>, trong đó <code>c</code> là chữ cái đầu tiên của <code>Suf[j]</code>, và <code>Pre[i] + c</code> cũng là 1 tiền tố (vì nó là tiền tố của <code>Pre[k]</code>). Như vậy, luôn tồn tại các cặp chỉ lệch nhau 1 kí tự - và ta chỉ cần đặt thêm điều kiện để khử trường hợp lệch 1 kí tự là đủ.</p><h3 id="Ki-tu-thua"><a href="#Ki-tu-thua" class="headerlink" title="Kí tự thừa"></a>Kí tự <em>thừa</em></h3><p>Xét trường hợp <code>X = (Pre[i] + c) + (Suf[j][1..])</code>. Ta có thể thêm vào điều kiện sau:Xét <code>Suf[j]</code>, nếu <code>c + Suf[j]</code> cũng là một hậu tố trong tập, thì ta <strong>không được</strong> ghép <code>Suf[j]</code> với <code>Pre[i&#39;] = Pre[i] + c</code>.</p><p>Dễ dàng chứng minh tất cả xâu cần tìm đều tồn tại cách ghép <em>duy nhất</em> thỏa mãn điều kiện.</p><p>Lưu ý <code>Pre[i&#39;]</code> phải là <code>Pre[i] + c</code>, tức phải có ít nhất 2 kí tự.</p><p>Ta gọi các xâu <code>c + Suf[j]</code> không thuộc tập hậu tố là xâu <em>kí tự thừa</em> <code>c</code>.</p><h3 id="Dem-nhu-the-nao"><a href="#Dem-nhu-the-nao" class="headerlink" title="Đếm như thế nào?"></a>Đếm như thế nào?</h3><p>Với điều kiện trên, lời giải của ta sẽ gồm các bước:</p><ul><li>Đếm số tiền tố khác nhau kết thúc ở <code>c</code>.</li><li>Đếm số xâu <em>kí tự thừa</em> <code>c</code>, nhân với số tiền tố đã tìm được ở trên.</li><li>Với mỗi hậu tố, kiểm tra xem liệu ta có thể tạo được hậu tố bằng cách ghép 1 kí tự đầu tiên từ 1 tiền tố nào đó với các kí tự còn lại của hậu tố. Vốn dĩ việc này là cần thiết bởi vì đây là trường hợp duy nhất mà 1 xâu có thể được tạo từ một hậu tố không có kí tự thừa, và không được xét ở trường hợp trên.</li></ul><h3 id="So-tien-to-khac-nhau"><a href="#So-tien-to-khac-nhau" class="headerlink" title="Số tiền tố khác nhau"></a>Số tiền tố khác nhau</h3><p>Trước tiên ta sort lại các truy vấn theo <code>R[i]</code> và xử lí offline.</p><p>Lần lượt thêm các tiền tố vào Trie (chống lặp), đồng thời lưu lại với mỗi nút lần cuối cùng nó xuất hiện.</p><p>Giả sử ta đang ở truy vấn <code>L[i], R[i]</code> và đã thêm tất cả các tiền tố của <code>S[i]..S[R[i]]</code>. Không khó để nhìn ra số lượng tiền tố khác nhau chính là số nút mà lần xuất hiện cuối cùng <code>&gt;= L[i]</code>. Ta có thể dùng IT hoặc BIT làm công cụ đếm phân phối số nút xuất hiện ở từng thời điểm và tính tổng nhanh.</p><p>Để có thể tính số tiền tố xuất hiện mà kết thúc với kí tự <code>c</code> cụ thể, ta có thể dùng 26 IT / BIT thay vì 1, với mỗi loại tiền tố ta có 1 cây đếm phân phối riêng.</p><p>Độ phức tạp mỗi truy vấn là <code>O(26 * log(N))</code>.</p><h3 id="So-hau-to-voi-ki-tu-thua"><a href="#So-hau-to-voi-ki-tu-thua" class="headerlink" title="Số hậu tố với kí tự thừa"></a>Số hậu tố với <em>kí tự thừa</em></h3><p>Trước tiên, vì bản chất xâu thừa chính là <code>c + Suf[i]</code> nên sẽ có <code>(số tiền tố khác nhau)</code> xâu như vậy (với 1 kí tự <code>c</code>). Tuy nhiên ta phải trừ đi các xâu cũng là hậu tố - chính là số hậu tố bắt đầu với <code>c</code> mà có trên 1 kí tự. Để đếm số lượng xâu bị tính thừa ta có thể lật ngược xâu, biến hậu tố thành tiền tố và đếm như phần trên.</p><p>Phần này ta cũng làm <code>O(26 * log(N))</code> mỗi truy vấn.</p><h3 id="Cac-hau-to-cong-them"><a href="#Cac-hau-to-cong-them" class="headerlink" title="Các hậu tố cộng thêm"></a>Các hậu tố cộng thêm</h3><p>Phần này khá đơn giản, với mỗi hậu tố bắt đầu với kí tự <code>c</code> ta có thể kiểm tra có tồn lại hậu tố <code>Pre[i] = c</code> nào không. Ta có thể làm kèm với thao tác đếm ở trên.</p><h3 id="Tong-ket"><a href="#Tong-ket" class="headerlink" title="Tổng kết"></a>Tổng kết</h3><p>Với <code>Q</code> truy vấn, độ phức tạp sẽ là <code>O(Q * 26 * log(N))</code>, nên cẩn thận 1 chút ở phần cài đặt nếu không có thể sẽ bị TLE vì cài ẩu.</p><h2 id="Electric-Charges-AIM-Tech-Round-Div-1"><a href="#Electric-Charges-AIM-Tech-Round-Div-1" class="headerlink" title="Electric Charges - AIM Tech Round (Div. 1)"></a><a href="http://codeforces.com/contest/623/problem/C" target="_blank" rel="noopener">Electric Charges - AIM Tech Round (Div. 1)</a></h2><h3 id="Tom-tat-de-bai-2"><a href="#Tom-tat-de-bai-2" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho <code>N</code> điểm trên mặt phẳng. Gióng chúng xuống trục Ox hoặc Oy sao cho khoảng cách giữa 2 điểm gióng xuống xa nhất là nhỏ nhất có thể.</p><h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 10^5</code>, <code>-10^8 &lt;= X[i], Y[i] &lt;= 10^8</code></p><h3 id="Chat-nhi-phan"><a href="#Chat-nhi-phan" class="headerlink" title="Chặt nhị phân"></a>Chặt nhị phân</h3><p>Trong bài này ta sử dụng chặt nhị phân, một cách thông dụng để giải các bài min-của-max. Bài toán trở thành: tìm một cách xếp sao cho khoảng cách không quá <code>X</code>?</p><h3 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT??"></a>2-SAT??</h3><p>Tuấn nghĩ ra thuật 2-SAT… Có thể AC nhũng chẳng hay chút nào :D Hiển nhiên một bài C div 1 không thể tốn nhiều thời gian code như thế… Đây không phải round của amd.</p><h3 id="Chon-mot-moc"><a href="#Chon-mot-moc" class="headerlink" title="Chọn một mốc"></a>Chọn một mốc</h3><p>Tóm lại ta phải tối ưu max của 3 cái sau:</p><ul><li><code>(minX - maxX)^2</code></li><li><code>(minY - maxY)^2</code></li><li><code>max(minX^2, maxX^2) + max(minY^2, maxY^2)</code>Ý tưởng đầu tiên sẽ là for một biến, giả sử <code>minX</code>, và tham lam các biến còn lại.</li></ul><p>Khi có <code>minX</code>, ta tính được <code>maxX</code>. Hiển nhiên các điểm có <code>X[i] &lt; minX</code> hoặc <code>X[i] &gt; maxX</code> đều phải chọn sang <code>Y</code>. Ta chỉ cần lấy min và max của các <code>Y[i]</code> đó, so sánh. Bài toán đơn giản?</p><p>Thuật toán sai rồi. Rất có thể <code>maxX^2</code> &gt; <code>minX^2</code> và sẽ làm cho thuật toán bị ảo tưởng.</p><h3 id="Chon-mot-diem"><a href="#Chon-mot-diem" class="headerlink" title="Chọn một điểm"></a>Chọn một điểm</h3><p>Thay vì chọn 1 mốc như <code>minX</code>, ta chọn một điểm và coi nó là <code>minX</code>, đồng thời là điểm có <code>abs(X[i])</code> lớn nhất được chọn làm <code>X</code>. Khi đó ta có thể yên tâm bốc các điểm nằm ngoài khoảng giới hạn đó là <code>Y</code> và chỉ cần kiểm tra các khoảng cách còn lại.</p><h3 id="Tinh-cac-Y-nhu-nao"><a href="#Tinh-cac-Y-nhu-nao" class="headerlink" title="Tính các Y như nào?"></a>Tính các <code>Y</code> như nào?</h3><p>Tóm lại ta cần tính nhanh minY và maxY ở khoảng các điểm có <code>X &lt; L</code> và <code>X &gt; R</code> với <code>L, R</code> bất kì. Ta có thể sort lại các điểm theo tọa độ của <code>X</code>, sau đó xây các mảng dồn min, max để lấy nhanh prefix và suffix.</p><p>Xây mất <code>O(N log(N))</code> (sắp xếp) và truy vấn <code>O(1)</code>.</p><h3 id="Lat-leo"><a href="#Lat-leo" class="headerlink" title="Lắt léo"></a>Lắt léo</h3><p>Còn một trường hợp nữa ta chưa xét đến: chọn tất cả theo trục Y. Trường hợp này không khó, check <code>(maxY - minY) ^ 2</code> là xong. Tuy vậy mình không nghĩ ra trước khi nộp :(</p><h3 id="Tong-ket-1"><a href="#Tong-ket-1" class="headerlink" title="Tổng kết"></a>Tổng kết</h3><p>Tóm lại ta cần chặt nhị phân, khi kiểm tra cần chạy con trỏ hoặc lấy lower/upper bound. Việc chạy con trỏ khá lằng nhằng không cần thiết nên mình không code. Độ phức tạp là <code>(O(N * log(N) * log(10^17)))</code> hoặc <code>O(N * log(10^17))</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hôm nay Hạnh dạy. Nói chung như mọi lần Hạnh dạy, bài thì hay nhưng có vẻ như Hạnh vẫn tốn rất nhiều thời gian giảng bài. Mình thực sự kh
      
    
    </summary>
    
      <category term="Training" scheme="http://blog.nkagami.me/categories/Training/"/>
    
    
      <category term="training" scheme="http://blog.nkagami.me/tags/training/"/>
    
      <category term="apio" scheme="http://blog.nkagami.me/tags/apio/"/>
    
      <category term="vietnamese" scheme="http://blog.nkagami.me/tags/vietnamese/"/>
    
      <category term="anh Hạnh" scheme="http://blog.nkagami.me/tags/anh-Hanh/"/>
    
  </entry>
  
  <entry>
    <title>2017/04/15 Training</title>
    <link href="http://blog.nkagami.me/2017/04/16/2017-04-15-Training/"/>
    <id>http://blog.nkagami.me/2017/04/16/2017-04-15-Training/</id>
    <published>2017-04-16T05:34:00.000Z</published>
    <updated>2017-10-07T12:05:02.967Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Warning</strong>: If you want to try solving the problems, skip reading everything but the statements! Also, for hints, read <em>slowly</em> from top to bottom of each problem.</p><p>I didn’t attend the class directly, but did the problems while going on a bus to Ninh Binh. The problems were somewhat exciting to me.</p><h2 id="A-Sorting"><a href="#A-Sorting" class="headerlink" title="A. Sorting"></a>A. Sorting</h2><h3 id="Statements"><a href="#Statements" class="headerlink" title="Statements"></a>Statements</h3><p>You are given a permutation <code>A[1..N]</code>, along with <code>Q</code> queries, each of the form <code>l, r</code> which you should sort the subarray <code>A[l..r]</code> increasingly or decreasingly. After all the queries are processed, print the middle value <code>A[N / 2 + 1]</code>.</p><h4 id="Contraints"><a href="#Contraints" class="headerlink" title="Contraints"></a>Contraints</h4><p><code>1 &lt;= N &lt;= 10^5</code>, <code>1 &lt;= Q &lt;= 10^5</code>, <code>N</code> is odd.</p><h3 id="One-problem-from-the-past"><a href="#One-problem-from-the-past" class="headerlink" title="One problem from the past"></a>One problem from the past</h3><p>The statements reminds me of a past problem I did on Codeforces. I didn’t remember the source, but in short you are given a Latin string with the same sorting queries, and then you have to return the whole string. It was feasible to solve the problem in <code>O(Q * 26 * log(N))</code> time because of the limited alphabet size.</p><p>The main idea is, for each <code>l, r</code> query, count the number of instances of each character in the range. Then we can re-assign the characters’ positions, from the smallest to the largest. To efficiently do range-counting and range-assignments we can maintain 26 <em>interval trees</em>, with lazy update.</p><p>However, the problem I faced yesterday was different: the alphabet size is much bigger. Perhaps a different approach was needed. Or maybe not?</p><h3 id="The-alphabet-size"><a href="#The-alphabet-size" class="headerlink" title="The alphabet size"></a>The alphabet size</h3><p>From the previous problem, we know that the problem can be solved efficiently if the alphabet size was small. “Is there anyway to make the numbers pool smaller?” - that was the first question that came to my mind.</p><p>The above problem somewhat resembles radix sorting, so of course it can also be applied to numbers. However splitting digits is not eligible, as reordering still takes too much time. We need to transform numbers into something that’s both small in size and easy to reassign, maybe not even caring about its original value.</p><p>The problem only asked for <strong>one</strong> element. What if, all we care about is the element itself?</p><h3 id="Relative-ordering"><a href="#Relative-ordering" class="headerlink" title="Relative ordering"></a>Relative ordering</h3><p>It turns out that we don’t actually need to sort the elements. Not entirely.</p><p>Let’s choose a pivot, <code>X</code>. We transform every number larger than <code>X</code> to <code>1</code>, and the rest to <code>0</code>. Sorting becomes wrong now, but the order <em>relative to <code>X</code></em> isn’t: If we sort <code>l, r</code> increasingly, every number that’s smaller than <code>X</code> still stays on the left of those which are larger than <code>X</code>. Therefore, this <em>masked</em> ordering isn’t entirely wrong, because the correct ordering <strong>have the same mask</strong>, and we can assume that the unlerlying original values are on the correct positions. Of course, we don’t need to care about it.</p><p>Of course, since the numbers are binary now, performing the above algorithm becomes a breeze.</p><p>After all the sortings, we get the middle number’s mask. It doesn’t give us the answer immediately, but it does leave a hint: If the number is <strong>1</strong> then the answer is <strong>larger than <code>X</code></strong>, and vice versa.</p><h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h3><p>To effectively use the previous hint, we can perform <em>binary search</em> on the value of <code>A[N / 2 + 1]</code>, checking whether it’s larger than the middle value, and shorten the range according to the answer.That is also the final missing piece to solve the problem, giving us an <code>O(log(N) * Q * log(N))</code> algorithm.</p><h2 id="B-Zigzag"><a href="#B-Zigzag" class="headerlink" title="B. Zigzag"></a>B. Zigzag</h2><h3 id="Statements-1"><a href="#Statements-1" class="headerlink" title="Statements"></a>Statements</h3><p>You are given an array <code>A[1..N]</code> of distinct numbers. There are also <code>Q</code> queries, each of the form <code>x y</code> that asks you to change the <code>x</code>-th number to <code>y</code>. It is guaranteed that after each query the array always contains dintinct numbers. After each query you have to return the largest alternating subsequence of the array.</p><h4 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h4><p><code>1 &lt;= N &lt;= 10^6</code>, <code>1 &lt;= A[i] &lt;= 10^9</code></p><h3 id="Alternating-Subsequence"><a href="#Alternating-Subsequence" class="headerlink" title="Alternating Subsequence"></a>Alternating Subsequence</h3><p>The first thing to do is analyzing the <strong>longest alternating subsequence</strong> problem. It turns out that it is not as difficult as it sounds, in fact it can be greedily built from an array with distinct numbers.</p><p>One nice observation from the problem: If there exists such <code>i</code> that <code>A[i - 1] &lt;= A[i] &lt;= A[i + 1]</code>, then there always exists an optimal subsequence without <code>A[i]</code>. Why? Since they’re consecutive numbers, <code>A[i - 1]</code> is always better than <code>A[i]</code> as a “lower” number, and <code>A[i + 1]</code> is always better than <code>A[i]</code> as an “upper” numbber. Therefore, it is safe to just remove <code>A[i]</code> from the array without losing the optimal sequence.</p><p>Now let’s continuously remove such numbers from the array until there is no such one. Which means, for each <code>i</code>, it is either <code>A[i - 1] &lt;= A[i] &amp;&amp; A[i] &gt;= A[i + 1]</code> or <code>A[i - 1] &gt;= A[i] &amp;&amp; A[i] &lt;= A[i + 1]</code>. Wait… Isn’t <code>A[..]</code> now already an alternating sequence? More than that, <code>A[..]</code> is an <strong>optimal</strong> longest alternating subsequence of the original array.</p><p>Dive a little deeper, we will find out that each <code>A[i]</code> can be a part of the new array <strong>if and only if</strong> has the same above atrribute on the original array. <em>Unless</em> it’s the first or last number of the array, in such case it’s always included.</p><h3 id="Testing-an-element"><a href="#Testing-an-element" class="headerlink" title="Testing an element"></a>Testing an element</h3><p>With the above observations, we can deduce whether an element will appear in our optimal subsequence:</p><ul><li>It’s the first or last element, <em>or</em></li><li>Either it’s both smaller or both bigger than its neighboring elements.</li></ul><p>Using these conditions we can check each element in <code>O(1)</code>. To answer the length of the optimal subsequence one only has to count how many elements satisfies the above conditions.</p><h3 id="Processing-queries"><a href="#Processing-queries" class="headerlink" title="Processing queries"></a>Processing queries</h3><p>If we change one number, how is each element’s satisfiability affected? It turns out, only 3 of them are affected at most: the element itself, and its neighboring elements.</p><p>It is now easy to process each query in <code>O(1)</code>: just change the element and re-check every affected elements.</p><p>That concludes our <code>O(N + M)</code> algorithm.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: If you want to try solving the problems, skip reading everything but the statements! Also, for hints, read &lt;em&gt;
      
    
    </summary>
    
      <category term="Training" scheme="http://blog.nkagami.me/categories/Training/"/>
    
    
      <category term="training" scheme="http://blog.nkagami.me/tags/training/"/>
    
      <category term="apio" scheme="http://blog.nkagami.me/tags/apio/"/>
    
      <category term="english" scheme="http://blog.nkagami.me/tags/english/"/>
    
      <category term="anh Minh" scheme="http://blog.nkagami.me/tags/anh-Minh/"/>
    
  </entry>
  
  <entry>
    <title>First Post</title>
    <link href="http://blog.nkagami.me/2016/10/10/First-Post/"/>
    <id>http://blog.nkagami.me/2016/10/10/First-Post/</id>
    <published>2016-10-10T06:10:19.000Z</published>
    <updated>2017-10-07T12:05:03.013Z</updated>
    
    <content type="html"><![CDATA[<p>I started a blog, yay! The purpose of this blog will be for me to express random thoughts, coding experiences and to show everyone my work. That’s all. Thank you for reading my first post!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I started a blog, yay! 
The purpose of this blog will be for me to express random thoughts, coding experiences and to show everyone my wo
      
    
    </summary>
    
      <category term="Thoughts" scheme="http://blog.nkagami.me/categories/Thoughts/"/>
    
    
      <category term="First Post" scheme="http://blog.nkagami.me/tags/First-Post/"/>
    
  </entry>
  
</feed>
