<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kagami&#39;s Blog</title>
  <subtitle>IOI Medalist, osu! lover, I tryhard everything.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://natsukagami.github.io/"/>
  <updated>2017-04-28T15:27:12.630Z</updated>
  <id>http://natsukagami.github.io/</id>
  
  <author>
    <name>Natsu Kagami</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2017/04/28 Training</title>
    <link href="http://natsukagami.github.io/2017/04/28/2017-04-28-Training/"/>
    <id>http://natsukagami.github.io/2017/04/28/2017-04-28-Training/</id>
    <published>2017-04-28T13:00:00.000Z</published>
    <updated>2017-04-28T15:27:12.630Z</updated>
    
    <content type="html"><![CDATA[<p>Hôm nay có hai phần: bài thầy Hoàng và bài
anh Khuê.
Cả 2 đều cần một sự tay to nhất định.</p>
<h1 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h1><h2 id="select-thay-Hoang"><a href="#select-thay-Hoang" class="headerlink" title="select (thầy Hoàng)"></a>select (thầy Hoàng)</h2><p>Cho dãy $S$ gồm các kí tự <code>d</code> và <code>x</code>. 2 người lần
lượt chơi, mỗi lượt bốc 1 kí tự, kí tự này phải đứng
cạnh 1 vị trí đã bị chọn trước đó (trừ nước
đầu tiên được chọn thoải mái). Khi trò chơi
kết thúc, người đi trước thắng khi có nhiều <code>d</code>
<strong>hơn hẳn</strong> người kia. Đếm số vị trí ban đầu
mà người đi trước có thể chọn mà vẫn đảm bảo
chiến thắng?</p>
<h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le |S| \le 1000$.</p>
<h2 id="eureka-thay-Hoang"><a href="#eureka-thay-Hoang" class="headerlink" title="eureka (thầy Hoàng)"></a>eureka (thầy Hoàng)</h2><p>Cho một hệ thống cân đĩa được biểu diễn như
sau:</p>
<ul>
<li>Nếu chỉ gồm <code>-1</code>: Đây là một vị trí đặt
quả cân.</li>
<li>Là một cái cân có dạng <code>x y A B</code> trong đó
$x$ và $y$ lần lượt là độ dài cánh tay đòn
bên trái và bên phải của cân; $A$ và $B$ là
2 hệ thống cân được treo vào bên trái và
bên phải của cân.</li>
</ul>
<p>Hình dưới biểu diễn hệ thống cân được biểu diễn
bằng dãy <code>12 18 4 2 -1 -1 10 8 3 3 -1 -1 6 4
-1 -1</code>:</p>
<p><img src="/images/eureka_exp.png" alt="Mô tả cân (các ô có nền xanh là
các quả cân)"></p>
<p>Trọng lượng các quả cân đều phải là số
nguyên dương.</p>
<p>Hãy tìm trọng lượng cho các quả cân của từng vị
trí đặt sao cho tất cả các cân đều thăng bằng
và tổng trọng lượng các quả cân phải đặt là nhỏ
nhất. Giả sử cân không có trọng lượng.</p>
<p>In ra tổng nhỏ nhất lấy dư cho $123456789$.</p>
<h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>Miêu tả được cho bởi dãy $A[1..N]$.</p>
<p>$1 \le N \le 3 \times 10^5$, $A[i] = -1$ hoặc
$1 \le A[i] \le 100$.</p>
<h2 id="liondance-thay-Hoang"><a href="#liondance-thay-Hoang" class="headerlink" title="liondance (thầy Hoàng)"></a>liondance (thầy Hoàng)</h2><p>Cho 2 dãy số $A[1..N]$ và $B[1..N]$. Tìm dãy
con chung dài nhất sao cho 2 phần tử liên
tiếp chênh lệch nhau không quá $d$.</p>
<p>Nếu có nhiều dãy, in ra dãy có <strong>thứ tự từ
điển</strong> lớn nhất.</p>
<h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 4000$, $1 \le A[i], B[i] \le 10^9$</p>
<h2 id="desert-thay-Hoang"><a href="#desert-thay-Hoang" class="headerlink" title="desert (thầy Hoàng)"></a>desert (thầy Hoàng)</h2><p>Trên mặt phẳng cho $N$ điểm. Tìm đường đi từ
$1$ đến $N$ sao cho khoảng cách Manhattan
lớn nhất giữa 2 điểm liên tiếp đi qua là
nhỏ nhất.</p>
<h4 id="Gioi-han-3"><a href="#Gioi-han-3" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 10^5$, tọa độ $-10^9 \le X_i,
Y_i\le 10^9$</p>
<h2 id="Tron-viec-anh-Khue"><a href="#Tron-viec-anh-Khue" class="headerlink" title="Trốn việc (anh Khuê)"></a>Trốn việc (anh Khuê)</h2><p>Cho dãy số $A[1..3N]$, chọn ra tập số có
tổng lớn nhất sao cho trong $N$ số liên
tiếp bất kì có không quá $K$ số được chọn.</p>
<h4 id="Gioi-han-4"><a href="#Gioi-han-4" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 200$, $1 \le K \le 10$, $1
\le A[i] \le 10^6$</p>
<h2 id="Party1-anh-Khue"><a href="#Party1-anh-Khue" class="headerlink" title="Party1 (anh Khuê)"></a>Party1 (anh Khuê)</h2><p>Cho $N$ bạn nam và $M$ bạn nữ, và $K$ mối
quan hệ nam - nữ. Liệt kê tất cả bạn nam
và bạn nữ chắc chắn sẽ xuất hiện trong
cặp ghép cực đại.</p>
<h4 id="Gioi-han-5"><a href="#Gioi-han-5" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N, M \le 10^4$, $1 \le K \le 10^5$.</p>
<h2 id="Party2-anh-Khue"><a href="#Party2-anh-Khue" class="headerlink" title="Party2 (anh Khuê)"></a>Party2 (anh Khuê)</h2><p>Cho đồ thị $N$ đỉnh $M$ cạnh xanh $K$ cạnh
đỏ, đỉnh $i$ có trọng số $A[i]$.
Chọn một tập điểm có tổng trọng số lớn nhất
thỏa mãn:</p>
<ul>
<li>2 đỉnh có cạnh xanh nối giữa thì không
được cùng chọn.</li>
<li>2 đỉnh có cạnh đỏ nối giữa thì cùng
được chọn, hoặc cùng không được chọn.</li>
</ul>
<p>Đồng thời, đếm số cách chọn tối ưu.</p>
<h4 id="Gioi-han-6"><a href="#Gioi-han-6" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 250$, $0 \le M \le
\frac{N(N-1)}{6}$,
$\frac{N(N-1)}{3} \le K \le
\frac{N(N-1)}{2}$</p>
<h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="Chuyen-doi-bai-toan"><a href="#Chuyen-doi-bai-toan" class="headerlink" title="Chuyển đổi bài toán"></a>Chuyển đổi bài toán</h3><p>Rất khó quản lí trạng thái thắng thua khi
bài toán yêu cầu so sánh số lượng. Vì vậy,
ta sẽ biến đổi bài toán một chút - mặc dù
tính chất thắng - thua không thay đổi.</p>
<p>Thay vì so sánh số lượng <code>d</code> của từng người,
ta lấy số lượng <code>d</code> của người đi trước trừ
đi người đi sau. Hiển nhiên người đi trước
muốn hiệu dương - tức <em>đối đa hóa</em> nó, và
người đi sau muốn tối thiểu hóa nó.</p>
<p>Bởi vì đây là trò chơi hữu hạn bước, và
2 người đều phải chơi tối ưu, nên ta sẽ
chỉ đi tìm một kết quả duy nhất: hiệu tối ưu
của trò chơi, với mỗi cách chọn bước đầu.</p>
<h3 id="Quy-hoach-dong"><a href="#Quy-hoach-dong" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Gọi $f[l][r]$ là hiệu tối ưu của trò chơi,
nếu trò chơi bắt đầu với trạng thái đoạn
$l..r$ bị khuyết. Ta có:</p>
<ul>
<li>Hiển nhiên $f[l][r] = 0$ nếu $l..r$ đã
phủ toàn bộ vòng tròn.</li>
<li>Ta có thể hiểu độ dài $l..r$ sẽ tương
đương với số bước đã xảy ra, vì vậy ta có
thể biết được lượt đi tiếp theo là của ai.</li>
<li>Nếu đây là lượt của người đi trước, hẳn
hắn ta sẽ muốn $f[l][r]$ lớn nhất có thể,
tức hắn sẽ chọn vị trí $l - 1$ hay $r + 1$
sao cho $f[l - 1][r]$ hoặc $f[l][r + 1]$,
cộng vị trí hắn chọn nếu nó màu đỏ,
sao cho tổng ấy lớn nhất có thể. Nói
cách khác ta có:
$$ f[l][r] = \max(f[l - 1][r] +
(\text{S[l - 1] == ‘d’}), f[l][r + 1] +
(\text{S[r + 1] == ‘d’}))$$</li>
<li>Ngược lại, người đi sau sẽ muốn lựa
chọn của mình là nhỏ nhất có thể, tức:
$$ f[l][r] = \min(f[l - 1][r] -
(\text{S[l - 1] == ‘d’}), f[l][r + 1] -
(\text{S[r + 1] == ‘d’}))$$
Lưu ý dấu <code>-</code>, bởi ta đang tối ưu hiệu
người đi trước trừ người đi sau.</li>
</ul>
<p>Ta có thể tính tất cả các hàm $f[1][1]$,
$f[2][2]$, …, $f[N][N]$ trong độ phức
tạp $O(N^2)$.</p>
<h3 id="Dem-vi-tri-tot"><a href="#Dem-vi-tri-tot" class="headerlink" title="Đếm vị trí tốt"></a>Đếm vị trí tốt</h3><p>Một vị trí $i$ thỏa mãn đầu bài nếu như
hiệu tối ưu lớn hơn $0$, bởi khi đó người
thứ nhất luôn có thể làm cho mình có nhiều
<code>d</code> hơn. Như vậy, ta chỉ cần thử hết các
vị trí $i$ và kiểm tra xem $f[i][i] &gt; 0$
đúng không.</p>
<p>Tổng độ phức tạp của bài toán là $O(N^2)$.</p>
<h2 id="eureka"><a href="#eureka" class="headerlink" title="eureka"></a>eureka</h2><h3 id="Tinh-chat-cua-tong-trong-luong"><a href="#Tinh-chat-cua-tong-trong-luong" class="headerlink" title="Tính chất của tổng trọng lượng"></a>Tính chất của tổng trọng lượng</h3><p>Xét một hệ thống cân, không khó để chứng
minh tổng trọng lượng của nó phải là
một bội của số $X$ tương ứng với từng
hệ thống.</p>
<p>Nhiệm vụ của ta là đi tìm $X$ đó cho cả hệ
thống lớn, bằng cách tính từ các hệ thống
con.</p>
<h3 id="Quy-nap"><a href="#Quy-nap" class="headerlink" title="Quy nạp"></a>Quy nạp</h3><p>Hiển nhiên quả cân có thể nhận trọng lượng
bất kì, vậy quả cân là hệ thống cân có $X$
là 1.</p>
<p>Ta xét hệ thống cân $a, b, X_l, X_r$ trong
đó $X_l, X_r$ là các giá trị mình đã tính
trước đó cho hệ thống cân bên trái và phải.
Ta có:</p>
<ul>
<li>Tồn tại $(p, q) = 1$ sao cho $paX_l =
qbX_r$. Hiển nhiên đây là $p$ và $q$ có
tổng nhỏ nhất thỏa mãn.</li>
<li>Khi đó, $X = pX_l + qX_r$.</li>
</ul>
<p>Ta có thể nhận thấy $\frac{p}{q} =
\frac{bX_r}{aX_l}$, vậy $p = bX_r / d$ và
$q = aX_l / d$ với $d = \gcd(aX_l, bX_r)$.
Như vậy $X = \dfrac{X_l X_r(a + b)}{d}$.</p>
<h3 id="So-lon"><a href="#So-lon" class="headerlink" title="Số lớn"></a>Số lớn</h3><p>Ta nhận thấy từ công thức trên rằng
đáp số có thể rất lớn. Ta không cần phải in
số lớn, tuy vậy các phép tính như $\gcd$
không thể được tính khi số đã bị mod.</p>
<p>Tuy nhiên ta cũng không cần phải cài số
lớn: Mỗi lần ta nhân thêm một số $a + b
\le 200$, nên thay vì lưu số lớn ta sẽ
lưu tập ước nguyên tố và số mũ. Khi đó,
các phép nhân (cộng số mũ), chia (trừ
số mũ), lấy $\gcd$ (lấy min số mũ) trở
nên đơn giản, với độ phức tạp $O(A[i])$.</p>
<p>Ta có thuật toán đáp số với độ phức tạp
$O(N * A[i])$.</p>
<h3 id="Cai-dat"><a href="#Cai-dat" class="headerlink" title="Cài đặt"></a>Cài đặt</h3><p>Một cách cài đặt ngắn gọn là sử dụng
đệ quy, vừa đọc vừa làm.
Ta thực hiện lần lượt:</p>
<ul>
<li>Đọc $a$ và kiểm tra xem có phải quả cân
không. Nếu có trả về 1.</li>
<li>Đọc $b$.</li>
<li>Đệ quy giải bên trái $X_l$.</li>
<li>Đệ quy giải bên phải $X_r$.</li>
<li>Tính và trả về $X$.</li>
</ul>
<h2 id="liondance"><a href="#liondance" class="headerlink" title="liondance"></a>liondance</h2><h3 id="Quy-hoach-dong-1"><a href="#Quy-hoach-dong-1" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Về cơ bản, đây chỉ là bài toán LCS có thêm
điều kiện, vì vậy hướng suy nghĩ của ta
tất nhiên là cải thiện thuật toán quy hoạch
động LCS, vì độ phức tạp yêu cầu cũng tương
đương.</p>
<p>Vậy làm sao để quản lí trạng thái vẫn là
$[i][j]$ khi ta còn cần thông tin về 2 phần
tử liên tiếp? Ta sẽ cần “gói” nhiều thông
tin hơn vào trạng thái $(i, j)$.</p>
<h3 id="Them-thong-tin"><a href="#Them-thong-tin" class="headerlink" title="Thêm thông tin!"></a>Thêm thông tin!</h3><p>Ta sẽ định nghĩa hàm quy hoạch động như sau:
Gọi $f[i][j]$ là dãy con chung dài nhất
khi sử dụng đoạn $A[i..N]$, đoạn $B[i + 1..N]$
<strong>và $B[j]$ là phần tử cuối cùng được thêm
ở đầu đoạn</strong> (để đơn giản, ta không tính
cặp $B[j]$ - ?? vào đáp số, cũng như coi $
B[0]$ là phần tử có thể ghép với mọi thứ).</p>
<h4 id="Tai-sao-lai-dinh-nghia-nhu-vay"><a href="#Tai-sao-lai-dinh-nghia-nhu-vay" class="headerlink" title="Tại sao lại định nghĩa như vậy?"></a>Tại sao lại định nghĩa như vậy?</h4><p>Nhờ có việc đánh dấu $B[j]$ là số được thêm
vào cuối cùng, ta có thể quản lí giá trị
có thể thêm vào tiếp theo.
Khi có $f[i][j]$, và $A[i] = B[k]$ ($k \ge
j + 1$), điều kiện duy nhất đẻ kiểm tra
chỉ là $|B[j] - B[k]| \le d$.</p>
<h4 id="Tai-sao-lai-tu-cuoi"><a href="#Tai-sao-lai-tu-cuoi" class="headerlink" title="Tại sao lại từ cuối?"></a>Tại sao lại từ cuối?</h4><p>Để giúp cho việc truy vết thứ tự từ điển,
sau này mình sẽ nói đến.</p>
<p>Ta có thể tính hàm quy hoạch động này như
sau - $f[i][j]$ có thể được tính từ các trạng
thái:</p>
<ul>
<li>$f[i + 1][j]$, hiển nhiên</li>
<li>$f[i + 1][k] + 1$, với $k \ge j + 1$ và
$A[i] = B[k]$.</li>
</ul>
<p>Độ phức tạp là $O(N^3)$. Ta sẽ cần một chút
quan sát để hạ độ phức tạp.</p>
<h3 id="Nhay-xuong-O-N-2"><a href="#Nhay-xuong-O-N-2" class="headerlink" title="Nhảy xuống $O(N^2)$"></a>Nhảy xuống $O(N^2)$</h3><p>Khi xét $f[i][j]$, ta có thể thấy nếu
$k \le k’$ và $A[i] = B[k] = B[k’]$ thì
$f[i + 1][k] \ge f[i + 1][k’]$. Chứng minh
rất đơn giản: $B[k + 1..N]$ dài hơn
$B[k’ + 1..N]$, mà điều kiện ghép không đổi.</p>
<p>Vì vậy, thực chất ta chỉ cần tìm $k$ nhỏ
nhất thỏa mãn $k \ge j + 1$ và $A[i] = B[k]$
để cập nhật vào $f[i][j]$. Việc này có thể
thực hiện bằng việc đánh dấu khi for ngược
$i$ và $j$, nên độ phức tạp chỉ còn $O(N^2)$.</p>
<h3 id="Thu-tu-tu-dien"><a href="#Thu-tu-tu-dien" class="headerlink" title="Thứ tự từ điển"></a>Thứ tự từ điển</h3><p>Khi quy hoạch động $f[i][j]$, ta sẽ lưu thêm
$nx[i][j]$ là chỉ số $B[k]$ mà mình chọn làm
kí tự tiếp theo. Do điều kiện của dãy đáp số
là phụ thuộc vào <em>giá trị</em> chứ không phải
chỉ số, ta sẽ phải thêm vào các điều kiện sau
đây để đảm bảo lựa chọn chỉ số tiếp theo cho
truy vết:</p>
<ul>
<li>Hiển nhiên nếu $f[i + 1][j] \neq f[i + 1][k]$
thì ta chọn cái nào lớn hơn, vì được dãy dài
hơn.</li>
<li>Nếu bằng nhau, hiển nhiên trong $B[nx[i + 1][j]]$
và $B[k]$ cái nào lớn hơn ta chọn.</li>
<li>Nếu vẫn bằng nhau, ta nhận thấy chắc chắn
$nx[i + 1][j] \ge k$, do vậy từ $(i + 1, k)$
ta có nhiều lựa chọn hơn (và có tất cả lựa
chọn của) $(i + 1, nx[i + 1][j])$, nên ta
sẽ chọn $(i + 1, k)$.</li>
</ul>
<p>Khi đã có mảng $nx[i][j]$, việc truy vết trở
thành đơn giản.</p>
<h2 id="desert"><a href="#desert" class="headerlink" title="desert"></a>desert</h2><h3 id="Cay-khung-Manhattan"><a href="#Cay-khung-Manhattan" class="headerlink" title="Cây khung Manhattan"></a>Cây khung Manhattan</h3><p>Bản chất của việc dựng đường đi sao cho
cạnh $\max$ là $\min$ chính là dựng cây khung
nhỏ nhất của đồ thị.</p>
<p>Từ việc chăm chỉ đọc wiki, ta cũng biết có
thể dựng lên cây khung giữa các đỉnh theo
khoảng cách Manhattan với độ phức tạp
$O(N \log N)$. Thực chất đây chỉ là bài
yêu cầu implement thuật toán đó.</p>
<h3 id="Dung-cay-khung-nhu-nao"><a href="#Dung-cay-khung-nhu-nao" class="headerlink" title="Dựng cây khung như nào?"></a>Dựng cây khung như nào?</h3><p>Ta có thể <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/line-sweep-algorithms/" target="_blank" rel="external">chứng minh</a>
rằng, để dựng cây khung Manhattan, với mỗi
điểm ta chỉ cần nối cạnh đến đỉnh gần nó nhất
trong mỗi <a href="https://www.wikiwand.com/en/Octant_(plane_geometry" target="_blank" rel="external">góc phần tám</a>).
Vậy tìm chúng như thế nào?</p>
<h4 id="Tim-diem-gan-nhat-trong-goc-phan-tam"><a href="#Tim-diem-gan-nhat-trong-goc-phan-tam" class="headerlink" title="Tìm điểm gần nhất trong góc phần tám"></a>Tìm điểm gần nhất trong góc phần tám</h4><p>Giả sử ta sẽ giải bài toán cho góc phần tám
có $X \le X_0$, $Y \le Y_0$ và $X - Y \le X_0 - Y_0$.</p>
<p>Ta sắp xếp các điểm theo thứ tự $X_i - Y_i$
giảm dần, và thêm vào một IT có tọa độ được
xếp theo $X_i$ giá trị $X_i + Y_i$ lấy $\max$.</p>
<p>Với mỗi điểm, ta <code>get</code> trong IT giá trị
$X_j + Y_j$ lớn nhất với $X_j \le X_i$, rồi
cập nhật điểm đó vào IT. Điểm <code>get</code> ra
sẽ là điểm gần nhất theo góc phần tám này.</p>
<p>Để hiểu tại sao sắp xếp như vậy lại đúng,
xem hình dưới.</p>
<p><img src="/images/desert_tree_upd.png" alt="Phần được gọi khi xét điểm $A$. Phần
tô màu đã được thêm vào IT, phần màu xanh
thể hiện phần được get trong IT"></p>
<p>Dễ dàng làm với góc phần tám đối diện, chỉ
cần for tập điểm ngược lại.</p>
<h4 id="Giai-nhanh-tat-ca-cac-phan"><a href="#Giai-nhanh-tat-ca-cac-phan" class="headerlink" title="Giải nhanh tất cả các phần"></a>Giải nhanh tất cả các phần</h4><p>Thay vì cài tất cả các trường hợp góc phần
tám, ta có thể chỉ cần giải 2 góc đối diện
như trên, rồi thực hiện <a href="https://quizlet.com/6704360/rotation-rules-for-mrs-nelsons-geometry-flash-cards/" target="_blank" rel="external">phép quay 90 độ</a>
cho tất cả các điểm theo gốc, và tiếp tục giải.</p>
<p>Hiển nhiên sau khi xoay 3 lần ta sẽ giải đủ 8
góc phần tám.</p>
<h2 id="Tron-viec"><a href="#Tron-viec" class="headerlink" title="Trốn việc"></a>Trốn việc</h2><h3 id="Lien-tuong"><a href="#Lien-tuong" class="headerlink" title="Liên tưởng"></a>Liên tưởng</h3><p>Trong một hệ thống $N$ máy song song, ta phải
đảm bảo trong khoảng thời gian $M$ bất kì
không có quá $N$ thao tác được thực hiện trên
bất cứ máy nào.
Ta sẽ làm như nào?</p>
<p>Một cách đơn giản là ra lệnh cho một máy,
sau khi thực hiện một thao tác, sẽ ngủ trong
$M$ giây. Như vậy, không có khoảng thời gian
$M$ nào có một máy chạy 2 lần, vì thế không
có chuyện có nhiều hơn $N$ thao tác được chạy.</p>
<p>Ta sẽ sử dụng ý tưởng này cho bài toán.</p>
<h3 id="Bien-doi-bai-toan"><a href="#Bien-doi-bai-toan" class="headerlink" title="Biến đổi bài toán"></a>Biến đổi bài toán</h3><p>Đề bài yêu cầu ta chọn một tập lớn nhất sao
cho cứ $N$ phần tử liên tiếp bất kì có không
quá $K$ phần tử được chọn. Ta sẽ biến bài
toán thành: Cho phép chạy $K$ máy lựa chọn
song song, mỗi phần tử chỉ được cho một máy
lựa chọn, trong khoảng $N$ bất kì không
có máy nào chọn liên tiếp 2 phần tử.</p>
<p>Nếu $K = 1$, ta có thể sử dụng quy hoạch động
$f[i] = \max(f[i - 1], f[i - N] + A[i])$. Với
$K$ lớn hơn, ta sẽ phải tìm cách khác để đảm
bảo mỗi phần tử chỉ được tối đa một máy lựa chọn.</p>
<p>Hãy tưởng tượng một đường ống $3N + 1$ đoạn liên
tiếp nối thành một đường thẳng. Ngoài ra
đường ống thứ $i$ còn được nối với $\min(
i + N, 3N + 1)$. Từ đỉnh 1 ta cho $K$ robot
chạy về hướng $3N + 1$. Các robot có thể
đi đường $i$ - $i + 1$ thoải mái, nhưng
mỗi đường đi $i$ - $i + N$ chỉ có thể cho
1 robot đi qua, đồng thời sẽ thu về $A[i]$
đồng tiền. Ta cần thu về nhiều tiền nhất
có thể.</p>
<p>Nghe rất giống một bài luồng max cost.</p>
<h3 id="Dung-luong"><a href="#Dung-luong" class="headerlink" title="Dựng luồng"></a>Dựng luồng</h3><p>Ta áp dụng toàn bộ ý tưởng của đường ống vào
luồng.</p>
<ul>
<li>$3N + 2$ đỉnh, $0$ là nguồn $3N + 1$ là đích.</li>
<li>$0$ =&gt; $1$: cap = $K$, cost = $0$</li>
<li>Với $i &gt; 0$, $i$ =&gt; $i + 1$: cap = $inf$, cost = $0$</li>
<li>Với $i &gt; 0$, $i$ =&gt; $\min(i + N, 3N + 1)$: cap = $1$, cost = $A[i]$</li>
</ul>
<p>Trên mạng, ta tìm luồng max cost. Hiển nhiên
luồng cực đại là $K$, nhưng ta chỉ cần quan
tâm đến cost tối đa. Cost chính là đáp số.</p>
<p>Độ phức tạp là <code>O(luồng 600 đỉnh 1000 cạnh)</code>.</p>
<h2 id="Party1"><a href="#Party1" class="headerlink" title="Party1"></a>Party1</h2><h3 id="Thay-doi-muc-tieu"><a href="#Thay-doi-muc-tieu" class="headerlink" title="Thay đổi mục tiêu"></a>Thay đổi mục tiêu</h3><p>Thay vì đi tìm những đỉnh mà xuất hiện trong
mọi cặp ghép cực đại, ta sẽ tìm những đỉnh
không có tính chất đó. Thật vậy, ta sẽ cần
tìm những đỉnh mà khi bỏ nó đi, kích cỡ cặp ghép
cực đại vẫn không thay đổi.</p>
<h3 id="Tinh-chat-cua-cap-ghep"><a href="#Tinh-chat-cua-cap-ghep" class="headerlink" title="Tính chất của cặp ghép"></a>Tính chất của cặp ghép</h3><p>Đầu tiên, ta dựng cặp ghép cực đại trên đồ thị
đã cho. Hiển nhiên các đỉnh không thuộc cặp
ghép là các đỉnh cần tìm. Ta sẽ chỉ xét đến
các đỉnh thuộc cặp ghép.</p>
<p>Giả sử $v_0$ là một đỉnh không được ghép.
Xét đường tăng $v_0, v_1,…, v_{2k}$. Hiển
nhiên độ dài đường tăng phải chẵn, nếu không
ta có thể tăng số cặp ghép, không thỏa mãn
tính chất cặp ghép cực đại.</p>
<p>Ta nhận thấy, nếu xóa đi 1 trong các đỉnh
$v_2, v_4, …,v_{2k}$, ta sẽ tách đường tăng
hiện tại ra thành 1 đường tăng lẻ, đồng thời số cặp ghép giảm đi 1.
Tuy nhiến, do tồn tại đường tăng lẻ nên ta
có thể đảo lại, làm tăng số cặp ghép về như
cũ. Vì vậy $v_2, v_4, …, v_{2k}$ đều là
các đỉnh cần tìm.</p>
<p>Nếu một đỉnh $x$ khi xóa đi không tạo ra
đường tăng lẻ nào (nhưng làm giảm số cặp ghép),
chắc chắn nó không phải đỉnh cần tìm.</p>
<p><img src="/images/party1_exp.png" alt="Các cạnh xanh là cạnh cặp ghép. Xét
đường tăng DHCGBFA (tím xanh), nếu bỏ B, đường tăng
DHCG sẽ là đường lẻ, tăng cặp ghép về như cũ.
Tương tự với C và A. Đường tăng JEI (xanh dương-xanh) cũng vậy."></p>
<h3 id="Thuat-toan"><a href="#Thuat-toan" class="headerlink" title="Thuật toán"></a>Thuật toán</h3><p>Trước tiên, tìm cặp ghép. Sau đó, ta BFS từ các
đỉnh không được cặp ghép, đi theo các đường tăng,
đánh dấu các đỉnh cùng phía được thăm.</p>
<p>Do tính chất của đồ thị 2 phía nên ta chỉ cần 2
lần BFS, mỗi lần xuất phát từ tất cả các đính
không được thăm trên cùng 1 phía.</p>
<p>Độ phức tạp sẽ là $O(K \sqrt{N + M})$ do cặp
ghép.</p>
<h2 id="Party2"><a href="#Party2" class="headerlink" title="Party2"></a>Party2</h2><h3 id="Nen-do-thi"><a href="#Nen-do-thi" class="headerlink" title="Nén đồ thị"></a>Nén đồ thị</h3><p>Với tập đỉnh đỏ, ta sẽ gộp tất cả các đỉnh liên
thông lại thành một, cộng tất cả các trọng số lại.
Bài toán trở thành tìm tập độc lập cực đại trên
đồ thị cạnh xanh.</p>
<p>Đây là một bài <strong>NP-Hard</strong>, chưa thể giải với
giới hạn $N \le 250$.</p>
<h3 id="So-luong-dinh"><a href="#So-luong-dinh" class="headerlink" title="Số lượng đỉnh"></a>Số lượng đỉnh</h3><p>Một chi tiết quan trọng là số lượng cạnh đỏ
rất lớn. Với $N = 250$ và $K = \frac{N(N-1)}{3}$,
chỉ có tối đa $46$ đỉnh đã gộp (bao gồm 205
đỉnh có clique và 45 đỉnh bậc 0).</p>
<p>Từ đây, ta có chút hi vọng với thuật backtrack.</p>
<h3 id="Dat-can"><a href="#Dat-can" class="headerlink" title="Đặt cận!"></a>Đặt cận!</h3><p>Đây là danh sách cận cần thiết để hi vọng qua
được đống test(?):</p>
<ul>
<li>Sort các đỉnh theo bậc rồi backtrack dần</li>
<li>Xử lí nhanh các đỉnh bị cấm</li>
<li>Loại bỏ các trường hợp khi tổng các đỉnh còn
lại không lớn hơn max hiện tại</li>
<li>Tính riêng các tplt rồi nhân với nhau</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hôm nay có hai phần: bài thầy Hoàng và bài
anh Khuê.
Cả 2 đều cần một sự tay to nhất định.&lt;/p&gt;
&lt;h1 id=&quot;Tom-tat-de-bai&quot;&gt;&lt;a href=&quot;#Tom-tat-
    
    </summary>
    
      <category term="Training" scheme="http://natsukagami.github.io/categories/Training/"/>
    
    
      <category term="training" scheme="http://natsukagami.github.io/tags/training/"/>
    
      <category term="apio" scheme="http://natsukagami.github.io/tags/apio/"/>
    
      <category term="vietnamese" scheme="http://natsukagami.github.io/tags/vietnamese/"/>
    
      <category term="thầy Hoàng" scheme="http://natsukagami.github.io/tags/thay-Hoang/"/>
    
      <category term="anh Khuê" scheme="http://natsukagami.github.io/tags/anh-Khue/"/>
    
  </entry>
  
  <entry>
    <title>2017/04/25 Training</title>
    <link href="http://natsukagami.github.io/2017/04/25/2017-04-25-Training/"/>
    <id>http://natsukagami.github.io/2017/04/25/2017-04-25-Training/</id>
    <published>2017-04-25T13:00:00.000Z</published>
    <updated>2017-04-26T17:17:54.066Z</updated>
    
    <content type="html"><![CDATA[<p>Hôm nay có khá nhiều bài trí tuệ.</p>
<h1 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h1><h2 id="wash"><a href="#wash" class="headerlink" title="wash"></a>wash</h2><p>Cho $N$ máy giặt và $M$ máy sấy chạy song song,
thời gian giặt là $A[1..N]$, sấy là $B[1..M]$ cho
từng máy. Tìm thời gian nhỏ nhất để giặt xong
$L$ quần áo.</p>
<h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N, M \le 10^5$, $1 \le L \le 10^6$,
$1 \le A[i], B[i] \le 10^9$.</p>
<h2 id="mars"><a href="#mars" class="headerlink" title="mars"></a>mars</h2><p>Cho $N$ nhà kho với sức chứa $C[1..N]$, ban
đầu các nhà kho rỗng. Trong ngày thứ $i$
($1 \le i \le D$), nhà kho $j$ nhận thêm
$A[i][j]$ món hàng, đồng thời bạn được chuyển
tổng cộng $d[i]$ món hàng ra khỏi các nhà kho.
Việc chuyển ra được thực hiện sau khi nhận
hàng. Hỏi sau $N$ ngày liệu có thể chuyển
tất cả hàng hóa đã nhận không?</p>
<h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N, D \le 30$,
$1 \le C[i], A[i][j], d[i] \le 10^6$</p>
<h2 id="government"><a href="#government" class="headerlink" title="government"></a>government</h2><p>Cho $N$ điểm, điểm $i$ có trọng số $A[i]$.
Tìm cách đặt các điểm vào các tọa độ nguyên
của đoạn thẳng $[1..M]$ (mỗi tọa độ chứa
không quá 1 điểm) để tối đa hóa:
$$\sum\limits_{i = 1}^N \sum\limits_{j = i + 1}
^N |x_i - x_j| \times A[i] \times A[j]$$</p>
<p>Với $x_i$ là tọa độ điểm $i$.</p>
<h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le M \le 10^6$, $1 \le N \le 1000$,
$1 \le A[i] \le 100$.</p>
<h2 id="permutation"><a href="#permutation" class="headerlink" title="permutation"></a>permutation</h2><p>Xét một hoán vị $P$, gọi $R[i]$ là bán kính của
$P_i$ nếu $R[i]$ là số lớn nhất thỏa mãn:</p>
<ul>
<li>$1 \le i - R[i]$ và $i + R[i] \le N$</li>
<li>$P_j &lt; P_i$ với mọi $i - R[i] \le j &lt; i$</li>
<li>$P_j &lt; P_i$ với mọi $i &lt; j \le i + R[i]$</li>
</ul>
<p>Cho số $N$ và dãy $R[1..N]$, đếm số hoán vị
$P$ độ dài $N$ có bán kính của $P_i$ là $R[i]$
với mọi $1 \le i \le N$.</p>
<h4 id="Gioi-han-3"><a href="#Gioi-han-3" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 1000$.</p>
<h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="wash-1"><a href="#wash-1" class="headerlink" title="wash"></a>wash</h2><h3 id="Tham-lam-tren-mot-may"><a href="#Tham-lam-tren-mot-may" class="headerlink" title="Tham lam trên một máy"></a>Tham lam trên một máy</h3><p>Giả sử bài toán chỉ có một loại máy (máy giặt
chẳng hạn, phơi thôi sấy làm gì tốn điện), ta
có thể sử dụng thuật toán tham lam: Với mỗi
bước ta chọn máy giặt mà có <strong>thời điểm hoàn
thành đồ tiếp theo</strong> (không phải đồ máy đó
đang giặt - nếu có) là nhỏ nhất.</p>
<p>Không khó để chứng minh thuật toán này là tối
ưu. Việc cài đặt cũng không khó khăn, chỉ
cần sử dụng 1 <code>priority_queue</code>.</p>
<p>Độ phức tạp là $O(L \log N)$.</p>
<p>Mạnh hơn thế, thuật toán này cho ta không
chỉ đáp án tối ưu, mà từng phần tử cũng tối
ưu: <strong>Không thể giặt đồ thứ $i$ xong
trước thời điểm $T[i]$.</strong></p>
<h3 id="Chat-nhi-phan-ket-qua"><a href="#Chat-nhi-phan-ket-qua" class="headerlink" title="Chặt nhị phân kết quả"></a>Chặt nhị phân kết quả</h3><p>Theo tính chất bài toán, ta có thể chặt nhị
phân kết quả. Bài toán trở thành kiểm tra,
liệu trong thời gian $X$ có thể giặt và
sấy $L$ quần áo không?</p>
<p>Để kiểm tra, đầu tiên ta sẽ tham lam theo thuật
toán trên để có tập thời gian giặt xong của
từng đồ, $T[i]$.</p>
<p>Sau đó, ta “lật ngược” trục trời gian lại,
xuất phát từ thời điểm $L$ và thực hiện tính
tập thời gian sấy $V[i]$, <em>cũng bằng thuật
tham lam trên</em>. Tại sao thuật tham lam vẫn
đúng? Tại vì, với mỗi máy, ta chỉ cần đảo
ngược thứ tự sấy các đồ của máy đó là tổng
thời gian vẫn không đổi, các đồ được sấy
đúng thứ tự xuôi trục thời gian.</p>
<p>Việc cuối cùng là dựng lên cặp ghép $T[i]$ - $V[i]$
sao cho $i$ ghép với $j$ thì $T[i] + V[j] &lt; X$.
Ta có thể tưởng tượng là giặt mất $T[i]$,
đợi đến $X - V[j]$ rồi sấy mất $V[j]$.</p>
<p>Hiển nhiên cách ghép tối ưu nhất là ghép $T[i]$
nhỏ nhất với $V[j]$ lớn nhất, nhỏ nhì với lớn
nhì và vân vân…</p>
<p>Ta có thuật toán $O(L \log N \log 10^{15})$,
chưa đủ mạnh.</p>
<h3 id="Khu-chat-nhi-phan"><a href="#Khu-chat-nhi-phan" class="headerlink" title="Khử chặt nhị phân"></a>Khử chặt nhị phân</h3><p>Ta nhận thấy việc tính mảng $T[i]$ và $V[i]$
không liên quan đến việc chặt nhị phân, vì
thế thực chất việc chặt nhị phân của ta
chỉ là tìm giá trị max của việc ghép cặp.</p>
<p>Như vậy, không cần chặt nhị phân, ta chỉ
cần tìm 2 mảng trên, thực hiện ghép cặp
rồi tìm giá trị max.</p>
<p>Độ phức tạp là $O(L \log N)$.</p>
<h2 id="mars-1"><a href="#mars-1" class="headerlink" title="mars"></a>mars</h2><h3 id="Luong"><a href="#Luong" class="headerlink" title="Luồng"></a>Luồng</h3><p>Ta có thể để ý, đề bài gồm một số đầu vào,
một số đầu ra và yêu cầu kiểm tra xem
có thể truyền từ đầu vào sang đầu ra không.
Đây chính là đặc điểm của bài toán luồng
cực đại - vì thế đây là bài luồng cơ bản.</p>
<p>Ngoài ra, giới hạn nhỏ của đề bài cũng
ủng hộ ý tưởng luồng.</p>
<h3 id="Dung-luong-nhu-the-nao"><a href="#Dung-luong-nhu-the-nao" class="headerlink" title="Dựng luồng như thế nào?"></a>Dựng luồng như thế nào?</h3><ul>
<li>Với mỗi ngày ta chỉ có thể giữ lại $C_i$
đơn vị ở nhà kho $i$ =&gt; Ta sẽ cần phải
dựng đỉnh quản lí $V[i][j]$ quản lí nhà
kho $i$ trong ngày $j$, từ $V[i][j]$ đi
đến $V[i][j + 1]$ với capacity $C_i$.</li>
<li>Trong ngày $i$ chỉ được chuyển $D_i$
đơn vị =&gt; Ta dựng đỉnh $Q[i]$ quản lí
lượng chuyển ra trong ngày $i$. Từ $Q[i]$
đến đích có capacity $D_i$, từ các
$V[i][j]$ đến $Q[j]$ có capacity vô tận.</li>
<li>Kho $j$ ngày $i$ tăng thêm $A[i][j]$ đơn
vị =&gt; từ nguồn vào $V[i][j]$ có capacity
$A[i][j]$.</li>
<li>Chuyển vào trước khi chuyển ra:
để xử lí phần này ta cần tách $V[i][j]$
thành $V_in[i][j]$ và $V_out[i][j]$,
từ $V_out[i][j - 1]$ vào $V_in[i][j]$
như trên, $V_out[i][j]$ vào $Q[j]$ như
trên và $V_in[i][j]$ vào $V_out[i][j]$
có capacity $C_i$.</li>
</ul>
<p>Sau đó ta tìm luồng cực đại và kiểm tra
nó có bằng tổng $A[i][j]$ không.</p>
<p>Độ phức tạp là <code>O(luồng 2000 đỉnh 2000 cạnh)</code>.</p>
<h2 id="government-1"><a href="#government-1" class="headerlink" title="government"></a>government</h2><h3 id="Bien-doi-cong-thuc"><a href="#Bien-doi-cong-thuc" class="headerlink" title="Biến đổi công thức"></a>Biến đổi công thức</h3><p>Ta có thể hiểu công thức chính là khoảng cách
có trọng số của từng cặp. Sử dụng công thức
này có điểm bất lợi là có quá nhiều biến.
Ta sẽ biến đổi công thức một chút.</p>
<p>Giả sử các điểm $1..N$ đã được xếp từ trái
sang phải, đáp số sẽ là
$$ \sum\limits_{i = 1}^{N - 1}(x_{i + 1} - x_i)
(\sum\limits_{j = 1}^i A[j])
(\sum\limits_{k = i + 1}^N A[k])$$</p>
<p>Với mỗi đoạn liên tiếp, số lần nó bị tính
vào đáp số sẽ là tổng trọng số những điểm
bến trái nó nhân với tổng trọng số những
điểm bên phải.</p>
<h3 id="Don-ve-2-ben"><a href="#Don-ve-2-ben" class="headerlink" title="Dồn về 2 bên"></a>Dồn về 2 bên</h3><p>Giả sử ta đã có thứ tự các số $A[i]$, vậy
đặt chúng vào đâu thì hợp lí nhất?</p>
<p>Dựa theo công thức phía trên, ta có: </p>
<ul>
<li>Tổng các $(x_{i + 1} - x_i)$ không quá $M$.
Vì ta cần tối đa hóa nên ta coi tổng là
$M$ luôn.</li>
<li>Vị trí có phần tích $A[i]$ lớn nhất là
khi tổng bên trái và bên phải gần nhau nhất.
Gọi vị trí này là $(x_{l + 1} - x_l)$.</li>
</ul>
<p>Từ đây ta suy ra luôn có thể tối đa hóa đáp
án bằng cách tối đa hóa đoạn $l$, tức cho
$(x_{l + 1} - x_l) = M - N + 1$ và các đoạn
còn lại là 1. Nói cách khác, ta sẽ dồn tập
điểm về 2 bên sao cho tổng trọng số của
chúng gần nhau nhất, tức $l$ lớn nhất
thỏa mãn tổng $A[1..l - 1]$ bé hơn nửa tổng.</p>
<h3 id="Thu-tu-cua-tung-ben"><a href="#Thu-tu-cua-tung-ben" class="headerlink" title="Thứ tự của từng bên"></a>Thứ tự của từng bên</h3><p>Giả sử ta biết tập con của từng bên, làm
sao để tìm thứ tự sắp xếp của chúng?</p>
<p>Xét tập bên trái $A[1..k]$.
Dễ dàng nhìn
thấy phần đáp số của các đoạn trong tập
chính là
$$A[1] \times (S - A[1]) +
(A[1] + A[2]) \times (S - A[1] - A[2]) + … +
(A[1] + … + A[k - 1]) \times (S + A[k])$$</p>
<p>Ta nhận thấy $A[1]$, $A[1] + A[2]$, …
đều sẽ nhỏ hơn số hạng còn lại tương ứng
(theo nhận xét phía trên), vì vậy để
tổng các tích này max, thì $A[1]$, $A[1] + A[2]$,
…, $A[1] + … + A[k - 1]$ đều phải
lớn nhất có thể. Vậy dãy $A[1..K]$ phải được
sắp xếp giảm dần.</p>
<p>Tương tự ta sẽ chứng minh được dãy bên phải
phải được sắp xếp <strong>tăng</strong> dần.</p>
<h3 id="Quy-hoach-dong"><a href="#Quy-hoach-dong" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Khi đã biết sắp xếp các phần tử, ta đã có
thứ tự quy hoạch động: ta sẽ thêm dần các
phần tử vào bên trái hoặc bên phải, theo
thứ tự $A[i]$ giảm dần.</p>
<p>Để có thể vận dụng công thức tính phần giữa,
trong hàm qhđ ta cần lưu lại tổng của 1 bên.</p>
<p>Ta có $f[i][j]$ là tổng đáp số của 2 tập, sao
cho tập bên trái có tổng là $j$, cả 2 tập
gồm các phần tử từ 1 đến $i$, lớn nhất.
Ta chuyển trạng thái từ $f[i][j]$ bằng cách
chọn $i + 1$ vào tập trái hay phải:</p>
<ul>
<li>Sang trái: chuyển sang $f[i + 1][j + A[i + 1]]$,
tổng tăng thêm $j \times (S - j)$.</li>
<li>Sang phải: chuyển sang $f[i + 1][j]$, tổng
tăng thêm: $(S[i] - j) * (S - S[i] + j)$, với
$S[i]$ là tổng $A[1..i]$.</li>
</ul>
<p>Đáp số sẽ là
$$ \max\limits_{i = 0}^{S}(f[N][i] + (M - N + 1)
\times i \times (S - i))$$</p>
<p>Độ phức tạp là $O(N^2 * A[i])$.</p>
<h2 id="permutation-1"><a href="#permutation-1" class="headerlink" title="permutation"></a>permutation</h2><h3 id="Vi-tri-dat-so-N"><a href="#Vi-tri-dat-so-N" class="headerlink" title="Vị trí đặt số $N$"></a>Vị trí đặt số $N$</h3><p>Xét dãy $R_i$. Ta nhận thấy số $N$ có thể đặt
ở $i$ khi và chỉ khi:</p>
<ul>
<li>$R_i$ phủ đến 1 hoặc đến $N$.</li>
<li>Không có $R_j$ nào phủ $i$.</li>
</ul>
<p>Giả sử ta có một vị trí thỏa mãn $x$. Nếu
đặt $x$ ở $N$, ta nhận thấy không có $j &lt; x$
nào mà $R_j$ phủ qua $x$, cũng như không
có $j &gt; x$ nào thỏa mãn. Vì thế $R[1..x - 1]$
và $R[x + 1..N]$ trở thành 2 bài toán riêng
biệt.</p>
<p>Ta có thể giải riêng 2 bài toán này, nhân
số cách với nhau, cùng với số cách chọn
$x - 1$ số trong $N - 1$ số cho tập bên trái
(và các số còn lại trong tập bên phải),
tức $C^{x - 1}_{N - 1}$.</p>
<h3 id="Quy-hoach-dong-1"><a href="#Quy-hoach-dong-1" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Gọi $f[i][j]$ là số cách điền các số hoán vị
thỏa mãn $R[i..j]$. Ta có:</p>
<ul>
<li>$x$ được gọi là thỏa mãn $i..j$ nếu:<ul>
<li>$i \le x \le j$</li>
<li>$R_x$ phủ $i$ hoặc phủ $j$</li>
<li>Không tồn tại $i \le k \le j$, $k \neq x$
mà $R_k$ phủ $x$.</li>
</ul>
</li>
<li>Ta định nghĩa đoạn đúng:<ul>
<li>$R[1..N]$ là đoạn đúng nếu không có
2 cặp nào phủ nhau.</li>
<li>Đoạn rỗng là đoạn đúng.</li>
<li>Nếu $R[i..j]$ đúng và $x$ thỏa mãn
$i..j$ thì $R[i..x-1]$ và $R[x+1..j]$
là đoạn đúng.</li>
</ul>
</li>
<li>$f[i][j] = 1$ nếu $R[i..j]$ là đoạn đúng
và $i = j$ hoặc $i = j + 1$.</li>
<li>$f[i][j] = \sum\limits_{x \text{ t/m } i..j}
f[i][x - 1] \times f[x + 1][j] \times C^{x - 1}_{N - 1}$</li>
</ul>
<p>Đáp số là $f[1][N]$. Độ phức tạp là $O(N^3)$,
do với mỗi đoạn ta cần tìm $x$ thỏa mãn.</p>
<p>Ta sẽ tối ưu việc lựa chọn này.</p>
<h3 id="So-luong-x-thoa-man"><a href="#So-luong-x-thoa-man" class="headerlink" title="Số lượng $x$ thỏa mãn"></a>Số lượng $x$ thỏa mãn</h3><p>Xét đoạn $i..j$. Gọi $L[i][j]$ là $k \le j$ lớn
nhất thỏa mãn $R[k]$ phủ $i$, $R[i][j]$
là $k \ge i$ nhỏ nhất thỏa mãn $R[k]$ phủ $j$.
Hiển nhiên $L[i][j]$ phủ tất cả các số
phủ $i$ đứng trước nó, $R[i][j]$ phủ tất
cả các số phủ $j$ đứng sau nó. Vậy chỉ có
$L[i][j]$ hoặc $R[i][j]$ có thể thỏa mãn.</p>
<p>Ta có thể tính được 2 mảng này trong
$O(N^2)$, việc còn lại là kiểm tra tính
thỏa mãn của 2 phần tử này.</p>
<h3 id="Kiem-tra-thoa-man"><a href="#Kiem-tra-thoa-man" class="headerlink" title="Kiểm tra thỏa mãn"></a>Kiểm tra thỏa mãn</h3><p>Ta còn điều kiện thỏa mãn: Không có phần
tử nào cùng đoạn phủ nó. Ta có thể dựng mảng
tính như sau:</p>
<ul>
<li>$S[i][j] = 1$ nếu $i$ phủ $j$ và 0 nếu không.</li>
<li>Ta có thể for trâu từng số và đánh dấu, tổng
độ phức tạp sẽ là $O(N^2 \log N)$ do tính chất
của bán kính.</li>
<li>Khi kiểm tra ta cần tính tổng $S[x][i..j]$.
Ta có thể sử dụng mảng tổng dồn để lấy tổng
trong $O(1)$.</li>
</ul>
<p>Như vậy ta có thuật toán $O(N^2 \log N)$.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hôm nay có khá nhiều bài trí tuệ.&lt;/p&gt;
&lt;h1 id=&quot;Tom-tat-de-bai&quot;&gt;&lt;a href=&quot;#Tom-tat-de-bai&quot; class=&quot;headerlink&quot; title=&quot;Tóm tắt đề bài&quot;&gt;&lt;/a&gt;Tóm
    
    </summary>
    
      <category term="Training" scheme="http://natsukagami.github.io/categories/Training/"/>
    
    
      <category term="training" scheme="http://natsukagami.github.io/tags/training/"/>
    
      <category term="apio" scheme="http://natsukagami.github.io/tags/apio/"/>
    
      <category term="anh Minh" scheme="http://natsukagami.github.io/tags/anh-Minh/"/>
    
      <category term="vietnamese" scheme="http://natsukagami.github.io/tags/vietnamese/"/>
    
  </entry>
  
  <entry>
    <title>2017/04/24 Training</title>
    <link href="http://natsukagami.github.io/2017/04/24/2017-04-24-Training/"/>
    <id>http://natsukagami.github.io/2017/04/24/2017-04-24-Training/</id>
    <published>2017-04-24T10:20:00.000Z</published>
    <updated>2017-04-25T16:45:13.171Z</updated>
    
    <content type="html"><![CDATA[<p>Hôm nay bài khá lằng nhằng, mình sẽ cố gắng chữa thật nhiều bước.</p>
<h1 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h1><h2 id="Heap-on-Trees-NAIPC-2017-bai-D"><a href="#Heap-on-Trees-NAIPC-2017-bai-D" class="headerlink" title="Heap on Trees, NAIPC 2017, bài D"></a><a href="https://naipc17.kattis.com/problems/heapstrees" target="_blank" rel="external">Heap on Trees, NAIPC 2017, bài D</a></h2><p>Cho một cây $N$ đỉnh, mỗi nút có một số $A_i$.
Tìm tập con các nút lớn nhất thỏa mãn nếu $i$ là tổ tiên của $j$ và $i$, $j$ đều được chọn thì $A_i &gt; A_j$.</p>
<h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 10^5$, $1 \le A_i \le 10^9$</p>
<h2 id="Pieces-of-Parentheses-NAIPC-2017-bai-A"><a href="#Pieces-of-Parentheses-NAIPC-2017-bai-A" class="headerlink" title="Pieces of Parentheses, NAIPC 2017, bài A"></a><a href="https://naipc17.kattis.com/problems/piecesofparentheses" target="_blank" rel="external">Pieces of Parentheses, NAIPC 2017, bài A</a></h2><p>Cho $N$ dãy ngoặc (không nhất thiết đúng), chọn
ra một tập con các dãy ngoặc sao cho có thể ghép
lại thành dãy ngoặc đúng dài nhất.</p>
<h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 300$, $1 \le |S_i| \le 300$</p>
<h2 id="Problem-Buyer-CCPC-2016-2017-Finals-bai-E"><a href="#Problem-Buyer-CCPC-2016-2017-Finals-bai-E" class="headerlink" title="Problem Buyer, CCPC 2016-2017 Finals, bài E"></a><a href="http://codeforces.com/gym/101206/attachments/download/5010/ccpc-20162017-finals-en.pdf" target="_blank" rel="external">Problem Buyer, CCPC 2016-2017 Finals, bài E</a></h2><p>Trên trục tọa độ cho $N$ điểm $C_i$ và $M$ đoạn
thẳng $[A_i, B_i]$. Tìm $K$ nhỏ nhất sao cho với
mọi tập con độ lớn $K$ của tập đoạn thẳng ta luôn
tìm được cặp ghép hoàn hảo của tập điểm với đoạn
thỏa mãn:</p>
<ul>
<li>Mỗi điểm ghép với đúng 1 đoạn thẳng</li>
<li>Mỗi đoạn thẳng ghép với tối đa 1 điểm</li>
<li>Nếu $C_i$ ghép với $[A_j, B_j]$ thì
$A_j \le C_i \le B_j$.</li>
</ul>
<h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N, M \le 10^5$,
$1 \le A_i \le B_i \le 10^9$,
$1 \le C_i \le 10^9$.</p>
<h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="Heap-on-Trees"><a href="#Heap-on-Trees" class="headerlink" title="Heap on Trees"></a>Heap on Trees</h2><h3 id="Xac-dinh-phuong-huong"><a href="#Xac-dinh-phuong-huong" class="headerlink" title="Xác định phương hướng"></a>Xác định phương hướng</h3><p>Ta bắt đầu với một hàm quy hoạch động “trâu”
chưa cần thiết thỏa mãn giới hạn.
Gọi $F[v][j]$ là số đỉnh lớn nhất ta có thể
chọn ở cây con gốc $v$ với giới hạn các số là
$j$.
Dễ dàng nhận thấy để tính $F[v][j]$, ta lần
lượt tính tổng $F[u][j]$ với $u$ là con của $v$.
Ngoài ra nếu $A[v] \le j$ ta có một cách chọn
là $A[v]$ cùng với tổng các $F[u][A[v] - 1]$.
$$ F[v][j] = \max(\sum\limits_{u \in child[v]}
  {F[u][j]}, (A[v] \le j) \times
  (1 + \sum\limits_
    {u \in child[v]}{F[u][A[v] - 1]}))$$
Đáp số chính là $F[root][inf]$.</p>
<p>Sau khi nén số, ta có hàm quy hoạch động $O(n^2)$.
Ta sẽ tập trung vào cải tiến hàm quy hoạch động
này.</p>
<h3 id="So-gia-tri-khac-nhau"><a href="#So-gia-tri-khac-nhau" class="headerlink" title="Số giá trị khác nhau"></a>Số giá trị khác nhau</h3><p>Xét một lá $v$. Hiển nhiên $F[v][j]$ chỉ có 2
giá trị khác nhau với mọi $j$: <strong>0</strong> khi $A[v]
&lt; j$ và <strong>1</strong> nếu ngược lại.</p>
<p>Khi cộng 2 hàm có 2 miền giá trị, ta sẽ
được một hàm có 3 miền giá trị. Tổng quát hơn,
khi cộng 2 hàm có $x$ và $y$ miền giá trị,
ta được một hàm có $x + y - 1$ miền giá trị.</p>
<p>Nếu ta coi $F$ mỗi lá là một hàm có 2 miền giá trị,
thì một cây con gốc $v$ sẽ có $F$ là một hàm có
$size[v] + 1$ miền giá trị, với $size[v]$ là kích
cỡ của cây con gốc $v$.</p>
<p>Ngoài ra, xét các vị trí thay đổi giá trị của
các hàm. Ta nhận thấy khi cộng 2 hàm có $x$ và $y$
miền giá trị, ta nhận được một hàm có $x + y - 1$
miền giá trị, trong đó các mốc chính là các mốc
thay đổi giá trị của 1 trong 2 hàm số hạng.
Như vậy, trong hàm $F[v]$, các điểm mốc chính là
các giá trị $A[u]$ với $u$ là nút trong cây con
gốc $v$.</p>
<p>Như vậy, từ một đỉnh $v$, ta có thể dựng hàm $F[u]$
với $u = parent[v]$ bằng cách “gộp” giá trị hàm
$F[v]$ vào $F[u]$.</p>
<h3 id="Gop-ham"><a href="#Gop-ham" class="headerlink" title="Gộp hàm"></a>Gộp hàm</h3><p>Giả sử ta có $F[v]$ với $k$ mốc giá trị $X_1, X_2,
…, X_k$, ta phải gộp vào hàm $F[u]$ ($u$ là
cha của $v$). Theo đúng công thức quy hoạch động,
giá trị của $F[v][X_i]$ sẽ được cộng vào các
$F[u][p]$ thỏa mãn $X_i \le p &lt; X_{i + 1}$, hay
$X_i \le p \le N$ nếu $i = k$.</p>
<p>Tất nhiên, hàm $F[u]$ cũng sẽ có các mốc $Y_1, Y_2,
…, Y_l$ ($X \subseteq Y$). Nếu coi $F[u]$ như
một IT, ta có thể update bằng cách:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> left = lower_bound(Y.begin(), Y.end(), X[i]) - Y.begin();</div><div class="line"><span class="keyword">int</span> right = lower_bound(Y.begin(), Y.end(), X[i + <span class="number">1</span>]) - <span class="number">1</span> - Y.begin();</div><div class="line">F[u].add(left, right, F[v][X[i]]); <span class="comment">// Thêm F[v][X[i]] vào đoạn [left..right]</span></div></pre></td></tr></table></figure>
<p>Sau đó ta cần cập nhật trường hợp chọn $u$.
Tất nhiên khi chọn $u$, tổng đáp số của cây con
gốc $u$ sẽ là $ans = (\max\limits_{i = 1}^{i &lt; A[u]}{F[u][i]}) + 1$.
Ta cần gán <code>f[u][i] = max(f[u][i], ans)</code> với mọi
$i \ge A[u]$. Tuy nhiên, do $F[u]$ là hàm tăng,
thực chất ta chỉ cần cộng <strong>1</strong> vào các vị trí từ
$A[u]$ đến trước vị trí $x$ có $F[u][x] = ans$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ans = F[u].get(A[u] - <span class="number">1</span>); <span class="comment">// hàm tăng</span></div><div class="line"><span class="keyword">int</span> right = F[u].lower_bound(ans) - <span class="number">1</span>;</div><div class="line">F[u].add(A[u], right, <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>Các bước gộp hàm đã hoàn chỉnh. Tuy nhiên,
độ phức tạp vẫn chưa thay đổi. Ta cần một
bước tiếp theo: thuật toán gộp set (hay gộp
IT).</p>
<h3 id="Thuat-toan-tap-lon-be"><a href="#Thuat-toan-tap-lon-be" class="headerlink" title="Thuật toán tập lớn - bé"></a>Thuật toán tập lớn - bé</h3><p>Xét bài toán: Cho $N$ tập hợp, lúc đầu mỗi tập
hợp có 1 phần tử. Để chuyển các
phần tử từ tập hợp $A$ sang tập hợp $B$, ta mất
chi phí $|A|$. Xử lí các truy vấn ghép tập hợp.</p>
<p>Cách giải bài toán rất đơn giản: với mỗi truy
vấn ta chỉ cần chuyển tất cả phần tử từ tập
nhỏ hơn vào tập lớn hơn, và tổng chi phí sẽ là
$O(N\log{N})$. Tại sao?</p>
<p>Gọi $s(p)$ là độ lớn của tập hợp chứa phần tử
$p$. Mỗi lần ta chuyển phần tử $p$ từ tập $X$
sang tập $Y$ ($|X| \le |Y|$), $s(p)$ tăng ít
nhất gấp đôi. Tuy vậy, $s(p)$ không thể vượt
quá $N$ do chỉ có tổng cộng $N$ phần tử. Vì
thế $p$ không thể bị chuyển quá $\log{N}$ lần.
Mỗi phần tử không bị chuyển quá $\log{N}$
lần, nên tổng chi phí vận chuyển không thể
quá $N\log{N}$.</p>
<h3 id="Ap-dung-vao-bai-toan-ban-dau"><a href="#Ap-dung-vao-bai-toan-ban-dau" class="headerlink" title="Áp dụng vào bài toán ban đầu"></a>Áp dụng vào bài toán ban đầu</h3><p>Để ý khi ta gộp $F[v]$ vào $F[u]$, chi phí
là $size[v] \times \log{N}$ và $size[u]$
tăng thêm $size[v]$, giống với việc gộp set.
Vì vậy ta có thể cải tiến thuật toán như sau.
Giả sử ta đã tính xong mọi $F[v]$ với $v$ là
con của $u$:</p>
<ul>
<li>Gán $F[u] = F[v_1]$ (đây là phép gán con trỏ $O(1)$).</li>
<li>Với mỗi $v$ tiếp theo:<ul>
<li>Nếu $size[u] &lt; size[v_i]$, tráo $F[u]$ và $F[v_i]$
(phép tráo con trỏ $O(1)$).  </li>
<li>Cập nhật $F[v_i]$ vào $F[u]$.</li>
</ul>
</li>
<li>Cập nhật đáp số khi chọn $u$ như trên.</li>
</ul>
<p>Ta sẽ có thuật toán $O(N\log^2{N})$. Tuy vậy, do
vẫn sử dụng IT nên bộ nhớ của ta vẫn có thể lên
đến $O(N^2)$.</p>
<h3 id="IT-bo-nho-dong"><a href="#IT-bo-nho-dong" class="headerlink" title="IT bộ nhớ động"></a>IT bộ nhớ động</h3><p>Việc biết trước kích thước tối đa và vị trí các
phần tử của IT cho phép ta dựng lên cây IT
chỉ với $\min(2N, \log{N} * size)$ nút. Việc
dựng nên IT này khá đơn giản, ta chỉ cần
thay vì sử dụng $2i$ và $2i + 1$ là con của $i$,
ta lưu 2 con trỏ chỉ đến 2 nút trái và phải,
và chỉ cấp phát bộ nhớ nếu cập nhật đến.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> node &#123;</div><div class="line">  <span class="keyword">int</span> val, sum; <span class="comment">// dữ liệu của IT</span></div><div class="line">  node *l, *r; <span class="comment">// 2 con của IT*</span></div><div class="line">  node() &#123; l = r = <span class="literal">NULL</span>; val = sum = <span class="number">0</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(node &amp;*v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (l &gt; j || r &lt; i) <span class="keyword">return</span>; <span class="comment">// không dùng</span></div><div class="line">  <span class="keyword">if</span> (v == <span class="literal">NULL</span>) v = <span class="keyword">new</span> node(); <span class="comment">// chưa có v, cấp phát</span></div><div class="line">  <span class="keyword">if</span> (i &lt;= l &amp;&amp; r &lt;= j) &#123;</div><div class="line">    v-&gt;val += val; v-&gt;sum += val;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// gọi đến bản gốc của con trỏ, chỉnh sửa trực tiếp</span></div><div class="line">  update(v-&gt;l, l, mid, i, j, val);</div><div class="line">  update(v-&gt;r, mid + <span class="number">1</span>, r, i, j, val);</div><div class="line">  v-&gt;val = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (v-&gt;l != <span class="literal">NULL</span>) v-&gt;val = max(v-&gt;l-&gt;val + v-&gt;sum, v-&gt;val);</div><div class="line">  <span class="keyword">if</span> (v-&gt;r != <span class="literal">NULL</span>) v-&gt;val = max(v-&gt;r-&gt;val + v-&gt;sum, v-&gt;val);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(node *v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// chưa cấp phát, chứng tỏ không có giá trị gì</span></div><div class="line">  <span class="keyword">if</span> (l &gt; pos || r &lt; pos) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (l == r) <span class="keyword">return</span> v-&gt;val;</div><div class="line">  <span class="keyword">return</span> max(get(v-&gt;l, l, mid, pos), get(v-&gt;r, mid + <span class="number">1</span>, r, pos)) + v-&gt;sum;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">undef</span> mid</span></div></pre></td></tr></table></figure>
<p>Do luôn chỉ có tổng cộng $N$ mốc trên tất cả IT
nên tổng bộ nhớ không quá $O(N\log{N})$.</p>
<p>Ngoài ra để đảm bảo điều này ta cũng cần thực
hiện xóa nút để giải phóng bộ nhớ. Ta có thể
thực hiện điều này sau khi chuyển xong.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(node &amp;*v)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (v == <span class="literal">NULL</span>) <span class="keyword">return</span>;</div><div class="line">  clear(v-&gt;l); clear(v-&gt;r);</div><div class="line">  <span class="keyword">delete</span> v;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Pieces-of-Parentheses"><a href="#Pieces-of-Parentheses" class="headerlink" title="Pieces of Parentheses"></a>Pieces of Parentheses</h2><h3 id="Thu-tu-quy-hoach-dong"><a href="#Thu-tu-quy-hoach-dong" class="headerlink" title="Thứ tự quy hoạch động"></a>Thứ tự quy hoạch động</h3><p>Thông thường để giải các bài ngoặc ta sẽ sử dụng
quy hoạch động. Tuy nhiên, theo đề bài thì ta
phải chọn một tập con có thứ tự, tức ta không
có một thứ tự gốc để dựng hàm quy hoạch động.</p>
<p>Ý tưởng của ta sẽ là đi tìm một thứ tự để chạy
phép qhđ.</p>
<h3 id="Bieu-dien-day-ngoac"><a href="#Bieu-dien-day-ngoac" class="headerlink" title="Biểu diễn dãy ngoặc"></a>Biểu diễn dãy ngoặc</h3><p>Điều kiện một dãy ngoặc đúng là</p>
<ul>
<li>Số mở ngoặc bằng số đóng ngoặc</li>
<li>Tại mọi thời điểm, số mở ngoặc không ít hơn
số đóng ngoặc. Nói cách khác, nếu thay <code>(</code>
thành 1 và <code>)</code> thành -1 thì tổng dồn luôn
không âm.</li>
</ul>
<p>Như vậy, thực chất với mỗi dãy ngoặc con, ta
chỉ cần lưu lại 3 thông số: độ dài, vị trí
có tổng dồn nhỏ nhất và tổng dồn cuối.
Ta gọi 3 giá trị này là $S_i$, $A_i$ và $B_i$.</p>
<p>Để tạo ra dãy ngoặc đúng từ các dãy ngoặc con
thì:</p>
<ul>
<li>$\sum\limits_{i = 1}^{k}B[i] = 0$</li>
<li>Với mọi $i$, $(\sum\limits_{j = 1}^{j &lt; i}
B[j]) + A[i] \ge 0$</li>
<li>Tổng $S_i$ là lớn nhất có thể.</li>
</ul>
<h3 id="Phan-loai-day-ngoac"><a href="#Phan-loai-day-ngoac" class="headerlink" title="Phân loại dãy ngoặc"></a>Phân loại dãy ngoặc</h3><p>Để đơn giản hóa việc sắp xếp thứ tự, ta có
thể nghĩ đến việc phân loại các dãy ngoặc.
Trong bài này ta sẽ phân thành 3 loại:</p>
<ul>
<li>$A[i] \ge 0$. Hiển nhiên $B[i] \ge 0$.
Với các loại dãy ngoặc này đặt ở vị trí nào
cũng thỏa mãn, vì vậy ta luôn đặt chúng ở
đầu để tối đa hóa tổng $B[j]$. Thứ tự từng
thành phần là không quan trọng.</li>
<li>$A[i] &lt; 0$ và $B[i] \ge 0$. Hiển nhiên
$A[i]$ càng nhỏ càng nên đặt phía sau, bởi
càng đứng sau thì tổng $B[j]$ càng lớn,
càng dễ thỏa mãn $A[i]$. Ta đặt các dãy ngoặc
loại này sau loại trên, sắp xếp các phần tử
theo thứ tự $A[i]$ giảm dần.</li>
<li>$A[i] &lt; 0$ và $B[i] &lt; 0$. Đây là loại phức
tạp nhất, ta sẽ cần một nhận xét để sắp xếp
loại ngoặc này. Hiện giờ ta chỉ biết ta sẽ
xếp chúng sau cùng.</li>
</ul>
<h3 id="A-i-lt-0-va-B-i-lt-0"><a href="#A-i-lt-0-va-B-i-lt-0" class="headerlink" title="$A[i] &lt; 0$ và $B[i] &lt; 0$"></a>$A[i] &lt; 0$ và $B[i] &lt; 0$</h3><p>Giả sử ta có một dãy ngoặc đúng chứa $i$ và
$i + 1$ là 2 phần tử loại 3 liên tiếp trong
dãy. Điều kiện sau là thỏa mãn:</p>
<ul>
<li>$S + A[i] \ge 0$, với $S$ là tổng các $B[j]$
đứng trước.</li>
<li>$S + B[i] + A[i + 1] \ge 0$.</li>
</ul>
<p>Từ đây ta có thể suy ra $S + A[i + 1] \ge 0$
do $B[i] &lt; 0$.</p>
<p>Nếu $B[i + 1] + A[i] \ge B[i] + A[i + 1]$, ta
hoàn toàn có thể đổi chỗ $i$ và $i + 1$ bởi
khi đó $S + B[i + 1] + A[i] \ge S + B[i] + A[i + 1] \ge 0$,
cả 2 điều kiện đều thỏa mãn.</p>
<p>Từ đó ta chứng minh được đáp án luôn tồn tại
sao cho với mọi cặp $i, j$ loại 3 ta đều có
$B[j] + A[i] \le B[i] + A[j]$, hay nói cách
khác, $A[i] - B[i] \le A[j] - B[j]$.</p>
<p>Như vậy, ta có thể sắp xếp các dãy ngoặc loại
3 theo thứ tự $A[i] - B[i]$ tăng dần mà vẫn
đảm bảo tìm được đáp án tối ưu.</p>
<h3 id="Cong-thuc-qhd"><a href="#Cong-thuc-qhd" class="headerlink" title="Công thức qhđ"></a>Công thức qhđ</h3><p>Khi đã có thứ tự, ta dựng công thức qhđ đơn
giản: gọi $f[i][j]$ là dãy ngoặc dài nhất
ghép được từ các đoạn từ 1 đến $i$ mà có
bậc là $j$. Ta chuyển trạng thái như sau:</p>
<ul>
<li>Không thêm đoạn $i + 1$, chuyển đến $f[i + 1][j]$.</li>
<li>Thêm đoạn $i + 1$, điều kiện là $j + A[i + 1] \ge 0$,
chuyển trạng thái đến $f[i + 1][j + B[i + 1]]$, tăng
thêm $S[i + 1]$ đơn vị.</li>
</ul>
<p>Ban đầu $f[0][0] = 0$, đáp số là $f[N][0]$.</p>
<p>Độ phức tạp là $O(N^2 * |S|)$, thỏa mãn bài toán.</p>
<h2 id="Problem-Buyer"><a href="#Problem-Buyer" class="headerlink" title="Problem Buyer"></a>Problem Buyer</h2><h3 id="Thuat-toan-tham-lam"><a href="#Thuat-toan-tham-lam" class="headerlink" title="Thuật toán tham lam"></a>Thuật toán tham lam</h3><p>Trước tiên ta cần phải biết thuật toán tham
lam để tìm cặp ghép. Thuật toán như sau:</p>
<ul>
<li>Sắp xếp $C_i$ tăng dần.</li>
<li>Giữ một <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;</code></li>
<li>Duyệt từ 1 đến $N$, khi đến $i$ ta thêm hết các đoạn
có $L_x \le C_i$ vào queue.</li>
<li>Tim phần tử trong queue có $R_x$ nhỏ nhất mà $\ge C_i$.
Nếu có, ghép và xóa khỏi queue. Nếu không, không tồn tại
cặp ghép đầy đủ.</li>
</ul>
<h3 id="Tao-ra-tap-sai"><a href="#Tao-ra-tap-sai" class="headerlink" title="Tạo ra tập sai"></a>Tạo ra tập sai</h3><p>Thay vì đi tìm $K$ nhỏ nhất sao cho mọi tập đều ghép
được, ta sẽ đi tìm $K’$ lớn nhất mà tồn tại 1 tập
không ghép được. Đáp số sẽ là $K’ + 1$.</p>
<h3 id="Vi-tri-fail"><a href="#Vi-tri-fail" class="headerlink" title="Vị trí fail"></a>Vị trí fail</h3><p>Dựa theo thuật toán tham lam, ta nhận thấy chỉ
cần ở 1 bước mà queue rỗng thì thuật toán sẽ
fail. Như vậy, khi xác định được vị trí fail
ta có thể dựng dãy bằng cách lấy tất cả các
phần tử trừ các phần tử đứng trong queue hiện
tại khi mô phỏng thuật toán.</p>
<p>Dễ dàng chứng minh đấy là cách tối ưu nhất để
làm một bước $i$ xác định nào đó fail. Như
vậy, thuật toán của ta chỉ là mô phỏng lại
thuật tham lam, mỗi bước ta xác định số
phần tử phải xóa đi để bước đó fail (chính là
số phần tử trong queue lúc đó), và tìm vị
trí cần xóa ít phần tử nhất.</p>
<p>Đáp số sẽ là $N - x$ với $x$ là số phần tử
bị xóa nhỏ nhất.
Độ phức tạp là $O(N \log{N})$.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hôm nay bài khá lằng nhằng, mình sẽ cố gắng chữa thật nhiều bước.&lt;/p&gt;
&lt;h1 id=&quot;Tom-tat-de-bai&quot;&gt;&lt;a href=&quot;#Tom-tat-de-bai&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="Training" scheme="http://natsukagami.github.io/categories/Training/"/>
    
    
      <category term="training" scheme="http://natsukagami.github.io/tags/training/"/>
    
      <category term="apio" scheme="http://natsukagami.github.io/tags/apio/"/>
    
      <category term="vietnamese" scheme="http://natsukagami.github.io/tags/vietnamese/"/>
    
      <category term="anh Hạnh" scheme="http://natsukagami.github.io/tags/anh-Hanh/"/>
    
  </entry>
  
  <entry>
    <title>2017/04/21 Training</title>
    <link href="http://natsukagami.github.io/2017/04/23/2017-04-21-Training/"/>
    <id>http://natsukagami.github.io/2017/04/23/2017-04-21-Training/</id>
    <published>2017-04-23T01:11:00.000Z</published>
    <updated>2017-04-23T10:17:42.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h1><h2 id="SEQUENCE"><a href="#SEQUENCE" class="headerlink" title="SEQUENCE"></a>SEQUENCE</h2><p>Cho dãy số <code>A[1..N]</code>. Mỗi lần xóa ta sẽ xóa
tất cả các số mang một giá trị <code>x</code> nào đó.
Hỏi dãy dài nhất có thể tạo ra được mà không
tồn tại <code>i &lt; j &lt; k</code> thỏa mãn
<code>A[i] == A[k] &amp;&amp; A[i] != A[j]</code>?</p>
<h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 10^5</code>, <code>1 &lt;= A[i] &lt;= 100</code></p>
<h2 id="AVTOGAME"><a href="#AVTOGAME" class="headerlink" title="AVTOGAME"></a>AVTOGAME</h2><p>Cho xâu <code>S</code>. Mỗi bước ta có thể chọn một đoạn
<code>l &lt; r</code> sao cho <code>S[l] == S[r]</code> và xóa đoạn đó
khỏi xâu. Hỏi xâu ngắn nhất và dài nhất có thể
tạo được (mà không thể xóa được tiếp) là bao
nhiêu?</p>
<h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>10 test, <code>1 &lt;= |S| &lt;= 100</code>, <code>&#39;a&#39; &lt;= S[i] &lt;= &#39;p&#39;</code></p>
<h2 id="DISKGAME"><a href="#DISKGAME" class="headerlink" title="DISKGAME"></a>DISKGAME</h2><p>Cho một đĩa gồm <code>N</code> tầng xoay, mỗi tầng có <code>K</code>
nấc xoay như hình dưới.</p>
<p><img src="/images/diskgame_exp.png" alt="Một đĩa có 3 tầng, mỗi tầng có 8 nấc"></p>
<p>Mỗi bước ta được xoay 1 tầng sang trái hoặc phải
1 nấc. Hỏi số bước nhỏ nhất để tạo ra 1 cột có
các số bằng nhau là bao nhiêu?</p>
<p><img src="/images/diskgame_sol.png" alt="Một cách giải hình trên"></p>
<h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N, K &lt;= 2000</code></p>
<h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="SEQUENCE-1"><a href="#SEQUENCE-1" class="headerlink" title="SEQUENCE"></a>SEQUENCE</h2><h3 id="Dieu-kien-cua-day-so"><a href="#Dieu-kien-cua-day-so" class="headerlink" title="Điều kiện của dãy số"></a>Điều kiện của dãy số</h3><p>Ta có thể thấy, 2 số <code>x</code> và <code>y</code> không được cùng
tồn tại trong đáp án nếu số <code>x</code> bị “kẹp giữa” số
<code>y</code> hoặc ngược lại. Ta cũng có thể dễ dàng
chứng minh một dãy không tồn tại cặp <code>x, y</code>
nào như vậy là một dãy thỏa mãn.</p>
<h4 id="Vi-du"><a href="#Vi-du" class="headerlink" title="Ví dụ"></a>Ví dụ</h4><p><code>1, 2, 1, 3, 1, 4</code> không thỏa mãn vì số <code>2</code> bị
kẹp giữa 2 lần số <code>1</code>.</p>
<p>Bài toán của ta trở thành đi tìm một dãy không
có 2 số nào “kẹp” nhau.</p>
<h3 id="Dau-va-duoi"><a href="#Dau-va-duoi" class="headerlink" title="Đầu và đuôi"></a>Đầu và đuôi</h3><p>Xét ví dụ ở trên, ta có thể thấy <code>2</code> bị kẹp
giữa bởi 2 số <code>1</code> ở vị trí 1 và 3. Ta cũng có
thể nói <code>2</code> bị kẹp giữa bởi 2 số <code>1</code> ở 1 và 5.</p>
<p>Giả sử <code>x</code> kẹp giữa <code>y</code> ở 2 vị trí <code>a &lt;= b</code>,
ta cũng có thể nói <code>x</code> kẹp ở 2 vị trí <code>first[x] &lt;= a</code>
và <code>b &lt;= last[x]</code> (2 lần xuất hiện đầu và cuối
của <code>x</code>). Như vậy điều kiện để <code>x</code> kẹp giữa <code>y</code>
chỉ là tồn tại <code>y</code> nằm giữa 2 vị trí xa nhau nhất
chứa <code>x</code>.</p>
<p>Đi xa hơn, ta có thể thấy xét trên trục 1 chiều,
tồn tại cặp <code>x</code>, <code>y</code> kẹp nhau khi và chỉ khi 2 đoạn
<code>(first[x], last[x])</code> và <code>(first[y], last[y])</code>
giao nhau.</p>
<h3 id="Quy-hoach-dong"><a href="#Quy-hoach-dong" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Như vậy, ta chỉ cần tìm 1 tập số sao cho tập
<code>(first[x], last[x])</code> của các số không giao nhau.
Đây là bài toán quy hoạch động cơ bản, có thể thực
hiện quy hoạch động trong
<code>O(N + M)</code> với <code>M</code> là số phần tử khác nhau.</p>
<p>Gọi <code>f[i]</code> là số đoạn thẳng nhiều nhất ta có
thể chọn trong khoảng <code>1..i</code>. Từ đây, ta có 2
lựa chọn:</p>
<ul>
<li>Thêm khoảng không, cập nhật <code>f[i]</code> cho <code>f[i + 1]</code>.</li>
<li>Thêm một đoạn <code>(i + 1..j)</code>. Ta duyệt tất cả các
đoạn thẳng có đầu mút trái là <code>i + 1</code> và cập nhật
<code>f[i] + 1</code> cho <code>f[j]</code>.</li>
</ul>
<p>Đáp số là <code>f[N]</code>.</p>
<h2 id="AVTOGAME-1"><a href="#AVTOGAME-1" class="headerlink" title="AVTOGAME"></a>AVTOGAME</h2><h3 id="Co-the-xoa-1-doan"><a href="#Co-the-xoa-1-doan" class="headerlink" title="Có thể xóa 1 đoạn?"></a>Có thể xóa 1 đoạn?</h3><p>Hiển nhiên các đoạn ta xóa sẽ không giao nhau,
nên chỉ có 2 khả năng xảy ra để xóa đoạn <code>[a &lt; b]</code>:</p>
<ul>
<li>Nếu <code>S[a] == S[b]</code> ta xóa cả đoạn trong 1 bước.</li>
<li>Chọn 1 vị trí <code>a &lt; k &lt; b - 1</code>, xóa đoạn <code>a..k</code>
rồi xóa đoạn <code>k+1..b</code>.</li>
</ul>
<p>Dựa vào nhận xét này, ta dễ dàng dựng nên mảng
<code>canErase[l][r]</code> (có thể xóa đoạn <code>l..r</code> không?)
trong <code>O(N^3)</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= N; ++l) &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = l + <span class="number">1</span>; r &lt;= N; ++r) &#123;</div><div class="line">    <span class="keyword">if</span> (S[l] == S[r]) canErase[l][r] = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = l + <span class="number">1</span>; k + <span class="number">1</span> &lt; r; ++k) &#123;</div><div class="line">      canErase[l][r] = canErase[l][r] || (canErase[l][k] &amp;&amp; canErase[k + <span class="number">1</span>][r]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Chi-phi-xoa-het-nho-nhat"><a href="#Chi-phi-xoa-het-nho-nhat" class="headerlink" title="Chi phí xóa hết nhỏ nhất"></a>Chi phí xóa hết nhỏ nhất</h3><p>Thay vì giải bài toán xâu ngắn nhất còn lại,
ta sẽ thay đổi bài toán bằng cách cho phép một
kiểu xóa nữa: xóa <strong>1 kí tự</strong> với chi phí 1.
Sau đó ta đi tìm chi phí nhỏ nhất để xóa
cả dãy. Ta có thể thấy tính chất các bước
xóa rời nhau không thay đổi.</p>
<p>Hiển nhiên chi phí sẽ bằng đáp án, vì ta không
bao giờ xóa đơn lẻ 2 kí tự giống nhau.</p>
<p>Để giải được bài toán này, ta cải tiến thuật
toán kiểm tra tính xóa được phía trên, thành
chi phí nhỏ nhất để xóa đoạn <code>l..r</code>. Hiển
nhiên <code>cost[i][i] = 1</code> vì chỉ có 1 kí tự. Với
đoạn <code>l..r</code> ta có 2 cách xóa:</p>
<ul>
<li>Nếu <code>S[l] == S[r]</code> ta xóa cả đoạn với chi
phí 0.</li>
<li>Chọn <code>l &lt;= k &lt; r</code> rồi xóa 2 đoạn <code>l..k</code> và
<code>k + 1..r</code> với tổng chi phí
<code>cost[l][k] + cost[k + 1][r]</code>.</li>
</ul>
<p>Đáp số là <code>cost[1][N]</code>, độ phức tạp là <code>O(N^3)</code>.</p>
<h3 id="Cac-ki-tu-con-lai"><a href="#Cac-ki-tu-con-lai" class="headerlink" title="Các kí tự còn lại"></a>Các kí tự còn lại</h3><p>Để giải được bài toán dãy còn lại dài nhất,
ta cần phải thấy tính chất của dãy còn lại.
Tính chất khá đơn giản: không tồn tại 2 kí
tự giống nhau trong xâu. Như vậy, ta cần
nhặt ra 1 tập kí tự khác nhau sao cho các phần
ở giữa có thể xóa được.</p>
<p>Điều kiện chỉ có 16 kí tự khác nhau cho ta
một gợi ý: sử dụng bitmask để quản lí các
kí tự đã lấy.</p>
<h3 id="Quy-hoach-dong-1"><a href="#Quy-hoach-dong-1" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Gọi <code>bool f[i][mask]</code> là tính khả thi của
việc chọn ra tập kí tự thỏa mãn <code>mask</code> trong đoạn
<code>1..i</code> và xóa hết các kí tự còn lại, trong đó
kí tự cuối ta chọn chính là <code>S[i]</code>. Ta có 2 lựa
chọn:</p>
<ul>
<li>Chọn cả kí tự <code>S[i - 1]</code>, với điều kiện
<code>S[i - 1] != S[i]</code> và <code>mask</code> có <code>S[i - 1]</code>. Ta
lùi về trạng thái <code>f[i - 1][mask ^ S[i]]</code>.</li>
<li>Chọn một vị trí <code>j &lt; i</code> và lấy kí tự này là
kí tự đứng ngay trước <code>S[i]</code>. Điều kiện là
<code>S[j] != S[i]</code>, <code>mask</code> có <code>S[j]</code> và <code>j + 1..i - 1</code>
xóa được. Ta lùi về trạng thái <code>f[j][mask ^ S[i]]</code>.</li>
</ul>
<p>Độ phức tạp sẽ là <code>O(N^2 * 2^16)</code>, chưa thể
thỏa mãn bài toán. Ta cần một chút cải tiến để
xóa bớt <code>N</code>.</p>
<h3 id="Nhay-chon-va-xoa"><a href="#Nhay-chon-va-xoa" class="headerlink" title="Nhảy, chọn và xóa"></a>Nhảy, chọn và xóa</h3><p>Ta sẽ chỉnh sửa hàm quy hoạch động một chút: xóa
bỏ điều kiện <code>S[i]</code> là kí tự cuối cùng chọn.
Thay vào đó, ta “nhảy” từng bước, chọn hoặc sử
dụng duy nhất một phép xóa. Cụ thể, từ trạng thái
<code>f[i][mask]</code>, ta có:</p>
<ul>
<li><code>S[i]</code> là kí tự được chọn. Điều kiện là <code>mask</code>
chứa <code>S[i]</code>. Lùi về <code>f[i - 1][mask ^ S[i]]</code>.</li>
<li><code>S[i]</code> là kí tự cuối cùng bị xóa. Vậy ta cần
một vị trí <code>j &lt; i</code> sao cho <code>S[i] == S[j]</code>, và lùi
về <code>f[j - 1][mask]</code>.</li>
</ul>
<p>Thoáng qua, vẫn là <code>O(N^2 * 2^16)</code>. Làm sao để
cải tiến? Ta thấy, trong trường hợp 2, điều kiện
duy nhất là <code>S[j] == S[i]</code>, mà chỉ có 16 loại kí tự,
vậy ta hoàn toàn có thể lưu lại tất cả các trường
hợp <code>f[j - 1][mask]</code> với mỗi lọai <code>S[j]</code> khác nhau.</p>
<p>Gọi <code>g[i][mask]</code> là tổng kết tất cả các trường hợp
<code>f[j][mask]</code> thỏa mãn <code>S[j + 1] == i</code>. Ta có thể
vừa đi vừa cập nhật <code>g[S[i + 1]][mask]</code>, đồng thời
trong trường hợp 2 ta chỉ cần lấy giá trị của
<code>g[S[i]][mask]</code> trong <code>O(1)</code>.</p>
<p>Độ phức tạp giảm xuống còn <code>O(N * 2^16)</code>,
thỏa mãn bài toán.</p>
<h2 id="DISKGAME-1"><a href="#DISKGAME-1" class="headerlink" title="DISKGAME"></a>DISKGAME</h2><h3 id="Chi-phi-xoay-cua-1-dia"><a href="#Chi-phi-xoay-cua-1-dia" class="headerlink" title="Chi phí xoay của 1 đĩa"></a>Chi phí xoay của 1 đĩa</h3><p>Hãy phân tích chi phí xoay của 1 đĩa để có
số <code>n</code> ở vị trí <code>p</code>. Hiển nhiên chi phí là
<code>min(|x - p|)</code> với <code>x</code> là các vị trí xuất hiện
của <code>n</code> trong đĩa.</p>
<p>Thực chất ta chỉ cần xét đến 2 vị trí gần nhất
bên trái và bên phải của <code>p</code>. Ta tạm gọi là
<code>x</code> và <code>y</code> (để đơn giản ta coi <code>x &lt;= p &lt;= y</code>).
Chi phí sẽ là <code>min(p - x, y - p)</code>. Dễ dàng nhận
thấy <code>p - x</code> là hàm tăng 1 đơn vị, <code>y - p</code> là
hàm giảm 1 đơn vị với <code>x &lt;= p &lt;= y</code>. min của
2 hàm này sẽ là “núi” góc 45 độ có chóp ở trung
điểm của <code>x</code> và <code>y</code> (hoặc có chóp ngang nếu trung
điểm không nguyên).</p>
<p>Nếu ta xét tất cả các cặp vị trí liên tiếp của
số, thì chi phí sẽ là nhiều “ngọn núi” như vậy.</p>
<p>Ta có thể thấy chi phí là một hàm như hình dưới,
cho dãy <code>1 2 3 1 2 3 5 1 5</code> với <code>n = 1</code>. Lưu ý
đoạn <code>8, 9, 1</code> cũng là 1 “ngọn núi”, vì thực chất
đĩa là hình tròn.</p>
<p><img src="/images/diskgame_func.png" alt="Hàm chi phí"></p>
<p>Ta có thể cắt hàm thành các đường chéo tăng và
giảm 45 độ để đơn giản hóa việc tính toán chi
phí cho tất cả các đĩa.</p>
<p>Tổng cộng 1 đĩa sẽ bị cắt thành <code>2K</code> đường chéo.</p>
<h3 id="Tinh-tong-chi-phi-cho-moi-dia"><a href="#Tinh-tong-chi-phi-cho-moi-dia" class="headerlink" title="Tính tổng chi phí cho mọi đĩa"></a>Tính tổng chi phí cho mọi đĩa</h3><p>Với mỗi vị trí <code>p</code> và một số <code>n</code>, ta cần tính
tổng chi phí xoay với mọi đĩa trong <code>O(1)</code>.
Biết chúng là tổng các đường chéo, làm sao
để tính nhanh?</p>
<p>Ta sẽ vận dụng tính chất chúng đều có dạng <code>x + b</code>
hoặc <code>-x + b</code> và sử dụng đường quét để tính
với mỗi <code>n</code>.</p>
<p>Ta thấy, khi có <code>k</code> đoạn <code>x + b[i]</code>, chi phí là
<code>kx + sum(b[i])</code> với bước tăng là <code>k</code>.
Vì vậy thực chất với mỗi vị
trí ta chỉ cần biết số đoạn tăng và tổng phần
hằng số của chúng. Ta hoàn toàn có thể làm
điều này khi quét bằng cách xét 2 đầu mút đầu
(thêm đoạn) và cuối (xóa đoạn) sau đó xử lí
từ trái sang phải.</p>
<p>Điều tương tự cũng đúng với hàm giảm.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> b[N * K + <span class="number">1</span>]; <span class="comment">// tất cả b[i] của các đường tăng</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; add[K + <span class="number">2</span>], remove[K + <span class="number">2</span>]; <span class="comment">// các mốc thêm xóa</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">addSegment</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">  <span class="comment">// thêm đoạn [l..r] = x + b[id]</span></div><div class="line">  add[l].push_back(id);</div><div class="line">  remove[r + <span class="number">1</span>].push_back(id);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> value = <span class="number">0</span>, cnt = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= K; ++i) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p: add[i]) &#123;</div><div class="line">      value += b[p] + i - <span class="number">1</span>; <span class="comment">// giá trị của i trước đó</span></div><div class="line">      ++cnt;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p: remove[i]) &#123;</div><div class="line">      value -= b[p] + i - <span class="number">1</span>;</div><div class="line">      --cnt;</div><div class="line">    &#125;</div><div class="line">    value += cnt;</div><div class="line">    <span class="comment">// value là tổng ở vị trí i</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Ta có thể thấy độ phức tạp với mỗi <code>n</code> là <code>O(K + số đoạn của n)</code>.
Vì thế tổng độ phức tạp là <code>O(K^2 + NK)</code>, do có <code>2NK</code> đoạn tất cả.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Tom-tat-de-bai&quot;&gt;&lt;a href=&quot;#Tom-tat-de-bai&quot; class=&quot;headerlink&quot; title=&quot;Tóm tắt đề bài&quot;&gt;&lt;/a&gt;Tóm tắt đề bài&lt;/h1&gt;&lt;h2 id=&quot;SEQUENCE&quot;&gt;&lt;a href
    
    </summary>
    
      <category term="Training" scheme="http://natsukagami.github.io/categories/Training/"/>
    
    
      <category term="training" scheme="http://natsukagami.github.io/tags/training/"/>
    
      <category term="apio" scheme="http://natsukagami.github.io/tags/apio/"/>
    
      <category term="vietnamese" scheme="http://natsukagami.github.io/tags/vietnamese/"/>
    
      <category term="thầy Nghĩa" scheme="http://natsukagami.github.io/tags/thay-Nghia/"/>
    
  </entry>
  
  <entry>
    <title>2017/04/20 Training</title>
    <link href="http://natsukagami.github.io/2017/04/21/2017-04-20-Training/"/>
    <id>http://natsukagami.github.io/2017/04/21/2017-04-20-Training/</id>
    <published>2017-04-21T11:36:25.000Z</published>
    <updated>2017-04-23T02:12:39.769Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Lưu ý</strong>: Mình đã tóm tắt đề bài ở trên, ai không muốn bị spoil thì đừng
kéo xuống lời giải vội.</p>
<p>Hôm nay có 5 bài của thầy Đông. Do mình không được nghe thầy chữa buổi chiều nên solution là của mình, mặc dù 99% là đúng nhưng không đảm bảo.
Thực chất bài không phải là khó quá.</p>
<h1 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h1><h2 id="ACM"><a href="#ACM" class="headerlink" title="ACM"></a>ACM</h2><p>Có <code>N</code> đội, mỗi đội có 11 chỉ số <code>A[i][1..11]</code>. Chọn 3 đội sao cho <code>sum[i = 1..11][max(A[x, y, z][i])]</code> (tổng của max chỉ số từng loại của 3 đội) là lớn nhất.</p>
<h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 30000</code></p>
<h2 id="DOMINO-Bai-toan-thu-nhat"><a href="#DOMINO-Bai-toan-thu-nhat" class="headerlink" title="DOMINO (Bài toán thứ nhất)"></a>DOMINO (Bài toán thứ nhất)</h2><p>Cho một bảng <code>M x N</code> với <code>K</code> ô cấm.
Điền 0 hoặc 1 vào các ô không bị cấm sao cho
với ô <code>(i, j)</code>:</p>
<ul>
<li>Nếu <code>i + j</code> lẻ, thì ô <code>(i, j)</code> không nhỏ
hơn các ô không bị cấm xung quanh.</li>
<li>Nếu <code>i + j</code> chẵn, thì <code>(i, j)</code> không lớn
hơn các ô không bị cấm xung quanh.</li>
</ul>
<h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= M, N &lt;= 16</code></p>
<h2 id="DOMINO-Bai-toan-thu-hai"><a href="#DOMINO-Bai-toan-thu-hai" class="headerlink" title="DOMINO (Bài toán thứ hai)"></a>DOMINO (Bài toán thứ hai)</h2><p>Lần này không có ô cấm. Điều kiện như bài toán thứ nhất.</p>
<h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 8</code>, <code>1 &lt;= M &lt;= 10^6</code></p>
<h2 id="GAMES"><a href="#GAMES" class="headerlink" title="GAMES"></a>GAMES</h2><p>Cho một dãy bit <code>N</code> phần tử chưa xác định
 và <code>M</code> điều kiện có dạng
xor của <code>A[l..r]</code> là 0 hay 1. Tìm vị trí <code>x</code> đầu tiên
mà điều kiện <code>x</code> mâu thuẫn với các điều kiện trên.</p>
<h4 id="Gioi-han-3"><a href="#Gioi-han-3" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 10^9</code>, <code>1 &lt;= M &lt;= 10^5</code></p>
<h2 id="HANOI"><a href="#HANOI" class="headerlink" title="HANOI"></a>HANOI</h2><p>Cho thuật toán giải bài toán tháp Hà Nội:
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HanoiTower</span><span class="params">(height, From, Temp, To)</span>:</span></div><div class="line">  <span class="keyword">if</span> height == <span class="number">1</span>:</div><div class="line">    <span class="comment"># Move one from `From` to `To`</span></div><div class="line">    <span class="keyword">return</span></div><div class="line">  HanoiTower(height - <span class="number">1</span>, From, To, Temp)</div><div class="line">  HanoiTower(<span class="number">1</span>, From, Temp, To)</div><div class="line">  HanoiTower(height - <span class="number">1</span>, Temp, From, To)</div><div class="line"></div><div class="line"><span class="comment"># Call the function</span></div><div class="line">HanoiTower(N, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>)</div></pre></td></tr></table></figure></p>
<ul>
<li>Tìm trạng thái của 3 tháp sau <code>P</code> lần gọi hàm.</li>
<li>Cho trạng thái của 3 tháp, tính số bước đã gọi hàm
<code>P</code>, hoặc in <code>-1</code> nếu không tồn tại trạng thái đó khi giải.</li>
</ul>
<h4 id="Gioi-han-4"><a href="#Gioi-han-4" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 100</code>. Lưu ý <code>P</code> có thể là số lớn.</p>
<h2 id="WG"><a href="#WG" class="headerlink" title="WG"></a>WG</h2><p>Cho một xâu <code>P</code> và một tập xâu <code>S[1..N]</code>. Dựng xâu <code>T</code> như sau:</p>
<ul>
<li>Đầu tiên chọn một xâu trong tập <code>S[]</code> và thêm vào <code>T</code></li>
<li>Sau đó, tìm xâu <code>S[i]</code> bất kì thỏa mãn <code>S[0] == T.back()</code> rồi thêm <code>S[i][1..]</code> vào.</li>
</ul>
<p>Hỏi xâu <code>T</code> ngắn nhất chứa dãy con không liên tiếp <code>P</code> là gì?</p>
<h4 id="Gioi-han-5"><a href="#Gioi-han-5" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= |P| &lt;= 250, 1 &lt;= |S[i]| &lt;= 10, 1 &lt;= N &lt;= 1000</code></p>
<h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="ACM-1"><a href="#ACM-1" class="headerlink" title="ACM"></a>ACM</h2><h3 id="Tom-tat-de-bai-1"><a href="#Tom-tat-de-bai-1" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Có <code>N</code> đội, mỗi đội có 11 chỉ số <code>A[i][1..11]</code>. Chọn 3 đội sao cho <code>sum[i = 1..11][max(A[x, y, z][i])]</code> (tổng của max chỉ số từng loại của 3 đội) là lớn nhất.</p>
<h4 id="Gioi-han-6"><a href="#Gioi-han-6" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 30000</code></p>
<h3 id="“Phuc-tap-hoa”-bai-toan"><a href="#“Phuc-tap-hoa”-bai-toan" class="headerlink" title="“Phức tạp hóa” bài toán"></a>“Phức tạp hóa” bài toán</h3><p>Rất khó để thực hiện việc chọn
nếu mình sử dụng việc lấy max của
từng chỉ số. Vì thế ta có thể
thay đổi bài toán thành <strong>chọn 3 đội
rồi mỗi chỉ số lấy của một đội</strong>.
Ta có thể thấy khi có quản lí đơn giản hơn:
chỉ cần mỗi đội một bitmask lựa chọn chỉ số.</p>
<p>Hiển nhiên khi đã xét tất cả trường hợp
thì trường hợp tốt nhất luôn là lấy max.</p>
<h3 id="Ghep-bitmask"><a href="#Ghep-bitmask" class="headerlink" title="Ghép bitmask"></a>Ghép bitmask</h3><p>Giả sử ta đã chọn 3 đội <code>i</code>, <code>j</code> và <code>k</code>.
Ta sẽ gán lần lượt 3 mask <code>x</code>, <code>y</code>, <code>z</code> cho 3 đội
này. Các mask sẽ thỏa mãn:</p>
<ul>
<li>Đôi một rời rạc (<code>x &amp; y == 0</code>, <code>y &amp; z == 0</code>, <code>z &amp; x == 0</code>)</li>
<li>Ghép lại thì có đầy đủ (<code>x | y | z == (1 &lt;&lt; 11) - 1</code>)</li>
<li>Tổng chỉ số tương ứng lớn nhất.</li>
</ul>
<p>Ta có thể thấy, thực chất ta không cần quan tâm
các đội được chọn là đội nào.
Với mask <code>x</code> được chọn trước, ta chỉ cần tính xem
trong các đội thì đội nào có tổng tương ứng mask <code>x</code>
là lớn nhất.
Việc 2 mask <code>x</code> và <code>y</code> bị chọn trùng đội không quan trọng:
Ta có thể coi như khi đó có 1 người được chọn với mask <code>0</code>.</p>
<p>Ta có thể tính trước <code>max[x]</code> với mask <code>x</code> trong <code>O(N * 2^11)</code>.</p>
<h3 id="Chon-3-phan-tu"><a href="#Chon-3-phan-tu" class="headerlink" title="Chọn 3 phần tử"></a>Chọn 3 phần tử</h3><p>Trước tiên, ta có thể thấy nếu chỉ chọn 2 phần tử, ta
có thể for tất cả cặp mask, kiểm tra trong <code>O((2^11)^2)</code>.
Hiển nhiên do 2 mask đều chỉ có 11 bit nên khi <code>or</code> lại với
nhau (ghép bộ) thì mask mới vẫn chỉ có 11 bit. Vậy để chọn
3 phần tử, ta có thể tiếp tục ghép cặp tập đã or với tập <code>max[x]</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> two[<span class="number">1</span> &lt;&lt; <span class="number">11</span>];</div><div class="line"><span class="keyword">int</span> three[<span class="number">1</span> &lt;&lt; <span class="number">11</span>];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>); ++i) &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>); ++j) &#123;</div><div class="line">    <span class="keyword">if</span> (!(i &amp; j)) <span class="comment">// không có phần tử trùng</span></div><div class="line">      two[i | j] = max(two[i | j], max[i] + max[j]);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>); ++i) &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>); ++j) &#123;</div><div class="line">    <span class="keyword">if</span> (!(i &amp; j)) <span class="comment">// không có phần tử trùng</span></div><div class="line">      three[i | j] = max(three[i | j], two[i] + max[j]);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Đáp số chính là <code>three[(1 &lt;&lt; 11) - 1]</code>.
Độ phức tạp sẽ là <code>O((2 ^ 11) ^ 2)</code>.</p>
<h2 id="DOMINO-Bai-toan-thu-nhat-1"><a href="#DOMINO-Bai-toan-thu-nhat-1" class="headerlink" title="DOMINO (Bài toán thứ nhất)"></a>DOMINO (Bài toán thứ nhất)</h2><h3 id="Tom-tat-de-bai-2"><a href="#Tom-tat-de-bai-2" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho một bảng <code>M x N</code> với <code>K</code> ô cấm.
Điền 0 hoặc 1 vào các ô không bị cấm sao cho
với ô <code>(i, j)</code>:</p>
<ul>
<li>Nếu <code>i + j</code> lẻ, thì ô <code>(i, j)</code> không nhỏ
hơn các ô không bị cấm xung quanh.</li>
<li>Nếu <code>i + j</code> chẵn, thì <code>(i, j)</code> không lớn
hơn các ô không bị cấm xung quanh.</li>
</ul>
<h4 id="Gioi-han-7"><a href="#Gioi-han-7" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= M, N &lt;= 16</code></p>
<h3 id="Quy-hoach-dong"><a href="#Quy-hoach-dong" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Thực chất đây là một bài toán quy hoạch
động bitmask cơ bản. Nhận xét rằng với mỗi ô
ta chỉ cần để ý bit ô bên trái và bên trên nó để
có thể xét điều kiện thỏa mãn.</p>
<p>Khi quy hoạch động ta đi từng ô theo từng cột,
trên xuống dưới trái qua phải.
Gọi <code>f[i][j][mask]</code> là số cách lát kể từ
ô <code>(i, j)</code> đến cuối cùng, với <code>mask</code> là trạng thái
<code>N</code> ô cuối cùng đã đến trước <code>(i, j)</code> (tức các ô <code>(i - 1, j)</code>,
<code>(i - 1, j + 1)</code>, …, <code>(i, j - 1)</code>). Xem hính dưới:</p>
<p><img src="/images/20170420_domino.png" alt="Bài Domino"></p>
<p>Hình thể hiện trạng thái khi đã đến ô <code>(i, j)</code>. Ô màu xanh lá
là các ô đã lát, ô màu vàng thể hiện mask đang bị quản lí bởi
bit tương ứng trong mask, ô màu xanh dương thể hiện ô sắp điền,
ô màu đỏ thể hiện các ô chưa lát.</p>
<p>Để chuyển trạng thái ta xác định bit của ô <code>(i, j)</code>, nếu nó thỏa mãn
điều kiện với ô trái và trên thì gọi đến trạng thái tiếp theo (<code>f[i][j + 1][mask mới]</code>
hoặc <code>f[i + 1][1][mask mới]</code> nếu đó là ô cuối của cột).</p>
<h4 id="Chuyen-mask-nhu-nao"><a href="#Chuyen-mask-nhu-nao" class="headerlink" title="Chuyển mask như nào?"></a>Chuyển mask như nào?</h4><p>Ta để ý trên hình, bit <code>3</code>, kể từ ô tiếp theo, không cần biết đến nữa.
Ta có thể xóa bit này và đẩy lên, cho bit của <code>(i, j)</code> vào cuối. Như
vậy trạng thái của mình luôn có <code>N</code> bit.</p>
<p>Độ phức tạp là <code>O(N * M * 2^N)</code>.</p>
<h3 id="Cai-dat-nhu-nao"><a href="#Cai-dat-nhu-nao" class="headerlink" title="Cài đặt như nào?"></a>Cài đặt như nào?</h3><p>Nên gọi đệ quy có nhớ.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> f[<span class="number">20</span>][<span class="number">20</span>][<span class="number">1</span> &lt;&lt; <span class="number">16</span>];</div><div class="line"><span class="keyword">bool</span> visited[<span class="number">20</span>][<span class="number">20</span>][<span class="number">1</span> &lt;&lt; <span class="number">16</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (i &gt; M) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// trường hợp biên</span></div><div class="line">  <span class="keyword">if</span> (visited[i][j][mask]) <span class="comment">// đã tính</span></div><div class="line">    <span class="keyword">return</span> f[i][j][mask];</div><div class="line">  visited[i][j][mask] = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ch = <span class="number">0</span>; ch &lt; <span class="number">2</span>; ++ch) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="comment">/*kiểm tra điều kiện đặt bit ch ở (i, j)*/</span>) &#123;</div><div class="line">      f[i][j][mask] += cal(i + (j == N), j % N + <span class="number">1</span>, (mask &lt;&lt; <span class="number">1</span>) &amp; ((<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>) + ch);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> f[i][j][mask];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// x &amp; ((1 &lt;&lt; N) - 1) để lấy x % (1 &lt;&lt; N), N bit cuối của x.</span></div><div class="line"><span class="comment">// (x &lt;&lt; 1) == x * 2, đẩy các bit sang phải 1 đơn vị.</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> ans = cal(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<h2 id="DOMINO-Bai-toan-thu-hai-1"><a href="#DOMINO-Bai-toan-thu-hai-1" class="headerlink" title="DOMINO (Bài toán thứ hai)"></a>DOMINO (Bài toán thứ hai)</h2><p>Lần này không có ô cấm. Điều kiện như bài toán thứ nhất.</p>
<h4 id="Gioi-han-8"><a href="#Gioi-han-8" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 8</code>, <code>1 &lt;= M &lt;= 10^6</code></p>
<h3 id="Nhan-ma-tran"><a href="#Nhan-ma-tran" class="headerlink" title="Nhân ma trận"></a>Nhân ma trận</h3><p>Lần này không có ô cấm, nên với mỗi hàng ta chỉ cần quan
tâm mask của nó là gì. Từ đây ta có thể nghĩ đến việc nhân
ma trận.</p>
<p>Giới hạn <code>N</code> nhỏ, <code>M</code> lớn cũng mang đến cho ta gợi ý này.</p>
<h3 id="So-trang-thai"><a href="#So-trang-thai" class="headerlink" title="Số trạng thái"></a>Số trạng thái</h3><p><code>O((2 ^ N)^3 * log(M))</code> chưa thể thỏa mãn bài toán.
Ta phân tích thêm một chút: với mỗi cột, ta có thể loại ra
các trạng thái không thỏa mãn các điều kiện giữa 2 ô liên tiếp
trên cùng cột.</p>
<p>Việc thử nghiệm cho thấy với <code>N = 8</code> cũng chỉ có <strong>55</strong> trạng thái,
có thể nhân ma trận.</p>
<h3 id="Dieu-kien-theo-i-j"><a href="#Dieu-kien-theo-i-j" class="headerlink" title="Điều kiện theo i + j"></a>Điều kiện theo <code>i + j</code></h3><p>Khi chuyển từ cột <code>2i</code> sang cột <code>2i + 1</code>,
điều kiện bị thay đổi: thứ tự các ô trong
cột đang từ <em>lẻ, chẵn, lẻ, …</em> thành <em>chẵn, lẻ, chẵn,…</em>
Điều này làm cho việc chuyển trạng thái không thể
thực hiện đơn thuần.</p>
<p>Ta có thể sửa điều này bằng cách thêm 1 bit cho
trạng thái của cột, chỉ xem đây là trạng thái cho cột lẻ
hay chẵn.</p>
<p>Bảng chuyển đổi của mình sẽ chỉ cho phép chuyển từ cột
lẻ sang chẵn và ngược lại.</p>
<p>Để đơn giản từ giờ ta gọi số trạng thái là <code>P</code> (<code>P &lt;= 110</code>).</p>
<h3 id="Ma-tran-goc-va-dap-so"><a href="#Ma-tran-goc-va-dap-so" class="headerlink" title="Ma trận gốc và đáp số"></a>Ma trận gốc và đáp số</h3><p>Hiển nhiên ta trận gốc là một ma trận <code>1 x P</code>, trong đó
các ô thể hiện trạng thái cột lẻ sẽ là <code>1</code>. Ta nhân ma trận
gốc với bảng chuyển đổi đã lũy thừa <code>M - 1</code>, nhận được ma
trận đáp số <code>1 x P</code>. Đáp án chính là tổng các phần tử trong
ma trận.</p>
<p>Độ phức tạp là <code>O(P ^ 3 * log(M))</code>.</p>
<h2 id="GAMES-1"><a href="#GAMES-1" class="headerlink" title="GAMES"></a>GAMES</h2><h3 id="Tom-tat-de-bai-3"><a href="#Tom-tat-de-bai-3" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho một dãy bit <code>N</code> phần tử chưa xác định
 và <code>M</code> điều kiện có dạng
xor của <code>A[l..r]</code> là 0 hay 1. Tìm vị trí <code>x</code> đầu tiên
mà điều kiện <code>x</code> mâu thuẫn với các điều kiện trên.</p>
<h4 id="Gioi-han-9"><a href="#Gioi-han-9" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 10^9</code>, <code>1 &lt;= M &lt;= 10^5</code></p>
<h3 id="Chat-nhi-phan"><a href="#Chat-nhi-phan" class="headerlink" title="Chặt nhị phân"></a>Chặt nhị phân</h3><p>Để tìm vị trí đầu tiên mâu thuẫn, ta chặt nhị phân <code>x</code>
để tìm vị trí xa nhất mà vẫn tồn tại một dãy thỏa mãn
các điều kiện từ 1 đến <code>x</code>.</p>
<p>Bài toán trở thành kiểm tra xem có một dãy tồn tại không.</p>
<h3 id="Tinh-chat-mang-don"><a href="#Tinh-chat-mang-don" class="headerlink" title="Tính chất mảng dồn"></a>Tính chất mảng dồn</h3><p>Nếu ta xét mảng dồn <code>S[1..N]</code>, thì điều kiện tổng xor
<code>l..r</code> bằng 0 hay 1 tương đương với <code>S[l - 1]</code> với <code>S[r]</code>
bằng nhau hay khác nhau.</p>
<p>Ngoài ra, <code>S[i]</code> có thể nhận được bất kí giá trị nào
không phụ thuộc vào <code>S[i - 1]</code> nên ta có thể thoải mái
gán một giá trị bất kì, nhưng chỉ <strong>một</strong> mà thôi.</p>
<p>Bài toán trở thành, liệu có thể gán dãy <code>S[1..N]</code> thỏa
mãn các điều kiện các nhau không?</p>
<h3 id="2-gia-tri-cho-1-bien"><a href="#2-gia-tri-cho-1-bien" class="headerlink" title="2 giá trị cho 1 biến"></a>2 giá trị cho 1 biến</h3><p>Ta có thể coi mảng <code>S[]</code> như một đồ thị <code>N</code> đỉnh. Gộp
các đỉnh cùng giá trị, ta thấy việc gán giá trị 0-1 cho
các đỉnh còn lại giống như tô màu 2 phía.</p>
<p>Như vậy, ta có thể kiểm tra xem đồ thị có phải 2 phía không.</p>
<p>Độ phức tạp sẽ là <code>O(M + N)</code>.</p>
<h3 id="Giam-so-luong-dinh"><a href="#Giam-so-luong-dinh" class="headerlink" title="Giảm số lượng đỉnh"></a>Giảm số lượng đỉnh</h3><p>Có tận <code>10^9</code> đỉnh, tuy nhiên chỉ có <code>10^5</code> cạnh. Vì thế
chỉ có tối đa <code>2 * 10^5</code> đỉnh có bậc khác 0, ta chỉ cần
quan tâm tới các đỉnh này.</p>
<p>Độ phức tạp chỉ còn <code>O(M)</code>, mang lại thuật toán <code>O(M * log(M))</code>.</p>
<h2 id="HANOI-1"><a href="#HANOI-1" class="headerlink" title="HANOI"></a>HANOI</h2><h3 id="Tom-tat-de-bai-4"><a href="#Tom-tat-de-bai-4" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho thuật toán giải bài toán tháp Hà Nội:
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HanoiTower</span><span class="params">(height, From, Temp, To)</span>:</span></div><div class="line">  <span class="keyword">if</span> height == <span class="number">1</span>:</div><div class="line">    <span class="comment"># Move one from `From` to `To`</span></div><div class="line">    <span class="keyword">return</span></div><div class="line">  HanoiTower(height - <span class="number">1</span>, From, To, Temp)</div><div class="line">  HanoiTower(<span class="number">1</span>, From, Temp, To)</div><div class="line">  HanoiTower(height - <span class="number">1</span>, Temp, From, To)</div><div class="line"></div><div class="line"><span class="comment"># Call the function</span></div><div class="line">HanoiTower(N, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>)</div></pre></td></tr></table></figure></p>
<ul>
<li>Tìm trạng thái của 3 tháp sau <code>P</code> lần gọi hàm.</li>
<li>Cho trạng thái của 3 tháp, tính số bước đã gọi hàm
<code>P</code>, hoặc in <code>-1</code> nếu không tồn tại trạng thái đó khi giải.</li>
</ul>
<h4 id="Gioi-han-10"><a href="#Gioi-han-10" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 100</code>. Lưu ý <code>P</code> có thể là số lớn.</p>
<h3 id="Cac-buoc-cua-thuat-toan"><a href="#Cac-buoc-cua-thuat-toan" class="headerlink" title="Các bước của thuật toán"></a>Các bước của thuật toán</h3><p>Ta có thể tóm tắt thuật toán trong 3 bước:</p>
<ul>
<li>Chuyển tháp <code>N - 1</code> từ A sang B dùng C làm đệm</li>
<li>Chuyển đĩa <code>N</code> từ A sang C</li>
<li>Chuyển tháp <code>N - 1</code> từ B sang C dùng A làm đệm</li>
</ul>
<p>Từ thuật toán, ta có thể xác định mình đang ở bước nào
bằng cách xét vị trí của đĩa <code>N</code>.</p>
<ul>
<li>Nếu <code>N</code> còn ở <code>A</code> thì ta ở bước 1.</li>
<li>Nếu không ta ở bước 2 hoặc 3.</li>
</ul>
<p>Sau khi xác định được vị trí của <code>N</code>, ta có thể bỏ nó đi
và đệ quy xuống bước dưới, coi như ta đang giải bài toán
chuyển tháp <code>N - 1</code>.</p>
<h3 id="Tim-trang-thai-tu-P"><a href="#Tim-trang-thai-tu-P" class="headerlink" title="Tìm trạng thái từ P"></a>Tìm trạng thái từ <code>P</code></h3><p>Ta biết để chuyển tháp <code>x</code> sẽ mất <code>2^x - 1</code> bước,
nên khi xét vị trí đĩa <code>N</code> ta có thể xác định xem ta
đang ở bước mấy của việc chuyển tháp <code>N</code>:</p>
<ul>
<li>Nếu <code>P &lt; 2^x</code> thì ta đang ở bước 1.</li>
<li>Nếu <code>P = 2^x</code> thì ta đang ở bước 2.</li>
<li>Nếu <code>P &gt; 2^x</code> thì ta đang ở lượt <code>P - 2^x</code> của bước 3.</li>
</ul>
<p>Tùy theo bước ta xác định vị trí của đĩa <code>N</code> rồi đệ
quy xuống bước tương ứng. Độ phức tạp là <code>O(N)</code>.
Code khá giống bò trên BST.</p>
<h3 id="Tim-P-tu-trang-thai"><a href="#Tim-P-tu-trang-thai" class="headerlink" title="Tìm P từ trạng thái"></a>Tìm <code>P</code> từ trạng thái</h3><p>Việc tìm <code>P</code> không khác gì tìm trạng thái. Khi xét tháp
<code>N</code>, ta kiểm tra xem mình ở bước nào tùy theo vị trí của
đĩa <code>N</code>:</p>
<ul>
<li>Nếu <code>N</code> ở A, thì ta ở bước 1. Đệ quy vào bước 1.</li>
<li>Nếu <code>N</code> ở C, ta ở bước 2 hoặc 3. Cộng <code>P</code> thêm <code>2^x</code> (cho
bước 1+2) rồi đệ quy vào 3.</li>
</ul>
<p>Độ phức tạp cũng là <code>O(N)</code>.</p>
<h2 id="WG-1"><a href="#WG-1" class="headerlink" title="WG"></a>WG</h2><h3 id="Tom-tat-de-bai-5"><a href="#Tom-tat-de-bai-5" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho một xâu <code>P</code> và một tập xâu <code>S[1..N]</code>. Dựng xâu <code>T</code> như sau:</p>
<ul>
<li>Đầu tiên chọn một xâu trong tập <code>S[]</code> và thêm vào <code>T</code></li>
<li>Sau đó, tìm xâu <code>S[i]</code> bất kì thỏa mãn <code>S[0] == T.back()</code> rồi thêm <code>S[i][1..]</code> vào.</li>
</ul>
<p>Hỏi xâu <code>T</code> ngắn nhất chứa dãy con không liên tiếp <code>P</code> là gì?</p>
<h4 id="Gioi-han-11"><a href="#Gioi-han-11" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= |P| &lt;= 250, 1 &lt;= |S[i]| &lt;= 10, 1 &lt;= N &lt;= 1000</code></p>
<h3 id="Tham-lam-dung-xau"><a href="#Tham-lam-dung-xau" class="headerlink" title="Tham lam dựng xâu"></a>Tham lam dựng xâu</h3><p>Khi đã có xâu <code>T</code> có thể lấy ra được dãy con là prefix <code>x</code> của <code>P</code>,
ta có thể xác định số lượng kí tự ghép thêm khi thêm xâu <code>S[i]</code>
bằng cách đi từ trái sang phải, tham lam kí tự tiếp theo cần ghép.</p>
<p>Từ đó ta tính trước được mảng <code>nx[i][j]</code>, khi thêm xâu <code>i</code> với <code>j</code>
kí tự đã ghép thì trạng thái mới là bao nhiêu. Độ phức tạp sẽ là
<code>O(N * |P| * |S[i]|)</code>.</p>
<h3 id="Quy-hoach-dong-1"><a href="#Quy-hoach-dong-1" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Ta có thể quy hoạch động <code>f[i][j]</code> là độ dài xâu <code>T</code> ngắn nhất sao
cho xâu cuối cùng là <code>i</code> và đã ghép được <code>j</code> kí tự đầu tiên của <code>P</code>.
Ta chọn thêm một xâu <code>S[k]</code> mới và chuyển trạng thái sang <code>f[k][nx[k][j]]</code>.
Điều kiện là <code>S[i].back() == S[k][0]</code> và <code>nx[k][j] != j</code>.</p>
<p>Độ phức tạp sẽ là <code>O(N^2 * |P|)</code>, chưa thỏa mãn bài toán.</p>
<h3 id="Ki-tu-cuoi"><a href="#Ki-tu-cuoi" class="headerlink" title="Kí tự cuối"></a>Kí tự cuối</h3><p>Thực chất ta không cần lưu chiều <code>i</code> là xâu cuối cùng, vì ta chỉ
cần quan tâm đến kí tự cuối cùng của <code>T</code>, nên thay vào đó ta có
thể chỉ lưu <code>i</code> là kí tự cuối cùng.</p>
<p>Độ phức tạp giảm xuống còn <code>O(26 * |P| * N)</code>, thỏa mãn bài toán.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Lưu ý&lt;/strong&gt;: Mình đã tóm tắt đề bài ở trên, ai không muốn bị spoil thì đừng
kéo xuống lời giải vội.&lt;/p&gt;
&lt;p&gt;Hôm nay có 5 bài củ
    
    </summary>
    
      <category term="Training" scheme="http://natsukagami.github.io/categories/Training/"/>
    
    
      <category term="training" scheme="http://natsukagami.github.io/tags/training/"/>
    
      <category term="apio" scheme="http://natsukagami.github.io/tags/apio/"/>
    
      <category term="vietnamese" scheme="http://natsukagami.github.io/tags/vietnamese/"/>
    
      <category term="thầy Đông" scheme="http://natsukagami.github.io/tags/thay-Dong/"/>
    
  </entry>
  
  <entry>
    <title>2017/04/19 Training</title>
    <link href="http://natsukagami.github.io/2017/04/19/2017-04-19-Training/"/>
    <id>http://natsukagami.github.io/2017/04/19/2017-04-19-Training/</id>
    <published>2017-04-19T08:00:00.000Z</published>
    <updated>2017-04-23T02:12:50.352Z</updated>
    
    <content type="html"><![CDATA[<p>Thầy Phương cho 3 bài của <a href="http://orac.amt.edu.au/cgi-bin/train/hub.pl?expand=fario17#fario17" target="_blank" rel="external">FARIO 2017</a>. Bài 1 đã làm rồi, bài 3 là bài approximate nên mình chỉ chữa bài 2.</p>
<h2 id="Pyramid-Cake"><a href="#Pyramid-Cake" class="headerlink" title="Pyramid Cake"></a>Pyramid Cake</h2><h3 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho một chiếc hộp có đáy chữ nhật <code>M x N</code>, vị trí <code>(i, j)</code> có độ cao là <code>H[i][j]</code>. Ta dựng một chiếc bánh nhiều tần thỏa mãn:</p>
<ul>
<li>Các tầng là các hình chữ nhật chứa đỉnh <code>(1,1)</code></li>
<li>Tầng trên phải nằm bên trong mặt phẳng của tầng dưới</li>
<li>Không ô nào cao hơn vị trí tương ứng của hộp</li>
<li>Thể tích bánh là lớn nhất.<h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><code>1 &lt;= N, M &lt;= 1000</code>, <code>1 &lt;= H[i][j] &lt;= 10^8</code></li>
</ul>
<h3 id="Lua-chon-tang"><a href="#Lua-chon-tang" class="headerlink" title="Lựa chọn tầng"></a>Lựa chọn tầng</h3><p>Do mọi tầng đề chứa <code>(1, 1)</code>, bản chất ta chỉ cần tọa độ của góc còn lại là có thể xác định được duy nhất tầng hiện tại.</p>
<p>Tại sao ta chỉ cần quan tâm số tầng mà không phải độ cao? Hiển nhiên, với tầng <code>(i, j)</code> ta biết độ cao của tầng đó (nếu tính cả các tầng dưới nó) sẽ là <code>M[i][j] = min(H[i&#39;][j&#39;])</code> với <code>i&#39; &lt;= i, j&#39; &lt;= j</code>.</p>
<p>Khi nén tầng như vậy, ta có thể coi như tầng sau luôn nhỏ hơn tầng dưới, làm cho tập trạng thái không có chu trình và ta có thể quy hoạch động được.</p>
<p>Gọi <code>f[i][j]</code> là diện tích lớn nhất của hình có tầng dưới cùng là <code>(i, j)</code>. Hiển nhiên ta sẽ đặt tầng dưới cùng độ dày <code>M[i][j]</code>. Sau đó, ta chọn một tầng nhỏ hơn để qhđ:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> cur = M[i][j] * i * j; <span class="comment">// Diện tích phần đáy</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i; ++k)</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= j; ++l)</div><div class="line">		<span class="keyword">if</span> (k != i || l != j)</div><div class="line">			f[i][j] = max(f[i][j], cur + f[k][l] - M[i][j] * k * l);</div></pre></td></tr></table></figure>
<p>Tại sao ta trừ đi <code>M[i][j] * k * l</code>? Bởi phần diện tích này đã được tính vào đáy của hình dưới cùng.</p>
<p>Đáp số sẽ là <code>max(f[i][j])</code>, độ phức tạp là <code>O(N^4)</code>, chưa đủ để giải quyết bài toán.</p>
<h3 id="Thu-tat-ca"><a href="#Thu-tat-ca" class="headerlink" title="Thử tất cả?"></a>Thử tất cả?</h3><p>Ta có thể thấy, mỗi hình chữ nhật con đều nhỏ hơn đáy ban đầu ít nhất 1 hàng hoặc 1 cột. Vậy tại sao mình không chọn 1 trong 2 hình to nhất (<code>(i, j - 1)</code> và <code>(i - 1, j)</code>) để làm đáy tiếp theo?</p>
<p>Rất có thể mọi người sẽ nghĩ việc này không đúng vì có thể không điền đc thêm tầng nào - nhưng nếu ta nghĩ theo cách nhìn khác - ta thêm <strong>0</strong> tầng, thì lựa chọn vẫn hợp lí.</p>
<p>Có thể việc này không tối ưu không? Giả sử, lựa chọn <code>(x, y)</code> (<code>x &lt; i, y &lt; j</code>) là tối ưu. Hiển nhiên nó cũng sẽ tối ưu cho <code>(i, j - 1)</code>. Vậy ta hoàn toàn có thể chọn <code>(i, j - 1)</code> và nó sẽ chứa cả <code>(x, y)</code>, kết quả không đổi.</p>
<h3 id="Cai-thien-thuat-toan"><a href="#Cai-thien-thuat-toan" class="headerlink" title="Cải thiện thuật toán"></a>Cải thiện thuật toán</h3><p>Ta rút việc chọn tất cả cặp thành chọn một trong hai hình chữ nhật con lớn nhất. Độ phức tạp giảm xuống còn <code>O(N^2)</code>, thỏa mãn bài toán.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Thầy Phương cho 3 bài của &lt;a href=&quot;http://orac.amt.edu.au/cgi-bin/train/hub.pl?expand=fario17#fario17&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;FAR
    
    </summary>
    
      <category term="Training" scheme="http://natsukagami.github.io/categories/Training/"/>
    
    
      <category term="training" scheme="http://natsukagami.github.io/tags/training/"/>
    
      <category term="apio" scheme="http://natsukagami.github.io/tags/apio/"/>
    
      <category term="vietnamese" scheme="http://natsukagami.github.io/tags/vietnamese/"/>
    
      <category term="thầy Phương" scheme="http://natsukagami.github.io/tags/thay-Phuong/"/>
    
  </entry>
  
  <entry>
    <title>2017/04/18 Training</title>
    <link href="http://natsukagami.github.io/2017/04/18/2017-04-18-Training/"/>
    <id>http://natsukagami.github.io/2017/04/18/2017-04-18-Training/</id>
    <published>2017-04-18T07:22:18.000Z</published>
    <updated>2017-04-23T02:12:58.206Z</updated>
    
    <content type="html"><![CDATA[<p>Hôm nay Hạnh dạy. Nói chung như mọi lần Hạnh dạy, bài thì hay nhưng có vẻ như Hạnh vẫn tốn rất nhiều thời gian giảng bài. Mình thực sự không muốn nghe cho lắm vì vẫn muốn nghĩ bài một mình, sau đó có reference của Hạnh để improve solution thì vẫn thích hơn.</p>
<h2 id="Stretching-Streamers-NAIPC-2017-bai-C"><a href="#Stretching-Streamers-NAIPC-2017-bai-C" class="headerlink" title="Stretching Streamers (NAIPC 2017, bài C)"></a><a href="https://naipc17.kattis.com/problems/naipc17.stretchingstreamers" target="_blank" rel="external">Stretching Streamers (NAIPC 2017, bài C)</a></h2><h3 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Có <code>N</code> điểm viết trên một đường tròn, điểm thứ <code>i</code> chứa số nguyên dương <code>A[i]</code>. 2 số có cạnh đến nhau khi ước chung lớn nhất lớn hơn 1. Không được chọn 2 cạnh đè lên nhau (trừ khi đè ở đầu mút), đếm số cách dựng cây khung <code>N</code> điểm mod <code>1e9 + 7</code>.</p>
<h5 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h5><p><code>3 &lt;= N &lt;= 300</code>, <code>2 &lt;= A[i] &lt;= 10^9</code>.</p>
<h3 id="Dung-cay-nhu-nao"><a href="#Dung-cay-nhu-nao" class="headerlink" title="Dựng cây như nào?"></a>Dựng cây như nào?</h3><p>Đơn giản ta có thể tóm tắt quá trình dựng cây như sau:</p>
<ul>
<li>Đầu tiên chọn đỉnh <code>1</code> làm gốc.</li>
<li>Từ đỉnh <code>1</code> chọn một tập đỉnh <code>X[1..M]</code> là con của đỉnh <code>1</code>. Hiển nhiên 1 phải có cạnh đến tất cả các đỉnh trong tập.</li>
<li>Mỗi đỉnh <code>X[i]</code> quản lí 1 đoạn <code>L[i] &lt;= X[i] &lt;= R[i]</code> sao cho <code>L[1] = 2</code>; <code>R[i] + 1 = L[i + 1]</code> và <code>R[M] = N</code>. (1)</li>
<li><p>Ta dựng cây cho mỗi đoạn <code>L[i]..R[i]</code>, với điều kiện không có cạnh <code>(x, y)</code> với <code>x &lt;= X[i] &lt;= y</code>. Để tính cái này ta làm tương đương, đệ quy xuống.</p>
<p>Tại sao lại có (1)? Đơn giản vì không thể tồn tại cạnh sao cho 2 đỉnh nằm 2 bên của một <code>X[i]</code> nào đó, vì chúng sẽ cắt qua cạnh <code>(1, X[i])</code>.</p>
</li>
</ul>
<h3 id="Bien-doi-doan-L-i-R-i"><a href="#Bien-doi-doan-L-i-R-i" class="headerlink" title="Biến đổi đoạn L[i]..R[i]."></a>Biến đổi đoạn <code>L[i]..R[i]</code>.</h3><p>Do có điều kiện không có cạnh <code>(x, y)</code> mà <code>x &lt;= X[i] &lt;= y</code> nên ta có thể chia đoạn <code>L[i]..R[i]</code> thành 2 đoạn <code>L[i]..X[i]</code> và <code>X[i]..R[i]</code> độc lập mà vẫn không thay đổi kết quả bài toán.</p>
<p>Khi đó, điều kiện đặc biệt biến mất và ta chỉ cần đệ quy xuống với các đoạn <code>L[1]..X[1]</code>, <code>X[1]..R[1]</code>, <code>L[2]..X[2]</code>, …, <code>X[M]..R[M]</code>.</p>
<h3 id="Cong-thuc-quy-hoach-dong"><a href="#Cong-thuc-quy-hoach-dong" class="headerlink" title="Công thức quy hoạch động"></a>Công thức quy hoạch động</h3><p>Từ các nhận xét trên, ta có công thức quy hoạch động sau:</p>
<p>Gọi <code>f[l][r]</code> là số cách dựng cây với các đỉnh thuộc đoạn <code>l..r</code>. Hiển nhiên <code>f[i][i] = 1</code>.</p>
<p>Ta có
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = l + <span class="number">1</span>; k &lt;= r; ++k)</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> st = l + <span class="number">1</span>; st &lt;= k; ++st)</div><div class="line">    f[l][r] += f[l][st - <span class="number">1</span>] * f[st][k] * f[k][r];</div></pre></td></tr></table></figure></p>
<p>Việc chọn tập <code>X[]</code> cho <code>[l..r]</code> giống với việc từ đoạn <code>[l..st - 1]</code> đã dựng cây, ta thêm đoạn <code>[st..r]</code> bằng cách nối <code>(l, k)</code> (<code>st &lt;= k &lt;= r</code>) rồi dựng 2 cây như trên. Do đó công thức qhđ này hoàn toàn chính xác. Đáp số sẽ là <code>f[1][N]</code>. Tuy nhiên độ phức tạp là <code>O(N^4)</code>, chưa đủ để thỏa mãn đề bài.</p>
<h3 id="Toi-uu-xuong-O-N-3"><a href="#Toi-uu-xuong-O-N-3" class="headerlink" title="Tối ưu xuống O(N^3)"></a>Tối ưu xuống <code>O(N^3)</code></h3><p>Việc chọn đoạn yêu cầu 2 bước, xác định <code>X[i]</code> và đoạn <code>st..r</code>. Liệu ta có thể giảm thiểu số cách lựa chọn không?</p>
<p>Thực chất ta hoàn toàn có thể tách 2 bước này thành 2 công đoạn chọn đoạn, đầu tiên chọn <code>st..X[i]</code> thỏa mãn có cạnh <code>(l, X[i])</code> và chọn đoạn <code>X[i]..r</code>. Như vậy ta có thể chọn 2 đoạn so le, mỗi lần chuyển trạng thái chỉ mất <code>O(N)</code>.</p>
<p>Ta sửa lại công thức qhđ thành <code>f[i][j][k]</code>, thêm <code>k</code> là bước hiện tại của chúng ta (<code>0</code> - chọn nửa đoạn đầu - hay <code>1</code> - đã chọn xong). Công thức trở thành:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = l + <span class="number">1</span>; k &lt;= r; ++k) &#123;</div><div class="line">  <span class="keyword">if</span> (__gcd(l, r) &gt; <span class="number">1</span>) <span class="comment">// có cạnh từ l đến k</span></div><div class="line">    f[l][r][<span class="number">0</span>] += f[l][k - <span class="number">1</span>][<span class="number">1</span>] * f[k][r][<span class="number">1</span>];</div><div class="line">  <span class="keyword">if</span> (__gcd(l, k) &gt; <span class="number">1</span>)</div><div class="line">    f[l][r][<span class="number">1</span>] += f[l][k][<span class="number">0</span>] * f[k][r][<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Lúc đầu <code>f[i][i][x] = x</code> và đáp số sẽ là <code>f[1][N][1]</code>. Độ phức tạp là <code>O(N^3)</code>.</p>
<h2 id="LISA-RCC-2017-1st-Qualification-Round-bai-E"><a href="#LISA-RCC-2017-1st-Qualification-Round-bai-E" class="headerlink" title="LISA - RCC 2017 1st Qualification Round, bài E"></a><a href="http://www.russiancodecup.ru/en/tasks/round/61/E/" target="_blank" rel="external">LISA - RCC 2017 1st Qualification Round, bài E</a></h2><h3 id="Tom-tat-de-bai-1"><a href="#Tom-tat-de-bai-1" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho <code>N</code> xâu và <code>Q</code> truy vấn. Mỗi truy vấn gồm 2 số <code>l, r</code> và yêu cầu trả lời số xâu khác nhau có thể tạo được bằng cách ghép 1 tiền tố khác rỗng với 1 hậu tố khác rỗng của xâu nào đó trong khoảng từ <code>l</code> đến <code>r</code>.</p>
<h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N, Q &lt;= 10^5</code>. Tổng độ dài xâu không quá <code>10^5</code>.</p>
<h3 id="Ghep-tien-to-va-hau-to"><a href="#Ghep-tien-to-va-hau-to" class="headerlink" title="Ghép tiền tố và hậu tố"></a>Ghép tiền tố và hậu tố</h3><p>Ta có thể thấy ngay nếu không có điều kiện “khác nhau”, đáp số chỉ là <code>(số tiền tố trong đoạn) * (số hậu tố trong đoạn)</code>. Tuy nhiên có 2 vấn đề sau xảy ra khi ta cần tìm những xâu khác nhau:</p>
<ul>
<li>Có thể tồn tại cặp tiền tố giống nhau - đây là phần dễ.</li>
<li>Tồn tại 2 cặp tiền tố - hậu tố khác nhau nhưng cho ra xâu ghép giống nhau.</li>
</ul>
<h3 id="Dieu-kien-dem"><a href="#Dieu-kien-dem" class="headerlink" title="Điều kiện đếm"></a>Điều kiện đếm</h3><p>Một trong những kĩ thuật tiêu biểu khi đếm để xử lí lặp là đặt thêm điều kiện cho bài toán sao cho chúng khử đi các trường hợp lặp.</p>
<p>Giả sử ta có 2 xâu <code>Pre[i]</code> và <code>Suf[j]</code>, ta có <code>X = Pre[i] + Suf[j]</code>. Vậy nếu tồn tại một cặp khác <code>X = Pre[k] + Suf[l]</code> thì ta có tính chất gì?</p>
<p>Không mất tính tổng quát, giả sử <code>|Pre[i]| &lt; |Pre[k]|</code>. Ta có thể thấy phần <em>thừa ra</em> của <code>Pre[k]</code> chính bằng phần <em>thừa ra</em> của <code>Suf[j]</code>.
Như vậy, một cách nghĩ có thể là loại bỏ tất cả việc ghép của các xâu <code>Suf[l]</code> khi đã tồn tại một <em>phần thừa chung</em> như trên.</p>
<p>Bởi vì ta đã lấy ra tất cả tiền tố, nên nếu tồn tại 2 cặp xâu như trên thì sẽ luôn tồn tại <code>X = (Pre[i] + c) + (Suf[j][1..])</code>, trong đó <code>c</code> là chữ cái đầu tiên của <code>Suf[j]</code>, và <code>Pre[i] + c</code> cũng là 1 tiền tố (vì nó là tiền tố của <code>Pre[k]</code>). Như vậy, luôn tồn tại các cặp chỉ lệch nhau 1 kí tự - và ta chỉ cần đặt thêm điều kiện để khử trường hợp lệch 1 kí tự là đủ.</p>
<h3 id="Ki-tu-thua"><a href="#Ki-tu-thua" class="headerlink" title="Kí tự thừa"></a>Kí tự <em>thừa</em></h3><p>Xét trường hợp <code>X = (Pre[i] + c) + (Suf[j][1..])</code>. Ta có thể thêm vào điều kiện sau:
Xét <code>Suf[j]</code>, nếu <code>c + Suf[j]</code> cũng là một hậu tố trong tập, thì ta <strong>không được</strong> ghép <code>Suf[j]</code> với <code>Pre[i&#39;] = Pre[i] + c</code>.</p>
<p>Dễ dàng chứng minh tất cả xâu cần tìm đều tồn tại cách ghép <em>duy nhất</em> thỏa mãn điều kiện.</p>
<p>Lưu ý <code>Pre[i&#39;]</code> phải là <code>Pre[i] + c</code>, tức phải có ít nhất 2 kí tự.</p>
<p>Ta gọi các xâu <code>c + Suf[j]</code> không thuộc tập hậu tố là xâu <em>kí tự thừa</em> <code>c</code>.</p>
<h3 id="Dem-nhu-the-nao"><a href="#Dem-nhu-the-nao" class="headerlink" title="Đếm như thế nào?"></a>Đếm như thế nào?</h3><p>Với điều kiện trên, lời giải của ta sẽ gồm các bước:</p>
<ul>
<li>Đếm số tiền tố khác nhau kết thúc ở <code>c</code>.</li>
<li>Đếm số xâu <em>kí tự thừa</em> <code>c</code>, nhân với số tiền tố đã tìm được ở trên.</li>
<li>Với mỗi hậu tố, kiểm tra xem liệu ta có thể tạo được hậu tố bằng cách ghép 1 kí tự đầu tiên từ 1 tiền tố nào đó với các kí tự còn lại của hậu tố. Vốn dĩ việc này là cần thiết bởi vì đây là trường hợp duy nhất mà 1 xâu có thể được tạo từ một hậu tố không có kí tự thừa, và không được xét ở trường hợp trên.</li>
</ul>
<h3 id="So-tien-to-khac-nhau"><a href="#So-tien-to-khac-nhau" class="headerlink" title="Số tiền tố khác nhau"></a>Số tiền tố khác nhau</h3><p>Trước tiên ta sort lại các truy vấn theo <code>R[i]</code> và xử lí offline.</p>
<p>Lần lượt thêm các tiền tố vào Trie (chống lặp), đồng thời lưu lại với mỗi nút lần cuối cùng nó xuất hiện.</p>
<p>Giả sử ta đang ở truy vấn <code>L[i], R[i]</code> và đã thêm tất cả các tiền tố của <code>S[i]..S[R[i]]</code>. Không khó để nhìn ra số lượng tiền tố khác nhau chính là số nút mà lần xuất hiện cuối cùng <code>&gt;= L[i]</code>. Ta có thể dùng IT hoặc BIT làm công cụ đếm phân phối số nút xuất hiện ở từng thời điểm và tính tổng nhanh.</p>
<p>Để có thể tính số tiền tố xuất hiện mà kết thúc với kí tự <code>c</code> cụ thể, ta có thể dùng 26 IT / BIT thay vì 1, với mỗi loại tiền tố ta có 1 cây đếm phân phối riêng.</p>
<p>Độ phức tạp mỗi truy vấn là <code>O(26 * log(N))</code>.</p>
<h3 id="So-hau-to-voi-ki-tu-thua"><a href="#So-hau-to-voi-ki-tu-thua" class="headerlink" title="Số hậu tố với kí tự thừa"></a>Số hậu tố với <em>kí tự thừa</em></h3><p>Trước tiên, vì bản chất xâu thừa chính là <code>c + Suf[i]</code> nên sẽ có <code>(số tiền tố khác nhau)</code> xâu như vậy (với 1 kí tự <code>c</code>). Tuy nhiên ta phải trừ đi các xâu cũng là hậu tố - chính là số hậu tố bắt đầu với <code>c</code> mà có trên 1 kí tự. Để đếm số lượng xâu bị tính thừa ta có thể lật ngược xâu, biến hậu tố thành tiền tố và đếm như phần trên.</p>
<p>Phần này ta cũng làm <code>O(26 * log(N))</code> mỗi truy vấn.</p>
<h3 id="Cac-hau-to-cong-them"><a href="#Cac-hau-to-cong-them" class="headerlink" title="Các hậu tố cộng thêm"></a>Các hậu tố cộng thêm</h3><p>Phần này khá đơn giản, với mỗi hậu tố bắt đầu với kí tự <code>c</code> ta có thể kiểm tra có tồn lại hậu tố <code>Pre[i] = c</code> nào không. Ta có thể làm kèm với thao tác đếm ở trên.</p>
<h3 id="Tong-ket"><a href="#Tong-ket" class="headerlink" title="Tổng kết"></a>Tổng kết</h3><p>Với <code>Q</code> truy vấn, độ phức tạp sẽ là <code>O(Q * 26 * log(N))</code>, nên cẩn thận 1 chút ở phần cài đặt nếu không có thể sẽ bị TLE vì cài ẩu.</p>
<h2 id="Electric-Charges-AIM-Tech-Round-Div-1"><a href="#Electric-Charges-AIM-Tech-Round-Div-1" class="headerlink" title="Electric Charges - AIM Tech Round (Div. 1)"></a><a href="http://codeforces.com/contest/623/problem/C" target="_blank" rel="external">Electric Charges - AIM Tech Round (Div. 1)</a></h2><h3 id="Tom-tat-de-bai-2"><a href="#Tom-tat-de-bai-2" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho <code>N</code> điểm trên mặt phẳng. Gióng chúng xuống trục Ox hoặc Oy sao cho khoảng cách giữa 2 điểm gióng xuống xa nhất là nhỏ nhất có thể.</p>
<h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 10^5</code>, <code>-10^8 &lt;= X[i], Y[i] &lt;= 10^8</code></p>
<h3 id="Chat-nhi-phan"><a href="#Chat-nhi-phan" class="headerlink" title="Chặt nhị phân"></a>Chặt nhị phân</h3><p>Trong bài này ta sử dụng chặt nhị phân, một cách thông dụng để giải các bài min-của-max. Bài toán trở thành: tìm một cách xếp sao cho khoảng cách không quá <code>X</code>?</p>
<h3 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT??"></a>2-SAT??</h3><p>Tuấn nghĩ ra thuật 2-SAT… Có thể AC nhũng chẳng hay chút nào :D Hiển nhiên một bài C div 1 không thể tốn nhiều thời gian code như thế… Đây không phải round của amd.</p>
<h3 id="Chon-mot-moc"><a href="#Chon-mot-moc" class="headerlink" title="Chọn một mốc"></a>Chọn một mốc</h3><p>Tóm lại ta phải tối ưu max của 3 cái sau:</p>
<ul>
<li><code>(minX - maxX)^2</code></li>
<li><code>(minY - maxY)^2</code></li>
<li><code>max(minX^2, maxX^2) + max(minY^2, maxY^2)</code>
Ý tưởng đầu tiên sẽ là for một biến, giả sử <code>minX</code>, và tham lam các biến còn lại.</li>
</ul>
<p>Khi có <code>minX</code>, ta tính được <code>maxX</code>. Hiển nhiên các điểm có <code>X[i] &lt; minX</code> hoặc <code>X[i] &gt; maxX</code> đều phải chọn sang <code>Y</code>. Ta chỉ cần lấy min và max của các <code>Y[i]</code> đó, so sánh. Bài toán đơn giản?</p>
<p>Thuật toán sai rồi. Rất có thể <code>maxX^2</code> &gt; <code>minX^2</code> và sẽ làm cho thuật toán bị ảo tưởng.</p>
<h3 id="Chon-mot-diem"><a href="#Chon-mot-diem" class="headerlink" title="Chọn một điểm"></a>Chọn một điểm</h3><p>Thay vì chọn 1 mốc như <code>minX</code>, ta chọn một điểm và coi nó là <code>minX</code>, đồng thời là điểm có <code>abs(X[i])</code> lớn nhất được chọn làm <code>X</code>. Khi đó ta có thể yên tâm bốc các điểm nằm ngoài khoảng giới hạn đó là <code>Y</code> và chỉ cần kiểm tra các khoảng cách còn lại.</p>
<h3 id="Tinh-cac-Y-nhu-nao"><a href="#Tinh-cac-Y-nhu-nao" class="headerlink" title="Tính các Y như nào?"></a>Tính các <code>Y</code> như nào?</h3><p>Tóm lại ta cần tính nhanh minY và maxY ở khoảng các điểm có <code>X &lt; L</code> và <code>X &gt; R</code> với <code>L, R</code> bất kì. Ta có thể sort lại các điểm theo tọa độ của <code>X</code>, sau đó xây các mảng dồn min, max để lấy nhanh prefix và suffix.</p>
<p>Xây mất <code>O(N log(N))</code> (sắp xếp) và truy vấn <code>O(1)</code>.</p>
<h3 id="Lat-leo"><a href="#Lat-leo" class="headerlink" title="Lắt léo"></a>Lắt léo</h3><p>Còn một trường hợp nữa ta chưa xét đến: chọn tất cả theo trục Y. Trường hợp này không khó, check <code>(maxY - minY) ^ 2</code> là xong. Tuy vậy mình không nghĩ ra trước khi nộp :(</p>
<h3 id="Tong-ket-1"><a href="#Tong-ket-1" class="headerlink" title="Tổng kết"></a>Tổng kết</h3><p>Tóm lại ta cần chặt nhị phân, khi kiểm tra cần chạy con trỏ hoặc lấy lower/upper bound. Việc chạy con trỏ khá lằng nhằng không cần thiết nên mình không code. Độ phức tạp là <code>(O(N * log(N) * log(10^17)))</code> hoặc <code>O(N * log(10^17))</code>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hôm nay Hạnh dạy. Nói chung như mọi lần Hạnh dạy, bài thì hay nhưng có vẻ như Hạnh vẫn tốn rất nhiều thời gian giảng bài. Mình thực sự kh
    
    </summary>
    
      <category term="Training" scheme="http://natsukagami.github.io/categories/Training/"/>
    
    
      <category term="training" scheme="http://natsukagami.github.io/tags/training/"/>
    
      <category term="apio" scheme="http://natsukagami.github.io/tags/apio/"/>
    
      <category term="vietnamese" scheme="http://natsukagami.github.io/tags/vietnamese/"/>
    
      <category term="anh Hạnh" scheme="http://natsukagami.github.io/tags/anh-Hanh/"/>
    
  </entry>
  
  <entry>
    <title>2017/04/15 Training</title>
    <link href="http://natsukagami.github.io/2017/04/16/2017-04-15-Training/"/>
    <id>http://natsukagami.github.io/2017/04/16/2017-04-15-Training/</id>
    <published>2017-04-16T05:34:00.000Z</published>
    <updated>2017-04-23T02:13:11.496Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Warning</strong>: If you want to try solving the problems, skip reading everything but the statements! Also, for hints, read <em>slowly</em> from top to bottom of each problem.</p>
<p>I didn’t attend the class directly, but did the problems while going on a bus to Ninh Binh. The problems were somewhat exciting to me.</p>
<h2 id="A-Sorting"><a href="#A-Sorting" class="headerlink" title="A. Sorting"></a>A. Sorting</h2><h3 id="Statements"><a href="#Statements" class="headerlink" title="Statements"></a>Statements</h3><p>You are given a permutation <code>A[1..N]</code>, along with <code>Q</code> queries, each of the form <code>l, r</code> which you should sort the subarray <code>A[l..r]</code> increasingly or decreasingly. After all the queries are processed, print the middle value <code>A[N / 2 + 1]</code>.</p>
<h4 id="Contraints"><a href="#Contraints" class="headerlink" title="Contraints"></a>Contraints</h4><p><code>1 &lt;= N &lt;= 10^5</code>, <code>1 &lt;= Q &lt;= 10^5</code>, <code>N</code> is odd.</p>
<h3 id="One-problem-from-the-past"><a href="#One-problem-from-the-past" class="headerlink" title="One problem from the past"></a>One problem from the past</h3><p>The statements reminds me of a past problem I did on Codeforces. I didn’t remember the source, but in short you are given a Latin string with the same sorting queries, and then you have to return the whole string. It was feasible to solve the problem in <code>O(Q * 26 * log(N))</code> time because of the limited alphabet size.</p>
<p>The main idea is, for each <code>l, r</code> query, count the number of instances of each character in the range. Then we can re-assign the characters’ positions, from the smallest to the largest. To efficiently do range-counting and range-assignments we can maintain 26 <em>interval trees</em>, with lazy update.</p>
<p>However, the problem I faced yesterday was different: the alphabet size is much bigger. Perhaps a different approach was needed. Or maybe not?</p>
<h3 id="The-alphabet-size"><a href="#The-alphabet-size" class="headerlink" title="The alphabet size"></a>The alphabet size</h3><p>From the previous problem, we know that the problem can be solved efficiently if the alphabet size was small. “Is there anyway to make the numbers pool smaller?” - that was the first question that came to my mind.</p>
<p>The above problem somewhat resembles radix sorting, so of course it can also be applied to numbers. However splitting digits is not eligible, as reordering still takes too much time. We need to transform numbers into something that’s both small in size and easy to reassign, maybe not even caring about its original value.</p>
<p>The problem only asked for <strong>one</strong> element. What if, all we care about is the element itself?</p>
<h3 id="Relative-ordering"><a href="#Relative-ordering" class="headerlink" title="Relative ordering"></a>Relative ordering</h3><p>It turns out that we don’t actually need to sort the elements. Not entirely.</p>
<p>Let’s choose a pivot, <code>X</code>. We transform every number larger than <code>X</code> to <code>1</code>, and the rest to <code>0</code>. Sorting becomes wrong now, but the order <em>relative to <code>X</code></em> isn’t: If we sort <code>l, r</code> increasingly, every number that’s smaller than <code>X</code> still stays on the left of those which are larger than <code>X</code>. Therefore, this <em>masked</em> ordering isn’t entirely wrong, because the correct ordering <strong>have the same mask</strong>, and we can assume that the unlerlying original values are on the correct positions. Of course, we don’t need to care about it.</p>
<p>Of course, since the numbers are binary now, performing the above algorithm becomes a breeze.</p>
<p>After all the sortings, we get the middle number’s mask. It doesn’t give us the answer immediately, but it does leave a hint: If the number is <strong>1</strong> then the answer is <strong>larger than <code>X</code></strong>, and vice versa.</p>
<h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h3><p>To effectively use the previous hint, we can perform <em>binary search</em> on the value of <code>A[N / 2 + 1]</code>, checking whether it’s larger than the middle value, and shorten the range according to the answer.
That is also the final missing piece to solve the problem, giving us an <code>O(log(N) * Q * log(N))</code> algorithm.</p>
<h2 id="B-Zigzag"><a href="#B-Zigzag" class="headerlink" title="B. Zigzag"></a>B. Zigzag</h2><h3 id="Statements-1"><a href="#Statements-1" class="headerlink" title="Statements"></a>Statements</h3><p>You are given an array <code>A[1..N]</code> of distinct numbers. There are also <code>Q</code> queries, each of the form <code>x y</code> that asks you to change the <code>x</code>-th number to <code>y</code>. It is guaranteed that after each query the array always contains dintinct numbers. After each query you have to return the largest alternating subsequence of the array.</p>
<h4 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h4><p><code>1 &lt;= N &lt;= 10^6</code>, <code>1 &lt;= A[i] &lt;= 10^9</code></p>
<h3 id="Alternating-Subsequence"><a href="#Alternating-Subsequence" class="headerlink" title="Alternating Subsequence"></a>Alternating Subsequence</h3><p>The first thing to do is analyzing the <strong>longest alternating subsequence</strong> problem. It turns out that it is not as difficult as it sounds, in fact it can be greedily built from an array with distinct numbers.</p>
<p>One nice observation from the problem: If there exists such <code>i</code> that <code>A[i - 1] &lt;= A[i] &lt;= A[i + 1]</code>, then there always exists an optimal subsequence without <code>A[i]</code>. Why? Since they’re consecutive numbers, <code>A[i - 1]</code> is always better than <code>A[i]</code> as a “lower” number, and <code>A[i + 1]</code> is always better than <code>A[i]</code> as an “upper” numbber. Therefore, it is safe to just remove <code>A[i]</code> from the array without losing the optimal sequence.</p>
<p>Now let’s continuously remove such numbers from the array until there is no such one. Which means, for each <code>i</code>, it is either <code>A[i - 1] &lt;= A[i] &amp;&amp; A[i] &gt;= A[i + 1]</code> or <code>A[i - 1] &gt;= A[i] &amp;&amp; A[i] &lt;= A[i + 1]</code>. Wait… Isn’t <code>A[..]</code> now already an alternating sequence? More than that, <code>A[..]</code> is an <strong>optimal</strong> longest alternating subsequence of the original array.</p>
<p>Dive a little deeper, we will find out that each <code>A[i]</code> can be a part of the new array <strong>if and only if</strong> has the same above atrribute on the original array. <em>Unless</em> it’s the first or last number of the array, in such case it’s always included.</p>
<h3 id="Testing-an-element"><a href="#Testing-an-element" class="headerlink" title="Testing an element"></a>Testing an element</h3><p>With the above observations, we can deduce whether an element will appear in our optimal subsequence:</p>
<ul>
<li>It’s the first or last element, <em>or</em></li>
<li>Either it’s both smaller or both bigger than its neighboring elements.</li>
</ul>
<p>Using these conditions we can check each element in <code>O(1)</code>. To answer the length of the optimal subsequence one only has to count how many elements satisfies the above conditions.</p>
<h3 id="Processing-queries"><a href="#Processing-queries" class="headerlink" title="Processing queries"></a>Processing queries</h3><p>If we change one number, how is each element’s satisfiability affected? It turns out, only 3 of them are affected at most: the element itself, and its neighboring elements.</p>
<p>It is now easy to process each query in <code>O(1)</code>: just change the element and re-check every affected elements.</p>
<p>That concludes our <code>O(N + M)</code> algorithm.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: If you want to try solving the problems, skip reading everything but the statements! Also, for hints, read &lt;em&gt;
    
    </summary>
    
      <category term="Training" scheme="http://natsukagami.github.io/categories/Training/"/>
    
    
      <category term="training" scheme="http://natsukagami.github.io/tags/training/"/>
    
      <category term="apio" scheme="http://natsukagami.github.io/tags/apio/"/>
    
      <category term="english" scheme="http://natsukagami.github.io/tags/english/"/>
    
      <category term="anh Minh" scheme="http://natsukagami.github.io/tags/anh-Minh/"/>
    
  </entry>
  
  <entry>
    <title>First Post</title>
    <link href="http://natsukagami.github.io/2016/10/10/First-Post/"/>
    <id>http://natsukagami.github.io/2016/10/10/First-Post/</id>
    <published>2016-10-10T06:10:19.000Z</published>
    <updated>2016-10-10T06:10:19.757Z</updated>
    
    <content type="html"><![CDATA[<p>I started a blog, yay! 
The purpose of this blog will be for me to express random thoughts, coding experiences and to show everyone my work. 
That’s all. Thank you for reading my first post!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I started a blog, yay! 
The purpose of this blog will be for me to express random thoughts, coding experiences and to show everyone my wo
    
    </summary>
    
      <category term="Thoughts" scheme="http://natsukagami.github.io/categories/Thoughts/"/>
    
    
      <category term="First Post" scheme="http://natsukagami.github.io/tags/First-Post/"/>
    
  </entry>
  
</feed>
