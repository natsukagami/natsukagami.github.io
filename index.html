<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Kagami&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Some random stuff I write to express my life.">
<meta property="og:type" content="website">
<meta property="og:title" content="Kagami's Blog">
<meta property="og:url" content="http://natsukagami.github.io/index.html">
<meta property="og:site_name" content="Kagami's Blog">
<meta property="og:description" content="Some random stuff I write to express my life.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kagami's Blog">
<meta name="twitter:description" content="Some random stuff I write to express my life.">
  
    <link rel="alternate" href="/atom.xml" title="Kagami&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>
  <script type="text/javascript">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'] ],
        displayMath: [ ['$$','$$'] ],
        processEscape: true
      }
    }); 
  </script>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Kagami&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">IOI Medalist, osu! lover, I tryhard everything.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://natsukagami.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2017-04-20-Training" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/21/2017-04-20-Training/" class="article-date">
  <time datetime="2017-04-21T11:36:25.000Z" itemprop="datePublished">2017-04-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Training/">Training</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/21/2017-04-20-Training/">2017/04/20 Training</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Lưu ý</strong>: Mình đã tóm tắt đề bài ở trên, ai không muốn bị spoil thì đừng
kéo xuống lời giải vội.</p>
<p>Hôm nay có 5 bài của thầy Đông. Do mình không được nghe thầy chữa buổi chiều nên solution là của mình, mặc dù 99% là đúng nhưng không đảm bảo.
Thực chất bài không phải là khó quá.</p>
<h1 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h1><h2 id="ACM"><a href="#ACM" class="headerlink" title="ACM"></a>ACM</h2><p>Có <code>N</code> đội, mỗi đội có 11 chỉ số <code>A[i][1..11]</code>. Chọn 3 đội sao cho <code>sum[i = 1..11][max(A[x, y, z][i])]</code> (tổng của max chỉ số từng loại của 3 đội) là lớn nhất.</p>
<h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 30000</code></p>
<h2 id="DOMINO-Bai-toan-thu-nhat"><a href="#DOMINO-Bai-toan-thu-nhat" class="headerlink" title="DOMINO (Bài toán thứ nhất)"></a>DOMINO (Bài toán thứ nhất)</h2><p>Cho một bảng <code>M x N</code> với <code>K</code> ô cấm.
Điền 0 hoặc 1 vào các ô không bị cấm sao cho
với ô <code>(i, j)</code>:</p>
<ul>
<li>Nếu <code>i + j</code> lẻ, thì ô <code>(i, j)</code> không nhỏ
hơn các ô không bị cấm xung quanh.</li>
<li>Nếu <code>i + j</code> chẵn, thì <code>(i, j)</code> không lớn
hơn các ô không bị cấm xung quanh.</li>
</ul>
<h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= M, N &lt;= 16</code></p>
<h2 id="DOMINO-Bai-toan-thu-hai"><a href="#DOMINO-Bai-toan-thu-hai" class="headerlink" title="DOMINO (Bài toán thứ hai)"></a>DOMINO (Bài toán thứ hai)</h2><p>Lần này không có ô cấm. Điều kiện như bài toán thứ nhất.</p>
<h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 8</code>, <code>1 &lt;= M &lt;= 10^6</code></p>
<h2 id="GAMES"><a href="#GAMES" class="headerlink" title="GAMES"></a>GAMES</h2><p>Cho một dãy bit <code>N</code> phần tử chưa xác định
 và <code>M</code> điều kiện có dạng
xor của <code>A[l..r]</code> là 0 hay 1. Tìm vị trí <code>x</code> đầu tiên
mà điều kiện <code>x</code> mâu thuẫn với các điều kiện trên.</p>
<h4 id="Gioi-han-3"><a href="#Gioi-han-3" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 10^9</code>, <code>1 &lt;= M &lt;= 10^5</code></p>
<h2 id="HANOI"><a href="#HANOI" class="headerlink" title="HANOI"></a>HANOI</h2><p>Cho thuật toán giải bài toán tháp Hà Nội:
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HanoiTower</span><span class="params">(height, From, Temp, To)</span>:</span></div><div class="line">  <span class="keyword">if</span> height == <span class="number">1</span>:</div><div class="line">    <span class="comment"># Move one from `From` to `To`</span></div><div class="line">    <span class="keyword">return</span></div><div class="line">  HanoiTower(height - <span class="number">1</span>, From, To, Temp)</div><div class="line">  HanoiTower(<span class="number">1</span>, From, Temp, To)</div><div class="line">  HanoiTower(height - <span class="number">1</span>, Temp, From, To)</div><div class="line"></div><div class="line"><span class="comment"># Call the function</span></div><div class="line">HanoiTower(N, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>)</div></pre></td></tr></table></figure></p>
<ul>
<li>Tìm trạng thái của 3 tháp sau <code>P</code> lần gọi hàm.</li>
<li>Cho trạng thái của 3 tháp, tính số bước đã gọi hàm
<code>P</code>, hoặc in <code>-1</code> nếu không tồn tại trạng thái đó khi giải.</li>
</ul>
<h4 id="Gioi-han-4"><a href="#Gioi-han-4" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 100</code>. Lưu ý <code>P</code> có thể là số lớn.</p>
<h2 id="WG"><a href="#WG" class="headerlink" title="WG"></a>WG</h2><p>Cho một xâu <code>P</code> và một tập xâu <code>S[1..N]</code>. Dựng xâu <code>T</code> như sau:</p>
<ul>
<li>Đầu tiên chọn một xâu trong tập <code>S[]</code> và thêm vào <code>T</code></li>
<li>Sau đó, tìm xâu <code>S[i]</code> bất kì thỏa mãn <code>S[0] == T.back()</code> rồi thêm <code>S[i][1..]</code> vào.</li>
</ul>
<p>Hỏi xâu <code>T</code> ngắn nhất chứa dãy con không liên tiếp <code>P</code> là gì?</p>
<h4 id="Gioi-han-5"><a href="#Gioi-han-5" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= |P| &lt;= 250, 1 &lt;= |S[i]| &lt;= 10, 1 &lt;= N &lt;= 1000</code></p>
<h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="ACM-1"><a href="#ACM-1" class="headerlink" title="ACM"></a>ACM</h2><h3 id="Tom-tat-de-bai-1"><a href="#Tom-tat-de-bai-1" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Có <code>N</code> đội, mỗi đội có 11 chỉ số <code>A[i][1..11]</code>. Chọn 3 đội sao cho <code>sum[i = 1..11][max(A[x, y, z][i])]</code> (tổng của max chỉ số từng loại của 3 đội) là lớn nhất.</p>
<h4 id="Gioi-han-6"><a href="#Gioi-han-6" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 30000</code></p>
<h3 id="“Phuc-tap-hoa”-bai-toan"><a href="#“Phuc-tap-hoa”-bai-toan" class="headerlink" title="“Phức tạp hóa” bài toán"></a>“Phức tạp hóa” bài toán</h3><p>Rất khó để thực hiện việc chọn
nếu mình sử dụng việc lấy max của
từng chỉ số. Vì thế ta có thể
thay đổi bài toán thành <strong>chọn 3 đội
rồi mỗi chỉ số lấy của một đội</strong>.
Ta có thể thấy khi có quản lí đơn giản hơn:
chỉ cần mỗi đội một bitmask lựa chọn chỉ số.</p>
<p>Hiển nhiên khi đã xét tất cả trường hợp
thì trường hợp tốt nhất luôn là lấy max.</p>
<h3 id="Ghep-bitmask"><a href="#Ghep-bitmask" class="headerlink" title="Ghép bitmask"></a>Ghép bitmask</h3><p>Giả sử ta đã chọn 3 đội <code>i</code>, <code>j</code> và <code>k</code>.
Ta sẽ gán lần lượt 3 mask <code>x</code>, <code>y</code>, <code>z</code> cho 3 đội
này. Các mask sẽ thỏa mãn:</p>
<ul>
<li>Đôi một rời rạc (<code>x &amp; y == 0</code>, <code>y &amp; z == 0</code>, <code>z &amp; x == 0</code>)</li>
<li>Ghép lại thì có đầy đủ (<code>x | y | z == (1 &lt;&lt; 11) - 1</code>)</li>
<li>Tổng chỉ số tương ứng lớn nhất.</li>
</ul>
<p>Ta có thể thấy, thực chất ta không cần quan tâm
các đội được chọn là đội nào.
Với mask <code>x</code> được chọn trước, ta chỉ cần tính xem
trong các đội thì đội nào có tổng tương ứng mask <code>x</code>
là lớn nhất.
Việc 2 mask <code>x</code> và <code>y</code> bị chọn trùng đội không quan trọng:
Ta có thể coi như khi đó có 1 người được chọn với mask <code>0</code>.</p>
<p>Ta có thể tính trước <code>max[x]</code> với mask <code>x</code> trong <code>O(N * 2^11)</code>.</p>
<h3 id="Chon-3-phan-tu"><a href="#Chon-3-phan-tu" class="headerlink" title="Chọn 3 phần tử"></a>Chọn 3 phần tử</h3><p>Trước tiên, ta có thể thấy nếu chỉ chọn 2 phần tử, ta
có thể for tất cả cặp mask, kiểm tra trong <code>O((2^11)^2)</code>.
Hiển nhiên do 2 mask đều chỉ có 11 bit nên khi <code>or</code> lại với
nhau (ghép bộ) thì mask mới vẫn chỉ có 11 bit. Vậy để chọn
3 phần tử, ta có thể tiếp tục ghép cặp tập đã or với tập <code>max[x]</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> two[<span class="number">1</span> &lt;&lt; <span class="number">11</span>];</div><div class="line"><span class="keyword">int</span> three[<span class="number">1</span> &lt;&lt; <span class="number">11</span>];</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>); ++i) &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>); ++j) &#123;</div><div class="line">    <span class="keyword">if</span> (!(i &amp; j)) <span class="comment">// không có phần tử trùng</span></div><div class="line">      two[i | j] = max(two[i | j], max[i] + max[j]);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>); ++i) &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>); ++j) &#123;</div><div class="line">    <span class="keyword">if</span> (!(i &amp; j)) <span class="comment">// không có phần tử trùng</span></div><div class="line">      three[i | j] = max(three[i | j], two[i] + max[j]);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Đáp số chính là <code>three[(1 &lt;&lt; 11) - 1]</code>.
Độ phức tạp sẽ là <code>O((2 ^ 11) ^ 2)</code>.</p>
<h2 id="DOMINO-Bai-toan-thu-nhat-1"><a href="#DOMINO-Bai-toan-thu-nhat-1" class="headerlink" title="DOMINO (Bài toán thứ nhất)"></a>DOMINO (Bài toán thứ nhất)</h2><h3 id="Tom-tat-de-bai-2"><a href="#Tom-tat-de-bai-2" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho một bảng <code>M x N</code> với <code>K</code> ô cấm.
Điền 0 hoặc 1 vào các ô không bị cấm sao cho
với ô <code>(i, j)</code>:</p>
<ul>
<li>Nếu <code>i + j</code> lẻ, thì ô <code>(i, j)</code> không nhỏ
hơn các ô không bị cấm xung quanh.</li>
<li>Nếu <code>i + j</code> chẵn, thì <code>(i, j)</code> không lớn
hơn các ô không bị cấm xung quanh.</li>
</ul>
<h4 id="Gioi-han-7"><a href="#Gioi-han-7" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= M, N &lt;= 16</code></p>
<h3 id="Quy-hoach-dong"><a href="#Quy-hoach-dong" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Thực chất đây là một bài toán quy hoạch
động bitmask cơ bản. Nhận xét rằng với mỗi ô
ta chỉ cần để ý bit ô bên trái và bên trên nó để
có thể xét điều kiện thỏa mãn.</p>
<p>Khi quy hoạch động ta đi từng ô theo từng cột,
trên xuống dưới trái qua phải.
Gọi <code>f[i][j][mask]</code> là số cách lát kể từ
ô <code>(i, j)</code> đến cuối cùng, với <code>mask</code> là trạng thái
<code>N</code> ô cuối cùng đã đến trước <code>(i, j)</code> (tức các ô <code>(i - 1, j)</code>,
<code>(i - 1, j + 1)</code>, …, <code>(i, j - 1)</code>). Xem hính dưới:</p>
<p><img src="/images/20170420_domino.png" alt="Bài Domino"></p>
<p>Hình thể hiện trạng thái khi đã đến ô <code>(i, j)</code>. Ô màu xanh lá
là các ô đã lát, ô màu vàng thể hiện mask đang bị quản lí bởi
bit tương ứng trong mask, ô màu xanh dương thể hiện ô sắp điền,
ô màu đỏ thể hiện các ô chưa lát.</p>
<p>Để chuyển trạng thái ta xác định bit của ô <code>(i, j)</code>, nếu nó thỏa mãn
điều kiện với ô trái và trên thì gọi đến trạng thái tiếp theo (<code>f[i][j + 1][mask mới]</code>
hoặc <code>f[i + 1][1][mask mới]</code> nếu đó là ô cuối của cột).</p>
<h4 id="Chuyen-mask-nhu-nao"><a href="#Chuyen-mask-nhu-nao" class="headerlink" title="Chuyển mask như nào?"></a>Chuyển mask như nào?</h4><p>Ta để ý trên hình, bit <code>3</code>, kể từ ô tiếp theo, không cần biết đến nữa.
Ta có thể xóa bit này và đẩy lên, cho bit của <code>(i, j)</code> vào cuối. Như
vậy trạng thái của mình luôn có <code>N</code> bit.</p>
<p>Độ phức tạp là <code>O(N * M * 2^N)</code>.</p>
<h3 id="Cai-dat-nhu-nao"><a href="#Cai-dat-nhu-nao" class="headerlink" title="Cài đặt như nào?"></a>Cài đặt như nào?</h3><p>Nên gọi đệ quy có nhớ.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> f[<span class="number">20</span>][<span class="number">20</span>][<span class="number">1</span> &lt;&lt; <span class="number">16</span>];</div><div class="line"><span class="keyword">bool</span> visited[<span class="number">20</span>][<span class="number">20</span>][<span class="number">1</span> &lt;&lt; <span class="number">16</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> mask)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (i &gt; M) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// trường hợp biên</span></div><div class="line">  <span class="keyword">if</span> (visited[i][j][mask]) <span class="comment">// đã tính</span></div><div class="line">    <span class="keyword">return</span> f[i][j][mask];</div><div class="line">  visited[i][j][mask] = <span class="number">1</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ch = <span class="number">0</span>; ch &lt; <span class="number">2</span>; ++ch) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="comment">/*kiểm tra điều kiện đặt bit ch ở (i, j)*/</span>) &#123;</div><div class="line">      f[i][j][mask] += cal(i + (j == N), j % N + <span class="number">1</span>, (mask &lt;&lt; <span class="number">1</span>) &amp; ((<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>) + ch);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> f[i][j][mask];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// x &amp; ((1 &lt;&lt; N) - 1) để lấy x % (1 &lt;&lt; N), N bit cuối của x.</span></div><div class="line"><span class="comment">// (x &lt;&lt; 1) == x * 2, đẩy các bit sang phải 1 đơn vị.</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> ans = cal(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<h2 id="DOMINO-Bai-toan-thu-hai-1"><a href="#DOMINO-Bai-toan-thu-hai-1" class="headerlink" title="DOMINO (Bài toán thứ hai)"></a>DOMINO (Bài toán thứ hai)</h2><p>Lần này không có ô cấm. Điều kiện như bài toán thứ nhất.</p>
<h4 id="Gioi-han-8"><a href="#Gioi-han-8" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 8</code>, <code>1 &lt;= M &lt;= 10^6</code></p>
<h3 id="Nhan-ma-tran"><a href="#Nhan-ma-tran" class="headerlink" title="Nhân ma trận"></a>Nhân ma trận</h3><p>Lần này không có ô cấm, nên với mỗi hàng ta chỉ cần quan
tâm mask của nó là gì. Từ đây ta có thể nghĩ đến việc nhân
ma trận.</p>
<p>Giới hạn <code>N</code> nhỏ, <code>M</code> lớn cũng mang đến cho ta gợi ý này.</p>
<h3 id="So-trang-thai"><a href="#So-trang-thai" class="headerlink" title="Số trạng thái"></a>Số trạng thái</h3><p><code>O((2 ^ N)^3 * log(M))</code> chưa thể thỏa mãn bài toán.
Ta phân tích thêm một chút: với mỗi cột, ta có thể loại ra
các trạng thái không thỏa mãn các điều kiện giữa 2 ô liên tiếp
trên cùng cột.</p>
<p>Việc thử nghiệm cho thấy với <code>N = 8</code> cũng chỉ có <strong>55</strong> trạng thái,
có thể nhân ma trận.</p>
<h3 id="Dieu-kien-theo-i-j"><a href="#Dieu-kien-theo-i-j" class="headerlink" title="Điều kiện theo i + j"></a>Điều kiện theo <code>i + j</code></h3><p>Khi chuyển từ cột <code>2i</code> sang cột <code>2i + 1</code>,
điều kiện bị thay đổi: thứ tự các ô trong
cột đang từ <em>lẻ, chẵn, lẻ, …</em> thành <em>chẵn, lẻ, chẵn,…</em>
Điều này làm cho việc chuyển trạng thái không thể
thực hiện đơn thuần.</p>
<p>Ta có thể sửa điều này bằng cách thêm 1 bit cho
trạng thái của cột, chỉ xem đây là trạng thái cho cột lẻ
hay chẵn.</p>
<p>Bảng chuyển đổi của mình sẽ chỉ cho phép chuyển từ cột
lẻ sang chẵn và ngược lại.</p>
<p>Để đơn giản từ giờ ta gọi số trạng thái là <code>P</code> (<code>P &lt;= 110</code>).</p>
<h3 id="Ma-tran-goc-va-dap-so"><a href="#Ma-tran-goc-va-dap-so" class="headerlink" title="Ma trận gốc và đáp số"></a>Ma trận gốc và đáp số</h3><p>Hiển nhiên ta trận gốc là một ma trận <code>1 x P</code>, trong đó
các ô thể hiện trạng thái cột lẻ sẽ là <code>1</code>. Ta nhân ma trận
gốc với bảng chuyển đổi đã lũy thừa <code>M - 1</code>, nhận được ma
trận đáp số <code>1 x P</code>. Đáp án chính là tổng các phần tử trong
ma trận.</p>
<p>Độ phức tạp là <code>O(P ^ 3 * log(M))</code>.</p>
<h2 id="GAMES-1"><a href="#GAMES-1" class="headerlink" title="GAMES"></a>GAMES</h2><h3 id="Tom-tat-de-bai-3"><a href="#Tom-tat-de-bai-3" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho một dãy bit <code>N</code> phần tử chưa xác định
 và <code>M</code> điều kiện có dạng
xor của <code>A[l..r]</code> là 0 hay 1. Tìm vị trí <code>x</code> đầu tiên
mà điều kiện <code>x</code> mâu thuẫn với các điều kiện trên.</p>
<h4 id="Gioi-han-9"><a href="#Gioi-han-9" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 10^9</code>, <code>1 &lt;= M &lt;= 10^5</code></p>
<h3 id="Chat-nhi-phan"><a href="#Chat-nhi-phan" class="headerlink" title="Chặt nhị phân"></a>Chặt nhị phân</h3><p>Để tìm vị trí đầu tiên mâu thuẫn, ta chặt nhị phân <code>x</code>
để tìm vị trí xa nhất mà vẫn tồn tại một dãy thỏa mãn
các điều kiện từ 1 đến <code>x</code>.</p>
<p>Bài toán trở thành kiểm tra xem có một dãy tồn tại không.</p>
<h3 id="Tinh-chat-mang-don"><a href="#Tinh-chat-mang-don" class="headerlink" title="Tính chất mảng dồn"></a>Tính chất mảng dồn</h3><p>Nếu ta xét mảng dồn <code>S[1..N]</code>, thì điều kiện tổng xor
<code>l..r</code> bằng 0 hay 1 tương đương với <code>S[l - 1]</code> với <code>S[r]</code>
bằng nhau hay khác nhau.</p>
<p>Ngoài ra, <code>S[i]</code> có thể nhận được bất kí giá trị nào
không phụ thuộc vào <code>S[i - 1]</code> nên ta có thể thoải mái
gán một giá trị bất kì, nhưng chỉ <strong>một</strong> mà thôi.</p>
<p>Bài toán trở thành, liệu có thể gán dãy <code>S[1..N]</code> thỏa
mãn các điều kiện các nhau không?</p>
<h3 id="2-gia-tri-cho-1-bien"><a href="#2-gia-tri-cho-1-bien" class="headerlink" title="2 giá trị cho 1 biến"></a>2 giá trị cho 1 biến</h3><p>Ta có thể coi mảng <code>S[]</code> như một đồ thị <code>N</code> đỉnh. Gộp
các đỉnh cùng giá trị, ta thấy việc gán giá trị 0-1 cho
các đỉnh còn lại giống như tô màu 2 phía.</p>
<p>Như vậy, ta có thể kiểm tra xem đồ thị có phải 2 phía không.</p>
<p>Độ phức tạp sẽ là <code>O(M + N)</code>.</p>
<h3 id="Giam-so-luong-dinh"><a href="#Giam-so-luong-dinh" class="headerlink" title="Giảm số lượng đỉnh"></a>Giảm số lượng đỉnh</h3><p>Có tận <code>10^9</code> đỉnh, tuy nhiên chỉ có <code>10^5</code> cạnh. Vì thế
chỉ có tối đa <code>2 * 10^5</code> đỉnh có bậc khác 0, ta chỉ cần
quan tâm tới các đỉnh này.</p>
<p>Độ phức tạp chỉ còn <code>O(M)</code>, mang lại thuật toán <code>O(M * log(M))</code>.</p>
<h2 id="HANOI-1"><a href="#HANOI-1" class="headerlink" title="HANOI"></a>HANOI</h2><h3 id="Tom-tat-de-bai-4"><a href="#Tom-tat-de-bai-4" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho thuật toán giải bài toán tháp Hà Nội:
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HanoiTower</span><span class="params">(height, From, Temp, To)</span>:</span></div><div class="line">  <span class="keyword">if</span> height == <span class="number">1</span>:</div><div class="line">    <span class="comment"># Move one from `From` to `To`</span></div><div class="line">    <span class="keyword">return</span></div><div class="line">  HanoiTower(height - <span class="number">1</span>, From, To, Temp)</div><div class="line">  HanoiTower(<span class="number">1</span>, From, Temp, To)</div><div class="line">  HanoiTower(height - <span class="number">1</span>, Temp, From, To)</div><div class="line"></div><div class="line"><span class="comment"># Call the function</span></div><div class="line">HanoiTower(N, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>)</div></pre></td></tr></table></figure></p>
<ul>
<li>Tìm trạng thái của 3 tháp sau <code>P</code> lần gọi hàm.</li>
<li>Cho trạng thái của 3 tháp, tính số bước đã gọi hàm
<code>P</code>, hoặc in <code>-1</code> nếu không tồn tại trạng thái đó khi giải.</li>
</ul>
<h4 id="Gioi-han-10"><a href="#Gioi-han-10" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 100</code>. Lưu ý <code>P</code> có thể là số lớn.</p>
<h3 id="Cac-buoc-cua-thuat-toan"><a href="#Cac-buoc-cua-thuat-toan" class="headerlink" title="Các bước của thuật toán"></a>Các bước của thuật toán</h3><p>Ta có thể tóm tắt thuật toán trong 3 bước:</p>
<ul>
<li>Chuyển tháp <code>N - 1</code> từ A sang B dùng C làm đệm</li>
<li>Chuyển đĩa <code>N</code> từ A sang C</li>
<li>Chuyển tháp <code>N - 1</code> từ B sang C dùng A làm đệm</li>
</ul>
<p>Từ thuật toán, ta có thể xác định mình đang ở bước nào
bằng cách xét vị trí của đĩa <code>N</code>.</p>
<ul>
<li>Nếu <code>N</code> còn ở <code>A</code> thì ta ở bước 1.</li>
<li>Nếu không ta ở bước 2 hoặc 3.</li>
</ul>
<p>Sau khi xác định được vị trí của <code>N</code>, ta có thể bỏ nó đi
và đệ quy xuống bước dưới, coi như ta đang giải bài toán
chuyển tháp <code>N - 1</code>.</p>
<h3 id="Tim-trang-thai-tu-P"><a href="#Tim-trang-thai-tu-P" class="headerlink" title="Tìm trạng thái từ P"></a>Tìm trạng thái từ <code>P</code></h3><p>Ta biết để chuyển tháp <code>x</code> sẽ mất <code>2^x - 1</code> bước,
nên khi xét vị trí đĩa <code>N</code> ta có thể xác định xem ta
đang ở bước mấy của việc chuyển tháp <code>N</code>:</p>
<ul>
<li>Nếu <code>P &lt; 2^x</code> thì ta đang ở bước 1.</li>
<li>Nếu <code>P = 2^x</code> thì ta đang ở bước 2.</li>
<li>Nếu <code>P &gt; 2^x</code> thì ta đang ở lượt <code>P - 2^x</code> của bước 3.</li>
</ul>
<p>Tùy theo bước ta xác định vị trí của đĩa <code>N</code> rồi đệ
quy xuống bước tương ứng. Độ phức tạp là <code>O(N)</code>.
Code khá giống bò trên BST.</p>
<h3 id="Tim-P-tu-trang-thai"><a href="#Tim-P-tu-trang-thai" class="headerlink" title="Tìm P từ trạng thái"></a>Tìm <code>P</code> từ trạng thái</h3><p>Việc tìm <code>P</code> không khác gì tìm trạng thái. Khi xét tháp
<code>N</code>, ta kiểm tra xem mình ở bước nào tùy theo vị trí của
đĩa <code>N</code>:</p>
<ul>
<li>Nếu <code>N</code> ở A, thì ta ở bước 1. Đệ quy vào bước 1.</li>
<li>Nếu <code>N</code> ở C, ta ở bước 2 hoặc 3. Cộng <code>P</code> thêm <code>2^x</code> (cho
bước 1+2) rồi đệ quy vào 3.</li>
</ul>
<p>Độ phức tạp cũng là <code>O(N)</code>.</p>
<h2 id="WG-1"><a href="#WG-1" class="headerlink" title="WG"></a>WG</h2><h3 id="Tom-tat-de-bai-5"><a href="#Tom-tat-de-bai-5" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho một xâu <code>P</code> và một tập xâu <code>S[1..N]</code>. Dựng xâu <code>T</code> như sau:</p>
<ul>
<li>Đầu tiên chọn một xâu trong tập <code>S[]</code> và thêm vào <code>T</code></li>
<li>Sau đó, tìm xâu <code>S[i]</code> bất kì thỏa mãn <code>S[0] == T.back()</code> rồi thêm <code>S[i][1..]</code> vào.</li>
</ul>
<p>Hỏi xâu <code>T</code> ngắn nhất chứa dãy con không liên tiếp <code>P</code> là gì?</p>
<h4 id="Gioi-han-11"><a href="#Gioi-han-11" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= |P| &lt;= 250, 1 &lt;= |S[i]| &lt;= 10, 1 &lt;= N &lt;= 1000</code></p>
<h3 id="Tham-lam-dung-xau"><a href="#Tham-lam-dung-xau" class="headerlink" title="Tham lam dựng xâu"></a>Tham lam dựng xâu</h3><p>Khi đã có xâu <code>T</code> có thể lấy ra được dãy con là prefix <code>x</code> của <code>P</code>,
ta có thể xác định số lượng kí tự ghép thêm khi thêm xâu <code>S[i]</code>
bằng cách đi từ trái sang phải, tham lam kí tự tiếp theo cần ghép.</p>
<p>Từ đó ta tính trước được mảng <code>nx[i][j]</code>, khi thêm xâu <code>i</code> với <code>j</code>
kí tự đã ghép thì trạng thái mới là bao nhiêu. Độ phức tạp sẽ là
<code>O(N * |P| * |S[i]|)</code>.</p>
<h3 id="Quy-hoach-dong-1"><a href="#Quy-hoach-dong-1" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Ta có thể quy hoạch động <code>f[i][j]</code> là độ dài xâu <code>T</code> ngắn nhất sao
cho xâu cuối cùng là <code>i</code> và đã ghép được <code>j</code> kí tự đầu tiên của <code>P</code>.
Ta chọn thêm một xâu <code>S[k]</code> mới và chuyển trạng thái sang <code>f[k][nx[k][j]]</code>.
Điều kiện là <code>S[i].back() == S[k][0]</code> và <code>nx[k][j] != j</code>.</p>
<p>Độ phức tạp sẽ là <code>O(N^2 * |P|)</code>, chưa thỏa mãn bài toán.</p>
<h3 id="Ki-tu-cuoi"><a href="#Ki-tu-cuoi" class="headerlink" title="Kí tự cuối"></a>Kí tự cuối</h3><p>Thực chất ta không cần lưu chiều <code>i</code> là xâu cuối cùng, vì ta chỉ
cần quan tâm đến kí tự cuối cùng của <code>T</code>, nên thay vào đó ta có
thể chỉ lưu <code>i</code> là kí tự cuối cùng.</p>
<p>Độ phức tạp giảm xuống còn <code>O(26 * |P| * N)</code>, thỏa mãn bài toán.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://natsukagami.github.io/2017/04/21/2017-04-20-Training/" data-id="cj1rrg0zs00001s2bn41lki5p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/apio/">apio</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thay-Dong/">thầy Đông</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/training/">training</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vietnamese/">vietnamese</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-04-19-Training" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/19/2017-04-19-Training/" class="article-date">
  <time datetime="2017-04-19T08:00:00.000Z" itemprop="datePublished">2017-04-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Training/">Training</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/19/2017-04-19-Training/">2017/04/19 Training</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Thầy Phương cho 3 bài của <a href="http://orac.amt.edu.au/cgi-bin/train/hub.pl?expand=fario17#fario17" target="_blank" rel="external">FARIO 2017</a>. Bài 1 đã làm rồi, bài 3 là bài approximate nên mình chỉ chữa bài 2.</p>
<h2 id="Pyramid-Cake"><a href="#Pyramid-Cake" class="headerlink" title="Pyramid Cake"></a>Pyramid Cake</h2><h3 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho một chiếc hộp có đáy chữ nhật <code>M x N</code>, vị trí <code>(i, j)</code> có độ cao là <code>H[i][j]</code>. Ta dựng một chiếc bánh nhiều tần thỏa mãn:</p>
<ul>
<li>Các tầng là các hình chữ nhật chứa đỉnh <code>(1,1)</code></li>
<li>Tầng trên phải nằm bên trong mặt phẳng của tầng dưới</li>
<li>Không ô nào cao hơn vị trí tương ứng của hộp</li>
<li>Thể tích bánh là lớn nhất.<h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><code>1 &lt;= N, M &lt;= 1000</code>, <code>1 &lt;= H[i][j] &lt;= 10^8</code></li>
</ul>
<h3 id="Lua-chon-tang"><a href="#Lua-chon-tang" class="headerlink" title="Lựa chọn tầng"></a>Lựa chọn tầng</h3><p>Do mọi tầng đề chứa <code>(1, 1)</code>, bản chất ta chỉ cần tọa độ của góc còn lại là có thể xác định được duy nhất tầng hiện tại.</p>
<p>Tại sao ta chỉ cần quan tâm số tầng mà không phải độ cao? Hiển nhiên, với tầng <code>(i, j)</code> ta biết độ cao của tầng đó (nếu tính cả các tầng dưới nó) sẽ là <code>M[i][j] = min(H[i&#39;][j&#39;])</code> với <code>i&#39; &lt;= i, j&#39; &lt;= j</code>.</p>
<p>Khi nén tầng như vậy, ta có thể coi như tầng sau luôn nhỏ hơn tầng dưới, làm cho tập trạng thái không có chu trình và ta có thể quy hoạch động được.</p>
<p>Gọi <code>f[i][j]</code> là diện tích lớn nhất của hình có tầng dưới cùng là <code>(i, j)</code>. Hiển nhiên ta sẽ đặt tầng dưới cùng độ dày <code>M[i][j]</code>. Sau đó, ta chọn một tầng nhỏ hơn để qhđ:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> cur = M[i][j] * i * j; <span class="comment">// Diện tích phần đáy</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= i; ++k)</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= j; ++l)</div><div class="line">		<span class="keyword">if</span> (k != i || l != j)</div><div class="line">			f[i][j] = max(f[i][j], cur + f[k][l] - M[i][j] * k * l);</div></pre></td></tr></table></figure>
<p>Tại sao ta trừ đi <code>M[i][j] * k * l</code>? Bởi phần diện tích này đã được tính vào đáy của hình dưới cùng.</p>
<p>Đáp số sẽ là <code>max(f[i][j])</code>, độ phức tạp là <code>O(N^4)</code>, chưa đủ để giải quyết bài toán.</p>
<h3 id="Thu-tat-ca"><a href="#Thu-tat-ca" class="headerlink" title="Thử tất cả?"></a>Thử tất cả?</h3><p>Ta có thể thấy, mỗi hình chữ nhật con đều nhỏ hơn đáy ban đầu ít nhất 1 hàng hoặc 1 cột. Vậy tại sao mình không chọn 1 trong 2 hình to nhất (<code>(i, j - 1)</code> và <code>(i - 1, j)</code>) để làm đáy tiếp theo?</p>
<p>Rất có thể mọi người sẽ nghĩ việc này không đúng vì có thể không điền đc thêm tầng nào - nhưng nếu ta nghĩ theo cách nhìn khác - ta thêm <strong>0</strong> tầng, thì lựa chọn vẫn hợp lí.</p>
<p>Có thể việc này không tối ưu không? Giả sử, lựa chọn <code>(x, y)</code> (<code>x &lt; i, y &lt; j</code>) là tối ưu. Hiển nhiên nó cũng sẽ tối ưu cho <code>(i, j - 1)</code>. Vậy ta hoàn toàn có thể chọn <code>(i, j - 1)</code> và nó sẽ chứa cả <code>(x, y)</code>, kết quả không đổi.</p>
<h3 id="Cai-thien-thuat-toan"><a href="#Cai-thien-thuat-toan" class="headerlink" title="Cải thiện thuật toán"></a>Cải thiện thuật toán</h3><p>Ta rút việc chọn tất cả cặp thành chọn một trong hai hình chữ nhật con lớn nhất. Độ phức tạp giảm xuống còn <code>O(N^2)</code>, thỏa mãn bài toán.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://natsukagami.github.io/2017/04/19/2017-04-19-Training/" data-id="cj1omty3s0000e92bw035i4ba" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/apio/">apio</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thay-Phuong/">thầy Phương</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/training/">training</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vietnamese/">vietnamese</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-04-18-Training" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/18/2017-04-18-Training/" class="article-date">
  <time datetime="2017-04-18T07:22:18.000Z" itemprop="datePublished">2017-04-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Training/">Training</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/18/2017-04-18-Training/">2017/04/18 Training</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hôm nay Hạnh dạy. Nói chung như mọi lần Hạnh dạy, bài thì hay nhưng có vẻ như Hạnh vẫn tốn rất nhiều thời gian giảng bài. Mình thực sự không muốn nghe cho lắm vì vẫn muốn nghĩ bài một mình, sau đó có reference của Hạnh để improve solution thì vẫn thích hơn.</p>
<h2 id="Stretching-Streamers-NAIPC-2017-bai-C"><a href="#Stretching-Streamers-NAIPC-2017-bai-C" class="headerlink" title="Stretching Streamers (NAIPC 2017, bài C)"></a><a href="https://naipc17.kattis.com/problems/naipc17.stretchingstreamers" target="_blank" rel="external">Stretching Streamers (NAIPC 2017, bài C)</a></h2><h3 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Có <code>N</code> điểm viết trên một đường tròn, điểm thứ <code>i</code> chứa số nguyên dương <code>A[i]</code>. 2 số có cạnh đến nhau khi ước chung lớn nhất lớn hơn 1. Không được chọn 2 cạnh đè lên nhau (trừ khi đè ở đầu mút), đếm số cách dựng cây khung <code>N</code> điểm mod <code>1e9 + 7</code>.</p>
<h5 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h5><p><code>3 &lt;= N &lt;= 300</code>, <code>2 &lt;= A[i] &lt;= 10^9</code>.</p>
<h3 id="Dung-cay-nhu-nao"><a href="#Dung-cay-nhu-nao" class="headerlink" title="Dựng cây như nào?"></a>Dựng cây như nào?</h3><p>Đơn giản ta có thể tóm tắt quá trình dựng cây như sau:</p>
<ul>
<li>Đầu tiên chọn đỉnh <code>1</code> làm gốc.</li>
<li>Từ đỉnh <code>1</code> chọn một tập đỉnh <code>X[1..M]</code> là con của đỉnh <code>1</code>. Hiển nhiên 1 phải có cạnh đến tất cả các đỉnh trong tập.</li>
<li>Mỗi đỉnh <code>X[i]</code> quản lí 1 đoạn <code>L[i] &lt;= X[i] &lt;= R[i]</code> sao cho <code>L[1] = 2</code>; <code>R[i] + 1 = L[i + 1]</code> và <code>R[M] = N</code>. (1)</li>
<li><p>Ta dựng cây cho mỗi đoạn <code>L[i]..R[i]</code>, với điều kiện không có cạnh <code>(x, y)</code> với <code>x &lt;= X[i] &lt;= y</code>. Để tính cái này ta làm tương đương, đệ quy xuống.</p>
<p>Tại sao lại có (1)? Đơn giản vì không thể tồn tại cạnh sao cho 2 đỉnh nằm 2 bên của một <code>X[i]</code> nào đó, vì chúng sẽ cắt qua cạnh <code>(1, X[i])</code>.</p>
</li>
</ul>
<h3 id="Bien-doi-doan-L-i-R-i"><a href="#Bien-doi-doan-L-i-R-i" class="headerlink" title="Biến đổi đoạn L[i]..R[i]."></a>Biến đổi đoạn <code>L[i]..R[i]</code>.</h3><p>Do có điều kiện không có cạnh <code>(x, y)</code> mà <code>x &lt;= X[i] &lt;= y</code> nên ta có thể chia đoạn <code>L[i]..R[i]</code> thành 2 đoạn <code>L[i]..X[i]</code> và <code>X[i]..R[i]</code> độc lập mà vẫn không thay đổi kết quả bài toán.</p>
<p>Khi đó, điều kiện đặc biệt biến mất và ta chỉ cần đệ quy xuống với các đoạn <code>L[1]..X[1]</code>, <code>X[1]..R[1]</code>, <code>L[2]..X[2]</code>, …, <code>X[M]..R[M]</code>.</p>
<h3 id="Cong-thuc-quy-hoach-dong"><a href="#Cong-thuc-quy-hoach-dong" class="headerlink" title="Công thức quy hoạch động"></a>Công thức quy hoạch động</h3><p>Từ các nhận xét trên, ta có công thức quy hoạch động sau:</p>
<p>Gọi <code>f[l][r]</code> là số cách dựng cây với các đỉnh thuộc đoạn <code>l..r</code>. Hiển nhiên <code>f[i][i] = 1</code>.</p>
<p>Ta có
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = l + <span class="number">1</span>; k &lt;= r; ++k)</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> st = l + <span class="number">1</span>; st &lt;= k; ++st)</div><div class="line">    f[l][r] += f[l][st - <span class="number">1</span>] * f[st][k] * f[k][r];</div></pre></td></tr></table></figure></p>
<p>Việc chọn tập <code>X[]</code> cho <code>[l..r]</code> giống với việc từ đoạn <code>[l..st - 1]</code> đã dựng cây, ta thêm đoạn <code>[st..r]</code> bằng cách nối <code>(l, k)</code> (<code>st &lt;= k &lt;= r</code>) rồi dựng 2 cây như trên. Do đó công thức qhđ này hoàn toàn chính xác. Đáp số sẽ là <code>f[1][N]</code>. Tuy nhiên độ phức tạp là <code>O(N^4)</code>, chưa đủ để thỏa mãn đề bài.</p>
<h3 id="Toi-uu-xuong-O-N-3"><a href="#Toi-uu-xuong-O-N-3" class="headerlink" title="Tối ưu xuống O(N^3)"></a>Tối ưu xuống <code>O(N^3)</code></h3><p>Việc chọn đoạn yêu cầu 2 bước, xác định <code>X[i]</code> và đoạn <code>st..r</code>. Liệu ta có thể giảm thiểu số cách lựa chọn không?</p>
<p>Thực chất ta hoàn toàn có thể tách 2 bước này thành 2 công đoạn chọn đoạn, đầu tiên chọn <code>st..X[i]</code> thỏa mãn có cạnh <code>(l, X[i])</code> và chọn đoạn <code>X[i]..r</code>. Như vậy ta có thể chọn 2 đoạn so le, mỗi lần chuyển trạng thái chỉ mất <code>O(N)</code>.</p>
<p>Ta sửa lại công thức qhđ thành <code>f[i][j][k]</code>, thêm <code>k</code> là bước hiện tại của chúng ta (<code>0</code> - chọn nửa đoạn đầu - hay <code>1</code> - đã chọn xong). Công thức trở thành:
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = l + <span class="number">1</span>; k &lt;= r; ++k) &#123;</div><div class="line">  <span class="keyword">if</span> (__gcd(l, r) &gt; <span class="number">1</span>) <span class="comment">// có cạnh từ l đến k</span></div><div class="line">    f[l][r][<span class="number">0</span>] += f[l][k - <span class="number">1</span>][<span class="number">1</span>] * f[k][r][<span class="number">1</span>];</div><div class="line">  <span class="keyword">if</span> (__gcd(l, k) &gt; <span class="number">1</span>)</div><div class="line">    f[l][r][<span class="number">1</span>] += f[l][k][<span class="number">0</span>] * f[k][r][<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Lúc đầu <code>f[i][i][x] = x</code> và đáp số sẽ là <code>f[1][N][1]</code>. Độ phức tạp là <code>O(N^3)</code>.</p>
<h2 id="LISA-RCC-2017-1st-Qualification-Round-bai-E"><a href="#LISA-RCC-2017-1st-Qualification-Round-bai-E" class="headerlink" title="LISA - RCC 2017 1st Qualification Round, bài E"></a><a href="http://www.russiancodecup.ru/en/tasks/round/61/E/" target="_blank" rel="external">LISA - RCC 2017 1st Qualification Round, bài E</a></h2><h3 id="Tom-tat-de-bai-1"><a href="#Tom-tat-de-bai-1" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho <code>N</code> xâu và <code>Q</code> truy vấn. Mỗi truy vấn gồm 2 số <code>l, r</code> và yêu cầu trả lời số xâu khác nhau có thể tạo được bằng cách ghép 1 tiền tố khác rỗng với 1 hậu tố khác rỗng của xâu nào đó trong khoảng từ <code>l</code> đến <code>r</code>.</p>
<h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N, Q &lt;= 10^5</code>. Tổng độ dài xâu không quá <code>10^5</code>.</p>
<h3 id="Ghep-tien-to-va-hau-to"><a href="#Ghep-tien-to-va-hau-to" class="headerlink" title="Ghép tiền tố và hậu tố"></a>Ghép tiền tố và hậu tố</h3><p>Ta có thể thấy ngay nếu không có điều kiện “khác nhau”, đáp số chỉ là <code>(số tiền tố trong đoạn) * (số hậu tố trong đoạn)</code>. Tuy nhiên có 2 vấn đề sau xảy ra khi ta cần tìm những xâu khác nhau:</p>
<ul>
<li>Có thể tồn tại cặp tiền tố giống nhau - đây là phần dễ.</li>
<li>Tồn tại 2 cặp tiền tố - hậu tố khác nhau nhưng cho ra xâu ghép giống nhau.</li>
</ul>
<h3 id="Dieu-kien-dem"><a href="#Dieu-kien-dem" class="headerlink" title="Điều kiện đếm"></a>Điều kiện đếm</h3><p>Một trong những kĩ thuật tiêu biểu khi đếm để xử lí lặp là đặt thêm điều kiện cho bài toán sao cho chúng khử đi các trường hợp lặp.</p>
<p>Giả sử ta có 2 xâu <code>Pre[i]</code> và <code>Suf[j]</code>, ta có <code>X = Pre[i] + Suf[j]</code>. Vậy nếu tồn tại một cặp khác <code>X = Pre[k] + Suf[l]</code> thì ta có tính chất gì?</p>
<p>Không mất tính tổng quát, giả sử <code>|Pre[i]| &lt; |Pre[k]|</code>. Ta có thể thấy phần <em>thừa ra</em> của <code>Pre[k]</code> chính bằng phần <em>thừa ra</em> của <code>Suf[j]</code>.
Như vậy, một cách nghĩ có thể là loại bỏ tất cả việc ghép của các xâu <code>Suf[l]</code> khi đã tồn tại một <em>phần thừa chung</em> như trên.</p>
<p>Bởi vì ta đã lấy ra tất cả tiền tố, nên nếu tồn tại 2 cặp xâu như trên thì sẽ luôn tồn tại <code>X = (Pre[i] + c) + (Suf[j][1..])</code>, trong đó <code>c</code> là chữ cái đầu tiên của <code>Suf[j]</code>, và <code>Pre[i] + c</code> cũng là 1 tiền tố (vì nó là tiền tố của <code>Pre[k]</code>). Như vậy, luôn tồn tại các cặp chỉ lệch nhau 1 kí tự - và ta chỉ cần đặt thêm điều kiện để khử trường hợp lệch 1 kí tự là đủ.</p>
<h3 id="Ki-tu-thua"><a href="#Ki-tu-thua" class="headerlink" title="Kí tự thừa"></a>Kí tự <em>thừa</em></h3><p>Xét trường hợp <code>X = (Pre[i] + c) + (Suf[j][1..])</code>. Ta có thể thêm vào điều kiện sau:
Xét <code>Suf[j]</code>, nếu <code>c + Suf[j]</code> cũng là một hậu tố trong tập, thì ta <strong>không được</strong> ghép <code>Suf[j]</code> với <code>Pre[i&#39;] = Pre[i] + c</code>.</p>
<p>Dễ dàng chứng minh tất cả xâu cần tìm đều tồn tại cách ghép <em>duy nhất</em> thỏa mãn điều kiện.</p>
<p>Lưu ý <code>Pre[i&#39;]</code> phải là <code>Pre[i] + c</code>, tức phải có ít nhất 2 kí tự.</p>
<p>Ta gọi các xâu <code>c + Suf[j]</code> không thuộc tập hậu tố là xâu <em>kí tự thừa</em> <code>c</code>.</p>
<h3 id="Dem-nhu-the-nao"><a href="#Dem-nhu-the-nao" class="headerlink" title="Đếm như thế nào?"></a>Đếm như thế nào?</h3><p>Với điều kiện trên, lời giải của ta sẽ gồm các bước:</p>
<ul>
<li>Đếm số tiền tố khác nhau kết thúc ở <code>c</code>.</li>
<li>Đếm số xâu <em>kí tự thừa</em> <code>c</code>, nhân với số tiền tố đã tìm được ở trên.</li>
<li>Với mỗi hậu tố, kiểm tra xem liệu ta có thể tạo được hậu tố bằng cách ghép 1 kí tự đầu tiên từ 1 tiền tố nào đó với các kí tự còn lại của hậu tố. Vốn dĩ việc này là cần thiết bởi vì đây là trường hợp duy nhất mà 1 xâu có thể được tạo từ một hậu tố không có kí tự thừa, và không được xét ở trường hợp trên.</li>
</ul>
<h3 id="So-tien-to-khac-nhau"><a href="#So-tien-to-khac-nhau" class="headerlink" title="Số tiền tố khác nhau"></a>Số tiền tố khác nhau</h3><p>Trước tiên ta sort lại các truy vấn theo <code>R[i]</code> và xử lí offline.</p>
<p>Lần lượt thêm các tiền tố vào Trie (chống lặp), đồng thời lưu lại với mỗi nút lần cuối cùng nó xuất hiện.</p>
<p>Giả sử ta đang ở truy vấn <code>L[i], R[i]</code> và đã thêm tất cả các tiền tố của <code>S[i]..S[R[i]]</code>. Không khó để nhìn ra số lượng tiền tố khác nhau chính là số nút mà lần xuất hiện cuối cùng <code>&gt;= L[i]</code>. Ta có thể dùng IT hoặc BIT làm công cụ đếm phân phối số nút xuất hiện ở từng thời điểm và tính tổng nhanh.</p>
<p>Để có thể tính số tiền tố xuất hiện mà kết thúc với kí tự <code>c</code> cụ thể, ta có thể dùng 26 IT / BIT thay vì 1, với mỗi loại tiền tố ta có 1 cây đếm phân phối riêng.</p>
<p>Độ phức tạp mỗi truy vấn là <code>O(26 * log(N))</code>.</p>
<h3 id="So-hau-to-voi-ki-tu-thua"><a href="#So-hau-to-voi-ki-tu-thua" class="headerlink" title="Số hậu tố với kí tự thừa"></a>Số hậu tố với <em>kí tự thừa</em></h3><p>Trước tiên, vì bản chất xâu thừa chính là <code>c + Suf[i]</code> nên sẽ có <code>(số tiền tố khác nhau)</code> xâu như vậy (với 1 kí tự <code>c</code>). Tuy nhiên ta phải trừ đi các xâu cũng là hậu tố - chính là số hậu tố bắt đầu với <code>c</code> mà có trên 1 kí tự. Để đếm số lượng xâu bị tính thừa ta có thể lật ngược xâu, biến hậu tố thành tiền tố và đếm như phần trên.</p>
<p>Phần này ta cũng làm <code>O(26 * log(N))</code> mỗi truy vấn.</p>
<h3 id="Cac-hau-to-cong-them"><a href="#Cac-hau-to-cong-them" class="headerlink" title="Các hậu tố cộng thêm"></a>Các hậu tố cộng thêm</h3><p>Phần này khá đơn giản, với mỗi hậu tố bắt đầu với kí tự <code>c</code> ta có thể kiểm tra có tồn lại hậu tố <code>Pre[i] = c</code> nào không. Ta có thể làm kèm với thao tác đếm ở trên.</p>
<h3 id="Tong-ket"><a href="#Tong-ket" class="headerlink" title="Tổng kết"></a>Tổng kết</h3><p>Với <code>Q</code> truy vấn, độ phức tạp sẽ là <code>O(Q * 26 * log(N))</code>, nên cẩn thận 1 chút ở phần cài đặt nếu không có thể sẽ bị TLE vì cài ẩu.</p>
<h2 id="Electric-Charges-AIM-Tech-Round-Div-1"><a href="#Electric-Charges-AIM-Tech-Round-Div-1" class="headerlink" title="Electric Charges - AIM Tech Round (Div. 1)"></a><a href="http://codeforces.com/contest/623/problem/C" target="_blank" rel="external">Electric Charges - AIM Tech Round (Div. 1)</a></h2><h3 id="Tom-tat-de-bai-2"><a href="#Tom-tat-de-bai-2" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h3><p>Cho <code>N</code> điểm trên mặt phẳng. Gióng chúng xuống trục Ox hoặc Oy sao cho khoảng cách giữa 2 điểm gióng xuống xa nhất là nhỏ nhất có thể.</p>
<h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p><code>1 &lt;= N &lt;= 10^5</code>, <code>-10^8 &lt;= X[i], Y[i] &lt;= 10^8</code></p>
<h3 id="Chat-nhi-phan"><a href="#Chat-nhi-phan" class="headerlink" title="Chặt nhị phân"></a>Chặt nhị phân</h3><p>Trong bài này ta sử dụng chặt nhị phân, một cách thông dụng để giải các bài min-của-max. Bài toán trở thành: tìm một cách xếp sao cho khoảng cách không quá <code>X</code>?</p>
<h3 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT??"></a>2-SAT??</h3><p>Tuấn nghĩ ra thuật 2-SAT… Có thể AC nhũng chẳng hay chút nào :D Hiển nhiên một bài C div 1 không thể tốn nhiều thời gian code như thế… Đây không phải round của amd.</p>
<h3 id="Chon-mot-moc"><a href="#Chon-mot-moc" class="headerlink" title="Chọn một mốc"></a>Chọn một mốc</h3><p>Tóm lại ta phải tối ưu max của 3 cái sau:</p>
<ul>
<li><code>(minX - maxX)^2</code></li>
<li><code>(minY - maxY)^2</code></li>
<li><code>max(minX^2, maxX^2) + max(minY^2, maxY^2)</code>
Ý tưởng đầu tiên sẽ là for một biến, giả sử <code>minX</code>, và tham lam các biến còn lại.</li>
</ul>
<p>Khi có <code>minX</code>, ta tính được <code>maxX</code>. Hiển nhiên các điểm có <code>X[i] &lt; minX</code> hoặc <code>X[i] &gt; maxX</code> đều phải chọn sang <code>Y</code>. Ta chỉ cần lấy min và max của các <code>Y[i]</code> đó, so sánh. Bài toán đơn giản?</p>
<p>Thuật toán sai rồi. Rất có thể <code>maxX^2</code> &gt; <code>minX^2</code> và sẽ làm cho thuật toán bị ảo tưởng.</p>
<h3 id="Chon-mot-diem"><a href="#Chon-mot-diem" class="headerlink" title="Chọn một điểm"></a>Chọn một điểm</h3><p>Thay vì chọn 1 mốc như <code>minX</code>, ta chọn một điểm và coi nó là <code>minX</code>, đồng thời là điểm có <code>abs(X[i])</code> lớn nhất được chọn làm <code>X</code>. Khi đó ta có thể yên tâm bốc các điểm nằm ngoài khoảng giới hạn đó là <code>Y</code> và chỉ cần kiểm tra các khoảng cách còn lại.</p>
<h3 id="Tinh-cac-Y-nhu-nao"><a href="#Tinh-cac-Y-nhu-nao" class="headerlink" title="Tính các Y như nào?"></a>Tính các <code>Y</code> như nào?</h3><p>Tóm lại ta cần tính nhanh minY và maxY ở khoảng các điểm có <code>X &lt; L</code> và <code>X &gt; R</code> với <code>L, R</code> bất kì. Ta có thể sort lại các điểm theo tọa độ của <code>X</code>, sau đó xây các mảng dồn min, max để lấy nhanh prefix và suffix.</p>
<p>Xây mất <code>O(N log(N))</code> (sắp xếp) và truy vấn <code>O(1)</code>.</p>
<h3 id="Lat-leo"><a href="#Lat-leo" class="headerlink" title="Lắt léo"></a>Lắt léo</h3><p>Còn một trường hợp nữa ta chưa xét đến: chọn tất cả theo trục Y. Trường hợp này không khó, check <code>(maxY - minY) ^ 2</code> là xong. Tuy vậy mình không nghĩ ra trước khi nộp :(</p>
<h3 id="Tong-ket-1"><a href="#Tong-ket-1" class="headerlink" title="Tổng kết"></a>Tổng kết</h3><p>Tóm lại ta cần chặt nhị phân, khi kiểm tra cần chạy con trỏ hoặc lấy lower/upper bound. Việc chạy con trỏ khá lằng nhằng không cần thiết nên mình không code. Độ phức tạp là <code>(O(N * log(N) * log(10^17)))</code> hoặc <code>O(N * log(10^17))</code>.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://natsukagami.github.io/2017/04/18/2017-04-18-Training/" data-id="cj1nlu8z60009kp2bjq2t1jk4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/anh-Hanh/">anh Hạnh</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/apio/">apio</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/training/">training</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vietnamese/">vietnamese</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-04-15-Training" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/2017-04-15-Training/" class="article-date">
  <time datetime="2017-04-16T05:34:00.000Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Training/">Training</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/16/2017-04-15-Training/">2017/04/15 Training</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>Warning</strong>: If you want to try solving the problems, skip reading everything but the statements! Also, for hints, read <em>slowly</em> from top to bottom of each problem.</p>
<p>I didn’t attend the class directly, but did the problems while going on a bus to Ninh Binh. The problems were somewhat exciting to me.</p>
<h2 id="A-Sorting"><a href="#A-Sorting" class="headerlink" title="A. Sorting"></a>A. Sorting</h2><h3 id="Statements"><a href="#Statements" class="headerlink" title="Statements"></a>Statements</h3><p>You are given a permutation <code>A[1..N]</code>, along with <code>Q</code> queries, each of the form <code>l, r</code> which you should sort the subarray <code>A[l..r]</code> increasingly or decreasingly. After all the queries are processed, print the middle value <code>A[N / 2 + 1]</code>.</p>
<h4 id="Contraints"><a href="#Contraints" class="headerlink" title="Contraints"></a>Contraints</h4><p><code>1 &lt;= N &lt;= 10^5</code>, <code>1 &lt;= Q &lt;= 10^5</code>, <code>N</code> is odd.</p>
<h3 id="One-problem-from-the-past"><a href="#One-problem-from-the-past" class="headerlink" title="One problem from the past"></a>One problem from the past</h3><p>The statements reminds me of a past problem I did on Codeforces. I didn’t remember the source, but in short you are given a Latin string with the same sorting queries, and then you have to return the whole string. It was feasible to solve the problem in <code>O(Q * 26 * log(N))</code> time because of the limited alphabet size.</p>
<p>The main idea is, for each <code>l, r</code> query, count the number of instances of each character in the range. Then we can re-assign the characters’ positions, from the smallest to the largest. To efficiently do range-counting and range-assignments we can maintain 26 <em>interval trees</em>, with lazy update.</p>
<p>However, the problem I faced yesterday was different: the alphabet size is much bigger. Perhaps a different approach was needed. Or maybe not?</p>
<h3 id="The-alphabet-size"><a href="#The-alphabet-size" class="headerlink" title="The alphabet size"></a>The alphabet size</h3><p>From the previous problem, we know that the problem can be solved efficiently if the alphabet size was small. “Is there anyway to make the numbers pool smaller?” - that was the first question that came to my mind.</p>
<p>The above problem somewhat resembles radix sorting, so of course it can also be applied to numbers. However splitting digits is not eligible, as reordering still takes too much time. We need to transform numbers into something that’s both small in size and easy to reassign, maybe not even caring about its original value.</p>
<p>The problem only asked for <strong>one</strong> element. What if, all we care about is the element itself?</p>
<h3 id="Relative-ordering"><a href="#Relative-ordering" class="headerlink" title="Relative ordering"></a>Relative ordering</h3><p>It turns out that we don’t actually need to sort the elements. Not entirely.</p>
<p>Let’s choose a pivot, <code>X</code>. We transform every number larger than <code>X</code> to <code>1</code>, and the rest to <code>0</code>. Sorting becomes wrong now, but the order <em>relative to <code>X</code></em> isn’t: If we sort <code>l, r</code> increasingly, every number that’s smaller than <code>X</code> still stays on the left of those which are larger than <code>X</code>. Therefore, this <em>masked</em> ordering isn’t entirely wrong, because the correct ordering <strong>have the same mask</strong>, and we can assume that the unlerlying original values are on the correct positions. Of course, we don’t need to care about it.</p>
<p>Of course, since the numbers are binary now, performing the above algorithm becomes a breeze.</p>
<p>After all the sortings, we get the middle number’s mask. It doesn’t give us the answer immediately, but it does leave a hint: If the number is <strong>1</strong> then the answer is <strong>larger than <code>X</code></strong>, and vice versa.</p>
<h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h3><p>To effectively use the previous hint, we can perform <em>binary search</em> on the value of <code>A[N / 2 + 1]</code>, checking whether it’s larger than the middle value, and shorten the range according to the answer.
That is also the final missing piece to solve the problem, giving us an <code>O(log(N) * Q * log(N))</code> algorithm.</p>
<h2 id="B-Zigzag"><a href="#B-Zigzag" class="headerlink" title="B. Zigzag"></a>B. Zigzag</h2><h3 id="Statements-1"><a href="#Statements-1" class="headerlink" title="Statements"></a>Statements</h3><p>You are given an array <code>A[1..N]</code> of distinct numbers. There are also <code>Q</code> queries, each of the form <code>x y</code> that asks you to change the <code>x</code>-th number to <code>y</code>. It is guaranteed that after each query the array always contains dintinct numbers. After each query you have to return the largest alternating subsequence of the array.</p>
<h4 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h4><p><code>1 &lt;= N &lt;= 10^6</code>, <code>1 &lt;= A[i] &lt;= 10^9</code></p>
<h3 id="Alternating-Subsequence"><a href="#Alternating-Subsequence" class="headerlink" title="Alternating Subsequence"></a>Alternating Subsequence</h3><p>The first thing to do is analyzing the <strong>longest alternating subsequence</strong> problem. It turns out that it is not as difficult as it sounds, in fact it can be greedily built from an array with distinct numbers.</p>
<p>One nice observation from the problem: If there exists such <code>i</code> that <code>A[i - 1] &lt;= A[i] &lt;= A[i + 1]</code>, then there always exists an optimal subsequence without <code>A[i]</code>. Why? Since they’re consecutive numbers, <code>A[i - 1]</code> is always better than <code>A[i]</code> as a “lower” number, and <code>A[i + 1]</code> is always better than <code>A[i]</code> as an “upper” numbber. Therefore, it is safe to just remove <code>A[i]</code> from the array without losing the optimal sequence.</p>
<p>Now let’s continuously remove such numbers from the array until there is no such one. Which means, for each <code>i</code>, it is either <code>A[i - 1] &lt;= A[i] &amp;&amp; A[i] &gt;= A[i + 1]</code> or <code>A[i - 1] &gt;= A[i] &amp;&amp; A[i] &lt;= A[i + 1]</code>. Wait… Isn’t <code>A[..]</code> now already an alternating sequence? More than that, <code>A[..]</code> is an <strong>optimal</strong> longest alternating subsequence of the original array.</p>
<p>Dive a little deeper, we will find out that each <code>A[i]</code> can be a part of the new array <strong>if and only if</strong> has the same above atrribute on the original array. <em>Unless</em> it’s the first or last number of the array, in such case it’s always included.</p>
<h3 id="Testing-an-element"><a href="#Testing-an-element" class="headerlink" title="Testing an element"></a>Testing an element</h3><p>With the above observations, we can deduce whether an element will appear in our optimal subsequence:</p>
<ul>
<li>It’s the first or last element, <em>or</em></li>
<li>Either it’s both smaller or both bigger than its neighboring elements.</li>
</ul>
<p>Using these conditions we can check each element in <code>O(1)</code>. To answer the length of the optimal subsequence one only has to count how many elements satisfies the above conditions.</p>
<h3 id="Processing-queries"><a href="#Processing-queries" class="headerlink" title="Processing queries"></a>Processing queries</h3><p>If we change one number, how is each element’s satisfiability affected? It turns out, only 3 of them are affected at most: the element itself, and its neighboring elements.</p>
<p>It is now easy to process each query in <code>O(1)</code>: just change the element and re-check every affected elements.</p>
<p>That concludes our <code>O(N + M)</code> algorithm.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://natsukagami.github.io/2017/04/16/2017-04-15-Training/" data-id="cj1nlu8z10006kp2blkcyswsf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/anh-Minh/">anh Minh</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/apio/">apio</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/english/">english</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/training/">training</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-First-Post" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/10/First-Post/" class="article-date">
  <time datetime="2016-10-10T06:10:19.000Z" itemprop="datePublished">2016-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Thoughts/">Thoughts</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/10/First-Post/">First Post</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>I started a blog, yay!<br>The purpose of this blog will be for me to express random thoughts, coding experiences and to show everyone my work.<br>That’s all. Thank you for reading my first post!</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://natsukagami.github.io/2016/10/10/First-Post/" data-id="cj1nlu8z00005kp2bg8fk4tv8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/First-Post/">First Post</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Thoughts/">Thoughts</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Training/">Training</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/First-Post/">First Post</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anh-Hanh/">anh Hạnh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anh-Minh/">anh Minh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apio/">apio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/english/">english</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thay-Phuong/">thầy Phương</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thay-Dong/">thầy Đông</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/training/">training</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vietnamese/">vietnamese</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/First-Post/" style="font-size: 10px;">First Post</a> <a href="/tags/anh-Hanh/" style="font-size: 10px;">anh Hạnh</a> <a href="/tags/anh-Minh/" style="font-size: 10px;">anh Minh</a> <a href="/tags/apio/" style="font-size: 20px;">apio</a> <a href="/tags/english/" style="font-size: 10px;">english</a> <a href="/tags/thay-Phuong/" style="font-size: 10px;">thầy Phương</a> <a href="/tags/thay-Dong/" style="font-size: 10px;">thầy Đông</a> <a href="/tags/training/" style="font-size: 20px;">training</a> <a href="/tags/vietnamese/" style="font-size: 15px;">vietnamese</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/04/21/2017-04-20-Training/">2017/04/20 Training</a>
          </li>
        
          <li>
            <a href="/2017/04/19/2017-04-19-Training/">2017/04/19 Training</a>
          </li>
        
          <li>
            <a href="/2017/04/18/2017-04-18-Training/">2017/04/18 Training</a>
          </li>
        
          <li>
            <a href="/2017/04/16/2017-04-15-Training/">2017/04/15 Training</a>
          </li>
        
          <li>
            <a href="/2016/10/10/First-Post/">First Post</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Natsu Kagami<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>