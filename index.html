<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Kagami&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Some random stuff I write to express my life.">
<meta property="og:type" content="website">
<meta property="og:title" content="Kagami's Blog">
<meta property="og:url" content="http://natsukagami.github.io/index.html">
<meta property="og:site_name" content="Kagami's Blog">
<meta property="og:description" content="Some random stuff I write to express my life.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kagami's Blog">
<meta name="twitter:description" content="Some random stuff I write to express my life.">
<meta name="twitter:creator" content="@natsukagami">
  
    <link rel="alternate" href="/atom.xml" title="Kagami&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>
  <script type="text/javascript">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'] ],
        displayMath: [ ['$$','$$'] ],
        processEscape: true
      }
    }); 
  </script>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Kagami&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">IOI Medalist, osu! lover, I tryhard everything.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://natsukagami.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Random-Rain" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/24/Random-Rain/" class="article-date">
  <time datetime="2017-10-24T03:24:00.000Z" itemprop="datePublished">2017-10-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Writing/">Writing</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/24/Random-Rain/">[Random] Rain</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><em>This is my first attempt at writing randomly. Please ignore any stupid errors I make!</em></p>
<p>Dark clouds filled the sky. She stood still, her hands holding something - it resembles an umbrella.</p>
<p>The rain started. Her fingers were shaking, that umbrella was completely useless. Raindrops filled her dress. She was not moving, at all. Her eyes were on the ground. Along with the rain, went a few teardrops.</p>
<p>She turned six today.</p>
<p>Minutes passed. The soaked girl let out a few coughs. She didn’t answer to anyone. Her legs were shaking, as if she wouldn’t stand any longer. But there she was, standing still. She cries out a little, but tried her best not to let anyone hear her.</p>
<p>This was the first time she ever felt alone.</p>
<p>In the heavy rain, came a light. The light got stronger, as wheels splashed the water. The mysterious black car stopped by her side. Inside the back seat was a woman. Black skirt, white shirt, little bow tie - not much to say about her, a businesswoman. She stepped out, opening her umbrella and walked towards the little girl.</p>
<p>“Carol, why are you standing outside of our house? Is that an umbrella, why aren’t you opening it?”</p>
<p>The girl stopped crying.</p>
<p>“It… it’s my birthday to…today. An…and mom is ten…twenty minutes late.”</p>
<p>“I’m so sorry dear! But I’ve bought you this… Happy Birthday Carol!”</p>
<p>The woman pulled a small box from the driver’s seat. A box of Godiva.</p>
<p>“That’s for you! You should go inside now, Carol. Have a bath! And I was asking you, why didn’t you open…”</p>
<p>Carol wasn’t carrying an umbrella.</p>
<p>“It’s a chocolate box, thanks mom. But you were late.”</p>
<hr>
<p>I’ve never written a horror piece before. So it clearly lacks some elements (the wind up is weak, I suck at describing stuff…)</p>
<p>I have to try better next time!</p>
<p>I rate myself 2/10.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://natsukagami.github.io/2017/10/24/Random-Rain/" data-id="cja0ufag8003cjuoe70rrrfmk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/english/">english</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/random/">random</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/story/">story</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/writing/">writing</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HSGSO-2017-Editorial" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/01/HSGSO-2017-Editorial/" class="article-date">
  <time datetime="2017-07-01T10:00:00.000Z" itemprop="datePublished">2017-07-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Editorials/">Editorials</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/01/HSGSO-2017-Editorial/">HSGSO 2017 Editorial</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Đây chắc là một trong những bài viết được chờ đợi nhất sau kì thi HSGSO 2017 vừa rồi. Ngoài chữa bài, mình sẽ đưa ra một số thống kê về đề và lượng người giải được!</p>
<p>Phần chữa bài được thực hiện bởi mình và bạn <a href="https://www.facebook.com/HiImMing" target="_blank" rel="external">Nguyễn Đinh Quang Minh</a>. Nếu có câu hỏi gì bạn có thể hỏi mình hoặc Minh qua facebook.</p>
<h1 id="De-bai"><a href="#De-bai" class="headerlink" title="Đề bài"></a>Đề bài</h1><p>Các bạn có thể tải về đề bài tại <a href="https://www.facebook.com/groups/163215593699283/1468547493166080/?match=aHNnc28%3D" target="_blank" rel="external">đây</a>. Trong phần comment của link cũng có chữa tóm tắt một vài bài do các bạn của dự tuyển Tổng Hợp.</p>
<h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="Muc-luc"><a href="#Muc-luc" class="headerlink" title="Mục lục"></a>Mục lục</h2><h3 id="Ngay-1"><a href="#Ngay-1" class="headerlink" title="Ngày 1"></a>Ngày 1</h3><ol>
<li><a href="#number">number</a></li>
<li><a href="#race">race</a></li>
<li><a href="#tree">tree</a></li>
<li><a href="#inversion">inversion</a></li>
</ol>
<h3 id="Ngay-2"><a href="#Ngay-2" class="headerlink" title="Ngày 2"></a>Ngày 2</h3><ol>
<li><a href="#matrix">matrix</a></li>
<li><a href="#string">string</a></li>
<li><a href="#p2grp">p2grp</a></li>
<li><a href="#turtle">turtle</a></li>
</ol>
<h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><ul>
<li>Author: thầy Phương, Phạm Cao Nguyên</li>
<li>Tester: Nguyễn Hoàng Hải Minh<h3 id="Cac-subtask-nho"><a href="#Cac-subtask-nho" class="headerlink" title="Các subtask nhỏ"></a>Các subtask nhỏ</h3></li>
<li><strong>Subtask 1</strong> ($S \le 20$) có thể dễ dàng giải bằng thuật quay lui, thử tất cả các trường hợp cắt với độ phức tạp $O(M_1 \times M_2 … \times M_N)$.</li>
<li><strong>Subtask 2</strong> ($S \le 500, K \le 18$): Do giới hạn của $K$, đáp số là một số không quá giới hạn <code>long long</code>, vì vậy ta có thể thực hiện đơn giản phép quy hoạch động.
Gọi $f[i][j]$ là số lớn nhất có thể tạo được nếu ta sử dụng các đoạn từ 1 đến $i$ và lấy tổng cộng $j$ chữ số.
Hiển nhiên $f[0][0] = 0$. Ta có:
$$f[i][j] = \sum\limits_{k=0}^{\min(M<em>i, j)} f[i - 1][j - k] \times 10^k + \overline{A</em>{i,1}A<em>{i,2}…A</em>{i,k}}$$
Đáp số chính là $f[N][K]$. Lưu ý độ phức tạp của thuật toán này chỉ là $O(SK)$ chứ không phải $O(N^2K)$.</li>
</ul>
<h3 id="Tham-lam-1-chu-so"><a href="#Tham-lam-1-chu-so" class="headerlink" title="Tham lam 1 chữ số"></a>Tham lam 1 chữ số</h3><p>Subtask 3 có một giới hạn khá lạ: Mỗi đoạn có độ dài đều là 1. Như vậy, việc chọn một đoạn chỉ đơn giản là lấy hoặc không. Ta có thể ra một thuật toán tham lam cho subtask này.</p>
<p>Ta có thể thấy, ở mỗi vị trí từ trái sang phải ta sẽ luôn ưu tiên số lớn nhất ở trước. Thật vậy, dễ dàng chứng minh điều này: Khi so sánh 2 số có cùng độ dài, ta chỉ cần tìm chữ số đầu tiên khác nhau từ trái sang và so sánh chúng.</p>
<p>Ý tưởng tham lam như sau. Giả sử ta đã lấy $x$ chữ số, chữ số cuối cùng ta lấy ở vị trí $i$. Ta có các nhận xét sau về chữ số tiếp theo cần lấy (ở vị trí $j$):</p>
<ul>
<li>Hiển nhiên ta không thể lấy tiếp ở các vị trí $j \le i$.</li>
<li>Hiển nhiên không kém, ta không thể lấy ở các vị trí $j &gt; N - (K - x) + 1$. Đơn giản là, nếu lấy ở các vị trí này, ta không còn đủ chữ số để dựng số có $K$ chữ số nữa.</li>
<li>Trong các vị trí còn lại, ta luôn chọn vị trí có chữ số lớn nhất. Điều này hiển nhiên đúng, vì về sau ta chọn thế nào thì cũng ra số lớn hơn số được tạo ra nếu ta không chọn chữ số lớn nhất ở bước này.</li>
<li>Trong các vị trí có cùng giá trị, lấy vị trí trái nhất. Điều này đảm bảo ta có nhiều cơ hội hơn để lấy số lớn hơn ở vị trí tiếp theo.</li>
</ul>
<p>Như vậy subtask 3 có thể giải với độ phức tạp $O(10 \times N)$. Hãy lưu ý subtask này, vì ý tưởng tham lam là chìa khóa để giải subtask cuối!</p>
<h3 id="Cai-tien-quy-hoach-dong"><a href="#Cai-tien-quy-hoach-dong" class="headerlink" title="Cải tiến quy hoạch động"></a>Cải tiến quy hoạch động</h3><p>2 subtask tiếp theo (4 và 5) chỉ là việc cài đặt công thức quy hoạch động của subtask 2 lên với số lớn. Dễ dàng nhận thấy ta chỉ phải cài đặt phép cộng số lớn, và đáp số không quá $10^K$ nên độ phức tạp là $O(SK^2)$.</p>
<p>Dễ dàng cài số lớn qua subtask 4, nhưng để qua subtask 5 sẽ cần thêm một chút cải tiến để lọt time limit (vd nén 9 chữ số vào một <code>int</code> thay vì giữ từng chữ số, cộng dồn đoạn để giảm số phép tính,…)</p>
<h3 id="Subtask-cuoi"><a href="#Subtask-cuoi" class="headerlink" title="Subtask cuối"></a>Subtask cuối</h3><p>Để giải được subtask cuối, ta cần bỏ đi suy nghĩ quy hoạch động và quay lại với ý tưởng tham lam.</p>
<p><strong>Tại sao ý tưởng của subtask 3 không thể áp dụng được ngay vào subtask cuối?</strong> Bởi vì trong mỗi đoạn, ta bắt buộc phải chọn 1 đoạn tiền tố để đặt vào đáp số. Nhiều khi, chữ số phía sau lớn nhưng đoạn chữ số phía trước không tối ưu.</p>
<p><strong>Ta có thể chỉ xét chữ số tiếp theo của chuỗi đang lấy cuối cùng, hoặc đầu của các chuỗi phía sau.</strong> Đây là một nhận xét đúng. Thật vậy: Kiểu gì bạn cũng phải đặt chữ số đầu tiên của một chuỗi nếu lấy chuỗi đó. Và nếu chữ số đầu tiên có lựa chọn tốt hơn: điều đúng đắn là bỏ cả chuỗi.</p>
<p><strong>Tuy nhiên, có một vấn đề khác.</strong> Khi có nhiều lựa chọn chữ số tiếp theo giống nhau, <strong>chọn chữ số trái cùng không phải lựa chọn tối ưu</strong>. Bản chất là vì lựa chọn của bạn còn làm ảnh hưởng đến tập đáp số tối ưu phía sau:</p>
<ul>
<li>Nếu $M_i = 1$ với mọi $i$, lựa chọn của bạn luôn là $(x_j, y_j)$ (giá trị, vị trí) với chữ số $j$ (từ trái sang) và $j$ luôn tốt hơn $j + 1$.</li>
<li>Khi điều kiện 1 không còn nữa, không phải lúc nào $j$ cũng tốt hơn $j + 1$. Xét trường hợp sau: <code>5 6</code> và <code>5 7</code> ($K = 2$). Nếu bạn chọn số <code>5</code> bên trái, tiếp theo bạn chỉ được chọn giữa <code>6</code> và <code>5</code> cho chữ số tiếp theo. Trong khi đó đáp số hiển nhiên là <code>57</code>.</li>
</ul>
<p>Tuy vậy, ta nhận thấy đáp án tối ưu vẫn luôn xuất phát từ chữ số lớn nhất, và đáp án vẫn là chọn số lớn nhất có thể ở mỗi bước. Vậy ta vẫn có thể đưa số <code>5</code> vào, chỉ có điều <strong>ta chưa quyết định đấy là số 5 ở vị trí nào</strong>. Hay hiểu kiểu khác, trước tiên ta chọn <code>5</code> của <code>5 6</code>, nhưng do <code>5 7</code> có đầu <code>5</code> trùng với đuôi <code>5</code> của ta nên ta xóa <code>5</code> của <code>5 6</code> đi và thêm cả <code>5 7</code> vào.</p>
<p>Tóm tắt lại, thuật toán của ta như sau:
Giả sử ta đã có $i$ chữ số $x_1, x_2, …, x_i$ ($x_i$ ở dãy $j$), ta sẽ có tập lựa chọn cho chữ số tiếp theo (dãy $p$ vị trí $q$) như sau:</p>
<ul>
<li>Nó phải thuộc dãy $p \ge j$. Hiển nhiên ta không thể lấy lại một dãy trước đó.</li>
<li>Sau nó phải có ít nhất $K - i - 1$ chữ số (từ nó về cuối dãy, và tổng tất cả dãy phía sau).</li>
<li>$p = j$ và nó là chữ số đứng sau $x_i$, <em>hoặc</em></li>
<li>$p &gt; j$, $x<em>{i - k} = A[p][q - 1 - k]$ với mọi $0 \le k &lt; q - 1$. Khi chọn lựa chọn này, ta xóa tất cả $x</em>{i - q + 2}..x_i$ và thêm vào $A[p][1..q]$.</li>
</ul>
<p>Dễ dàng chứng minh ở mỗi bước, ta đều lấy được chữ số lớn nhất có thể lấy được khi có prefix dựng từ bước trước đó (do vậy, nếu prefix tối ưu thì theo phép so sánh số, dãy mới là tối ưu). Do ở bước đầu (prefix rỗng), lựa chọn là tối ưu, nên theo quy nạp thuật toán tham là tối ưu.</p>
<p>Ta có thể cài thuật toán này trong độ phức tạp $O(SK)$.</p>
<h3 id="Mot-chut-thong-ke"><a href="#Mot-chut-thong-ke" class="headerlink" title="Một chút thống kê"></a>Một chút thống kê</h3><p><img src="/images/score_number.png" alt=""></p>
<p>Về điểm số:</p>
<ul>
<li>Có một bạn duy nhất được <strong>99</strong> điểm (Bùi Hồng Đức). Xin chúc mừng Đức đã ra được thuật toán đúng cho subtask cuối. Thật vậy, Đức chỉ còn 1 test lắt léo duy nhất: Đề bài yêu cầu in ra số tạo từ $K$ chữ số đã chọn, mà đã là số thì phải không có số <code>0</code> ở đầu :( Kể ra bài đã khó, test cũng khó, sorry mọi người vì cái test quái gở này.</li>
<li>Có 12 bạn được <strong>73-76</strong> điểm. Khi sinh test mình đã tính đến việc các bạn sử dụng tham lam của subtask 3, đưa thẳng vào subtask 6 (chỉ qua nhận xét đầu tiên). Đây là số điểm các bạn nhận được :) Kể ra không cho điểm nào thì cũng hơi ác, nhưng cho nhiều điểm quá thì cũng không đáng (nhớ rằng tối ưu bignum chỉ được thêm 10 điểm). Thật sự 6 điểm khá là nhiều cho một thuật sai khá là rõ ràng, và còn vài bạn còn cài sai thuật đó nữa…</li>
<li>6 bạn được <strong>70</strong> điểm. Chúc mừng 6 bạn đã qua được mốc quan trọng của một bài khó: cắn nhiều nhất có thể. Đây là chiến thuật hữu dụng nhất khi thi quốc gia!</li>
<li>Còn lại 71 bạn có điểm dương, trải dài khá đều từ 1 đến 65 điểm. Rất tuyên dương cố gắng của các bạn! Hãy cố lên! Đặc biệt với những bạn được 1 điểm, mình không hiểu tại sao có thể được 1 điểm…</li>
</ul>
<p>Về bộ test:</p>
<ul>
<li>Bản thân mình khá hài lòng về bộ test mình sinh ra. Có đủ điểm cho người liều lĩnh, đủ điểm cho người chắc ăn, đủ lỗi để hành người sai,…</li>
<li>Trong bộ test (sau này sẽ được up), có 2 test được sinh ra để giết một nhận xét tham lam của subtask 6… Đố bạn nào biết đó là nhận xét gì :)</li>
</ul>
<h2 id="race"><a href="#race" class="headerlink" title="race"></a>race</h2><ul>
<li>Author: Nguyễn Đinh Quang Minh</li>
<li>Tester: Nguyễn Hoàng Hải Minh</li>
</ul>
<h3 id="Bai-toan-lop-bon-va-thuat-toan-O-N-3"><a href="#Bai-toan-lop-bon-va-thuat-toan-O-N-3" class="headerlink" title="Bài toán lớp bốn và thuật toán O(N^3)"></a>Bài toán lớp bốn và thuật toán O(N^3)</h3><blockquote>
<p>Ba người $A$, $B$, $C$ xuất phát ở ba vị trí $x_A$, $x_B$, $x_C$ trên một đường thẳng, cùng đi về một hướng với vận tốc $v_A$, $v_B$, $v_C$. Hỏi có thời điểm nào người $B$ nằm ở trung điểm 2 người còn lại hay không?</p>
</blockquote>
<p>Thầy Phương từng đố mình bài toán trên. Nếu bỏ qua dữ kiện ‘đây là bài toán lớp bốn’ thì chúng ta (tất nhiên kể cả mình) đều sẽ cầm bút giải phương trình bậc nhất rồi tìm nghiệm. Nhưng hãy thử nghĩ <em>như một học sinh lớp bốn</em> xem sao…</p>
<p>Cách giải của các bé lớp bốn cho bài toán này như sau: giả sử có thêm một người $D$ di chuyển sao cho $D$ <em>luôn nằm ở trung điểm</em> của $A$ và $C$, khi đó nếu $B$ gặp $D$ tức là <strong>$B$ nằm ở trung điểm $AC$</strong>. Vị trí xuất phát và vận tốc của $D$ như thế nào cho hợp lý? Hiển nhiên là trung bình cộng của $A$ và $C$, tức là $x_D = \dfrac{x_A + x_C}{2}$, $v_D = \dfrac{vA + vC}{2}$.</p>
<p>Khi đã có người D rồi thì có 3 trường hợp xảy ra:</p>
<ol>
<li>$B$ luôn chạy trùng với $D$: có vô hạn thời điểm thỏa mãn;</li>
<li>$B$ không gặp $D$ (kết quả tăng 0);</li>
<li>$B$ có gặp $D$ (kết quả tăng 1).</li>
</ol>
<p>Điều kiện cụ thể cho từng trường hợp xảy ra như sau:</p>
<table>
<thead>
<tr>
<th></th>
<th>$v_B &lt; v_D$</th>
<th>$v_B = v_D$</th>
<th>$v_B &gt; v_D$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$x_B &lt; x_D$</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>$x_B = x_D$</td>
<td>1</td>
<td>vô hạn</td>
<td>1</td>
</tr>
<tr>
<td>$x_B &gt; x_D$</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Như vậy thuật giải $O(N^3)$ chỉ đơn giản là duyệt tất cả các bộ ba <em>phân biệt</em> rồi kiểm tra theo bảng trên.</p>
<h3 id="Dieu-kien-tren-nhin-quen-quen"><a href="#Dieu-kien-tren-nhin-quen-quen" class="headerlink" title="Điều kiện trên nhìn quen quen?"></a>Điều kiện trên nhìn quen quen?</h3><p>Để tối ưu thuật toán, ta sẽ nghĩ đến việc duyệt 2 người $A$ và $C$, tính được thông tin người $D$, rồi tìm số người $B$ thỏa mãn. Cụ thể hơn:</p>
<ul>
<li>Nếu tồn tại người B sao cho x_B = x_D, v_B = v_D thì trả về kết quả là <code>infinity</code>.</li>
<li>Cộng vào kết quả số người B thỏa mãn $x_B \le X_D$, $v_B &gt; v_D$.</li>
<li>Cộng vào kết quả số người B thỏa mãn $x_B \ge x_D$, $v_B &lt; v_D$.</li>
</ul>
<p>Hai điều kiện trên (trừ điều kiện in ra <code>infinity</code> rất dễ) đều khá quen thuộc: ý tưởng của nó giống với <a href="https://natsukagami.github.io/2017/05/01/HSGSO-2016-Editorial/#polylines">bài polylines của năm ngoái</a>. Ta có thể sort tất cả những người $B$ và $D$ theo chiều $v$ tăng dần rồi sử dụng cấu trúc dữ liệu BIT cho chiều $x$.</p>
<h3 id="Khong-biet-cai-BIT-thi-sao"><a href="#Khong-biet-cai-BIT-thi-sao" class="headerlink" title="Không biết cài BIT thì sao?"></a>Không biết cài BIT thì sao?</h3><p>Thì <del>bạn nên học cài BIT</del> ta sẽ thử một thuật giải không sử dụng BIT <del>mà sẽ sử dụng IT</del>.</p>
<p>Trước hết, chúng ta chỉ quan tâm đến giá trị $x$ và $v$ của mỗi người <em>đứng thứ mấy</em> nên ta hoàn toàn có thể sort các giá trị $x$ và $v$ lại rồi “đánh số” lại theo thứ tự của giá trị trong dãy được sort.
Bây giờ khi có một người $D$ nào đó, ta có thể biết $x_D$ đứng ở vị trí thứ mấy trong mảng $x$ bằng chặt nhị phân, tương tự với $v_D$. Điều này sẽ giúp ta giải quyết bài toán bằng mảng cộng dồn 2 chiều thay vì BIT.</p>
<p>Trước hết, ta lập một mảng $A[1..N][1..N]$, $A[i][j] = 1$ có nghĩa là tồn tại một người có giá trị $x$ đứng thứ $i$ và giá trị $v$ đứng thứ $j$, ngược lại $A[i][j] = 0$. Giả sử xét một người $D$ có $x_D$ đứng ở vị trí thứ $X$, $v_D$ đứng ở vị trí thứ $V$. Như vậy, số người thỏa mãn $x_B \le x_D$, $v_B &gt; v_D$ chính là tổng các số trong hình chữ nhật con có góc trên trái là $(1, V)$, góc dưới phải là $(X, N)$ và được tính trong $O(1)$ bằng mảng cộng dồn.</p>
<h3 id="One-more-thing"><a href="#One-more-thing" class="headerlink" title="One more thing"></a>One more thing</h3><p>Để cài đặt cho tiện, bạn nên nhân đôi tất cả tọa độ và vận tốc lên ¯\_(ツ)_/¯</p>
<h3 id="Score-Distribution"><a href="#Score-Distribution" class="headerlink" title="Score Distribution!"></a>Score Distribution!</h3><p><img src="/images/score_race.png" alt=""></p>
<h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><ul>
<li>Author: Phạm Đức Thắng</li>
<li>Tester: Nguyễn Hoàng Hải Minh</li>
</ul>
<h3 id="N-1"><a href="#N-1" class="headerlink" title="$N = 1$!"></a>$N = 1$!</h3><p>Trước tiên, cần phải để ý nếu $N = 1$ thì đỉnh duy nhất phải có bậc <strong>0</strong>. Khi đó, đường đi dài nhất là 1.</p>
<p>Rất nhiều bạn đã chết test này!</p>
<h3 id="Subtask-nho"><a href="#Subtask-nho" class="headerlink" title="Subtask nhỏ"></a>Subtask nhỏ</h3><ul>
<li>Subtask 1 ($N \le 15$), bạn có thể backtrack mọi cách dựng cây?</li>
</ul>
<h3 id="Dung-duoc-cay-khong"><a href="#Dung-duoc-cay-khong" class="headerlink" title="Dựng được cây không?"></a>Dựng được cây không?</h3><p>Điều kiện sau là điều kiện cần và đủ để tồn tại cây:</p>
<ul>
<li>Tổng bậc là $2N - 2$</li>
<li>Không đỉnh nào có bậc quá $N - 1$.</li>
<li>Không đỉnh nào có bậc dưới $1$.</li>
</ul>
<p>Dễ dàng chứng minh điều kiện này bằng quy nạp.</p>
<p>Subtask 2 sinh ra để bạn kiểm tra việc dựng cây nếu không biết điều này :D</p>
<h3 id="Dung-toi-uu"><a href="#Dung-toi-uu" class="headerlink" title="Dựng tối ưu!"></a>Dựng tối ưu!</h3><p>Gọi $x$ là số nút có bậc lớn hơn 1 (tức không phải lá). Ta sẽ chứng minh nếu $N \ge 2$ thì đáp số là $x + 1$.</p>
<p>Thật vậy, ta gọi tập đỉnh không phải lá là $A_1, A_2, …, A_x$. Trước tiên, dựng tập cạnh như sau:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lá - A[1] - A[2] - ... - A[x] - lá</div></pre></td></tr></table></figure></p>
<p>Dễ dàng nhận thấy tổng bậc còn lại của các đỉnh không phải lá là $(2N - 2) - (N - x) - 2x = N - x - 2$, số lá còn lại là $N - x - 2$. Như vậy ta có thể thêm lá vào các bậc còn thiếu của từng đỉnh. Cây đã dựng xong! Đường đi dài nhất trên cây này chắc chắn là $x + 1$.</p>
<p>Không khó để chứng minh đáp số không thể lớn hơn $x + 1$ (đường đi đơn không thể đi qua 3 lá). Vì vậy $x + 1$ là đáp án tối ưu.</p>
<h3 id="Phan-bo-diem"><a href="#Phan-bo-diem" class="headerlink" title="Phân bố điểm"></a>Phân bố điểm</h3><p>Rất nhiều bạn AC bài này, tuy nhiên cũng rất nhiều người bị 98 điểm do thiếu $N = 1$. Hãy cẩn thận với những trường hợp biên!</p>
<p><img src="/images/score_tree.png" alt=""></p>
<h2 id="inversion"><a href="#inversion" class="headerlink" title="inversion"></a>inversion</h2><ul>
<li>Author: Nguyễn Thành Vinh</li>
<li>Tester: Nguyễn Hoàng Hải Minh</li>
</ul>
<h3 id="Chay-trau"><a href="#Chay-trau" class="headerlink" title="Chạy trâu!"></a>Chạy trâu!</h3><p>For từng đoạn con, tính cặp nghịch thế trâu, $O(N^4)$ ăn sub 1. Ta có thể cải tiến hơn, tính nghịch thể trong $O(N \log N)$ bằng BIT, tuy nhiên vẫn chưa đủ để ăn subtask 2.</p>
<h3 id="Tinh-tien-Level-1"><a href="#Tinh-tien-Level-1" class="headerlink" title="Tịnh tiến Level 1"></a>Tịnh tiến Level 1</h3><p>Nhận thấy, mỗi lần for đoạn con là một lần tính lại. Đoạn $(i, j)$ chỉ khác đoạn $(i, j + 1)$ một lượng là số phần tử trong khoảng $(i, j)$ mà lớn hơn $A[j + 1]$. Như vậy, ta có thể for $i$ rồi vừa tăng $j$ vừa tính thêm, giảm độ phức tạp xuống $O(N^2 \log N)$.</p>
<h3 id="Tinh-tien-Level-2"><a href="#Tinh-tien-Level-2" class="headerlink" title="Tịnh tiến Level 2"></a>Tịnh tiến Level 2</h3><p>Từ việc tịnh tiến trên, ta nhận thấy rằng nếu $i \le j &lt; k$ thì $(i, j)$ luôn có số nghịch thế không quá số nghịch thế của $(i, k)$.</p>
<p>Đồng thời, nhận xét cũng đúng với $(j, i)$ và $(k, i)$ nếu $k &lt; j \le i$.</p>
<p>Giả sử $j$ là số lớn nhất sao cho $(i, j)$ có số nghịch thế $&lt; K$. Dễ dàng nhận thấy tất cả $(i, j’)$ với $j &lt; j’ \le N$ đều là đáp án. Như vậy với mỗi $i$ ta chỉ cần tìm $j$ là đủ.</p>
<p>Lại có $(i, j)$ có số nghịch thế $&lt; K$, vì thế $(i + 1, j)$ chắc chắn có số nghịch thế $&lt; K$. Ta không cần for các giá trị nhỏ hơn $j$ để kiểm tra nữa. Thay vì for lại $j$, ta xóa $i$ khỏi đoạn, giảm số nghịch thế đi 1 lượng là số số nhỏ hơn $A[i]$.</p>
<p>2 con trỏ $i$ và $j$ đều tăng từ 1 đến $N$, mỗi lần tăng con trỏ phải update mất $O(\log N)$. Độ phức tạp của thuật toán là $O(N \log N)$.</p>
<h3 id="Phan-bo-diem-1"><a href="#Phan-bo-diem-1" class="headerlink" title="Phân bố điểm"></a>Phân bố điểm</h3><p>Đây là một bài khá cơ bản, dù vậy điểm khá là thấp so với bọn mình kì vọng, chủ yếu mọi người chỉ dừng ở subtask 2.</p>
<p><img src="/images/score_inversion.png" alt=""></p>
<h2 id="matrix"><a href="#matrix" class="headerlink" title="matrix"></a>matrix</h2><ul>
<li>Author: Nguyễn Đinh Quang Minh</li>
<li>Tester: Phạm Cao Nguyên, Nguyễn Hoàng Hải Minh</li>
</ul>
<h3 id="Cac-subtask-nho-1"><a href="#Cac-subtask-nho-1" class="headerlink" title="Các subtask nhỏ"></a>Các subtask nhỏ</h3><ul>
<li><strong>Subtask 1</strong> ($N = 1$), đây là subtask cho điểm vì bản thân cả bảng đã được chứa trong mảng $B[]$. Nếu xor tất cả phần tử trong mảng $B[]$ bằng $A[1]$ thì có 1 đáp án chính là mảng $B[]$. Nếu không thì không có đáp án nào cả. Độ phức tạp $O(M)$.</li>
<li><strong>Subtask 2</strong> ($NM \le 20$), từ điều kiện ta suy ra $\min(N, M) \le \sqrt{20} \le 5$. 
Không mất tính tổng quát ta giả sử $M \le 5$ (nếu không ta xoay bảng lại), ta có thể quy hoạch động $f[i][mask]$ là số cách tạo các hàng từ 1 đến $i$, với tổng xor từng cột được biểu diễn trong $mask$. Sau đó ta có thể for tất cả các mask $m$ có thể của hàng $i + 1$, update vào $f[i + 1][mask \oplus m]$. Độ phức tạp là $O(N \times (2^M)^2)$. 
Hoặc ta có thể backtrack giá trị của tất cả phần tử của bảng, độ phức tạp là $O(2^{N + M})$.</li>
<li><strong>Subtask 3</strong> ($N \le 10$, $M \le 2000$), ta sẽ cải tiến thuật toán quy hoạch động phía trên. Thay vì mỗi lần ta thêm cả cột (mất $O(2^N)$), ta chỉ thêm từng ô. 
Gọi $f[i][j][mask]$ là số cách điền các ô từ $(i, j)$ trở đi (theo từng cột, rồi từng hàng), và xor các phần tử đã đặt vào trước đó của mỗi hàng được biểu diễn trong mask. Ta tính từ $f[i + 1][j][mask’]$ hoặc $f[1][j + 1][mask’]$, với điều kiện là khi điền xong mỗi cột thì xor cột đó phải bằng $B[j]$. Ta có thể kiểm tra điều này bằng cách kiểm tra $X = B[1] \oplus B[2] \oplus … \oplus B[j]$ có bằng xor các bit trong $mask$ không. 
Độ phức tạp là $O(NM2^N)$.</li>
</ul>
<h3 id="Dung-mot-dap-an"><a href="#Dung-mot-dap-an" class="headerlink" title="Dựng một đáp án"></a>Dựng một đáp án</h3><p>Trước khi tìm hiểu xem có bao nhiêu đáp án thỏa mãn, ta cần phải kiểm tra xem có tồn tại đáp án không đã.</p>
<p>Hiển nhiên nếu tổng xor của $A[]$ khác tổng xor của $B[]$ thì không thể tồn tại bảng thỏa mãn. Còn lại, ta sẽ chứng minh luôn tồn tại bảng thỏa mãn.</p>
<p>Gọi tổng xor cả bảng là $S$.</p>
<p>Xét bảng $N \times M$ được dựng như sau:</p>
<ul>
<li>Với $i &lt; N$ và $j &lt; M$: điền <code>0</code>.</li>
<li>Với $i = N$ và $j &lt; M$: điền $B[j]$.</li>
<li>Với $i &lt; N$ và $j = M$: điền $A[i]$.</li>
<li>Xét ô $(N, M)$. Ta có giá trị $b[N][M] = A[N] \oplus B[1] \oplus B[2] \oplus … \oplus B[M - 1]$, hay $b[N][M] = A[N] \oplus S \oplus B[M]$. Tất nhiên phân tích theo cột ta cũng sẽ ra công thức này, và vì $S$ xác định nên có duy nhất 1 cách điền ô $(N, M)$. </li>
</ul>
<p>Vậy tồn tại bảng thỏa mãn.</p>
<h3 id="Co-bao-nhieu-bang-thoa-man"><a href="#Co-bao-nhieu-bang-thoa-man" class="headerlink" title="Có bao nhiêu bảng thỏa mãn?"></a>Có bao nhiêu bảng thỏa mãn?</h3><p>Giả sử ta có bảng $b[][]$ thỏa mãn. </p>
<p>Nếu ta flip giá trị $b[i][j]$ ($i &lt; N$, $j &lt; M$), ta có thể flip cả $b[i][M]$, $b[N][j]$ và $[N][M]$ để ra một bảng mới vẫn đúng. (mỗi hàng mỗi cột ảnh hưởng đều bị flip tổng xor 2 lần).</p>
<p>Nếu ta giữ nguyên $b[i][j]$ với mọi $i &lt; N$ và $j &lt; M$, dễ dàng chứng minh cách điền các ô còn lại là duy nhất. Thật vậy, $b[i][M]$ ($i &lt; M$) phải xác định duy nhất để tổng xor các ô trong hàng $i$ bằng $A[i]$, tương tự với $b[N][j]$ ($j &lt; N$). Còn lại ô $(N, M)$, tất nhiên vì hàng và cột cuối cũng có tổng xor xác định nên giá trị của ô cũng chỉ có tối đa một.</p>
<p>Từ 2 nhận xét trên, ta thấy với mỗi cách điền bảng $(N - 1)\times (M - 1)$ ở góc trái trên ta có duy nhất 1 cách điền nốt thỏa mãn. Vậy số bảng thỏa mãn là $2^{(N - 1)(M - 1)}$. </p>
<p>Kiểm tra điều kiện tồn tại mất $O(N + M)$, tính số bảng mất $O(\log(NM))$, dựng 1 bảng thỏa mãn mất $O(NM)$.</p>
<h3 id="Thong-ke"><a href="#Thong-ke" class="headerlink" title="Thống kê"></a>Thống kê</h3><p>Subtask 2 là một subtask rất đơn giản (backtrack lấy 20 điểm), vậy mà số bạn làm được khá là ít. Subtask 3 đòi hỏi kỹ thuật quy hoạch động khó hơn, không nhiều bạn làm được. </p>
<p>Chúc mừng 4 bạn làm được 100 điểm!</p>
<p><img src="/images/score_matrix.png" alt=""></p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ul>
<li>Author: Vương Hoàng Long</li>
<li>Tester: Nguyễn Hoàng Hải Minh</li>
</ul>
<h3 id="Subtask-nho-1"><a href="#Subtask-nho-1" class="headerlink" title="Subtask nhỏ"></a>Subtask nhỏ</h3><p>Do độ dài của 2 xâu không quá $10^8$ nên ta có thể thực hiện for trâu để giải subtask này. Tất nhiên có một số điều sau phải chú ý:</p>
<ul>
<li>Tuyệt đối không dựng cả xâu. Dựng xâu mất thời gian hằng số rất lớn, có thể làm bạn bị TLE trước cả khi thực hiện so sánh. Chỉ for các chỉ số lặp lại.</li>
<li>Để tăng tốc, không dùng phép mod để tính nhanh chỉ số. </li>
</ul>
<p>Độ phức tạp là $O(|A|)$.</p>
<h3 id="Subtask-lon"><a href="#Subtask-lon" class="headerlink" title="Subtask lớn"></a>Subtask lớn</h3><p>Để đơn giản cho việc mod ta coi xâu đánh số từ 0.</p>
<p>Nhận thấy phần tử thứ $i$ của xâu $X$ sẽ được so sánh với các phần tử $i \mod |Y|, (i + |X|) \mod |Y|, …, (i + (n - 1)|X|) \mod |Y|$ của $Y$.</p>
<p>Không khó để nhận ra dãy này có chu trình độ dài $|Y| / \gcd(|X|, |Y|)$. Không khó để chứng minh điều này: $|X||Y| / \gcd(|X|, |Y|)$ chính là <em>bội chung nhỏ nhất</em> của $|X|$ và $|Y|$, bội dương đầu tiên của $|X|$ chia hết cho $|Y|$.</p>
<p>Như vậy, ta chỉ cần chia $Y$ thành các chu trình tương ứng, sau đó tính trước số kí tự từng loại là có thể so sánh 1 vị trí của $X$ với 1 chu trình trong $O(1)$.</p>
<p>Độ phức tạp là $O(|Y| + |X|)$.</p>
<h3 id="Thong-ke-1"><a href="#Thong-ke-1" class="headerlink" title="Thống kê"></a>Thống kê</h3><p>Đây là bài dễ của ngày 2. Tuy vậy mình không nghĩ là có ít người AC như vậy. Có lẽ tại vì không nhiều người biết đến việc chu trình BCNN? </p>
<p><img src="/images/score_string.png" alt=""></p>
<h2 id="p2grp"><a href="#p2grp" class="headerlink" title="p2grp"></a>p2grp</h2><ul>
<li>Author: Nguyễn Khánh</li>
<li>Tester: Nguyễn Hoàng Hải Minh</li>
</ul>
<h3 id="Subtask-1"><a href="#Subtask-1" class="headerlink" title="Subtask 1"></a>Subtask 1</h3><p>Với $n$ và $m$ không quá 20, các cạnh không quá $2^{m-1}$, chúng ta có thể dựng đồ thị rồi sử dụng thuật toán tìm đường đi ngắn nhất bất kì (Floyd, Dijkstra hoặc thậm chí là backtrack). Kết quả không vượt quá số nguyên 64 bit nên cũng không có gì bận tâm về cách cài đặt.</p>
<h3 id="Subtask-2"><a href="#Subtask-2" class="headerlink" title="Subtask 2"></a>Subtask 2</h3><p>Thuật toán Floyd tìm đường đi ngắn nhất cho mọi cặp đỉnh chạy trong độ phức tạp $O(n^3)$ nên hoàn toàn có thể vượt qua subtask này. Tuy nhiên, kết quả không còn đủ nhỏ để lưu dưới dạng số nguyên nữa, vì vậy ta cần cài thêm hàm cộng 2 dãy nhị phân.</p>
<h3 id="Subtask-3"><a href="#Subtask-3" class="headerlink" title="Subtask 3"></a>Subtask 3</h3><p>Tất nhiên, ngoài Floyd, chúng ta có thể chạy thuật toán Dijkstra từ mỗi đỉnh của đồ thị. Mỗi lần chạy Dijkstra có độ phức tạp $O((n+m) * \log n)$, nên tổng độ phức tạp sẽ là $O(n(n+m)\log n \times C)$, trong đó $C$ là chi phí cộng 2 dãy nhị phân.</p>
<p>Nếu cộng từng bit một của 2 dãy nhị phân lại với nhau thì $C$ sẽ rơi vào khoảng 1000 phép tính, không đủ để qua subtask này. Cách tốt hơn là cứ $x$ bit của dãy nhị phân, ta nhóm lại thành một số rồi thực hiện cộng (hiệu quả nhất là $x = 63$).</p>
<h3 id="Subtask-4"><a href="#Subtask-4" class="headerlink" title="Subtask 4"></a>Subtask 4</h3><p>Điều kiện $m &lt; n$ cho ta biết đồ thị là một cây. Giữa 2 đỉnh bất kì trên cây chỉ có duy nhất một đường đi đơn, và hiển nhiên đó là đường đi ngắn nhất.</p>
<p>Việc duyệt qua mỗi cặp đỉnh rồi tính đường đi ngắn nhất có vẻ không hiệu quả và cũng khó tối ưu được. Do đó chúng ta nghĩ đến việc thay đổi bài toán:</p>
<blockquote>
<p>Với mỗi cạnh, có bao nhiêu cặp đỉnh mà đường đi ngắn nhất đi qua cạnh đó?</p>
</blockquote>
<p>Hiển nhiên nếu ta trả lời được câu hỏi trên thì sẽ dễ dàng tính được đáp án.</p>
<p>Câu trả lời thực ra cũng rất đơn giản. Mỗi cạnh trên cây, nếu cắt đi sẽ tạo ra 2 cái cây nhỏ. Dễ thấy một cặp đỉnh mà mỗi đỉnh nằm ở một cây thì đường đi giữa chúng bắt buộc phải đi qua cạnh vừa bị cắt. Do vậy số cặp đỉnh có đường đi đi qua cạnh đó sẽ bằng tích độ lớn 2 cây con.</p>
<p>Ta đặt gốc cây ở đỉnh 1. Giả sử cạnh đang xét nối giữa đỉnh $u$ và cha của nó, thì 1 trong 2 cây con sẽ chính là cây con gốc $u$. Việc tính độ lớn cây con gốc u có thể giải quyết bằng DFS trong thời gian $O(n)$.</p>
<h3 id="Nhung-canh-khong-quan-trong"><a href="#Nhung-canh-khong-quan-trong" class="headerlink" title="Những cạnh không quan trọng"></a>Những cạnh không quan trọng</h3><p>Đọc kĩ lại đề bài, chúng ta phát hiện ra còn một chi tiết nữa mà cả 4 subtask trước đều chưa phải dùng đến: các cạnh có độ lớn $2^w$ và có trọng số <strong>phân biệt</strong>. Liệu đây có phải mấu chốt để giải quyết subtask cuối?</p>
<p>Để ý rằng trọng số của một cạnh lớn hơn hẳn tổng trọng số của các cạnh nhỏ hơn nó (vì $2^0 + 2^1 + … + 2^{x-1} &lt; 2^x$). Điều đó chứng tỏ nếu 2 đường đi có cạnh lớn nhất khác nhau thì đường đi nào có cạnh lớn nhất nhỏ hơn chắc chắn có tổng nhỏ hơn.</p>
<p>Như vậy, ta có thể lần lượt các cạnh vào đồ thị theo thứ tự trọng số tăng dần. Giả sử khi thêm cạnh $(u, v)$ mà giữa $u$ và $v$ đã có đường đi thì cạnh $(u, v)$ sẽ không nằm trong bất kì đường đi ngắn nhất nào (thay vì đi cạnh $(u, v)$ ta có thể đi đường đi ngắn nhất từ $u$ đến $v$ đã tìm được trước đó). Do đó, ta có thể bỏ cạnh $(u, v)$.</p>
<h4 id="Subtask-5-Subtask-4-D"><a href="#Subtask-5-Subtask-4-D" class="headerlink" title="Subtask 5 = Subtask 4 ?? :D ??"></a>Subtask 5 = Subtask 4 ?? :D ??</h4><p>Sau khi loại bỏ các cạnh không quan trọng, đồ thị ta thu được là một cây (!). Lí do là ta sẽ không thêm cạnh $(u, v)$ mà $u$ đã có đường đi tới $v$, tức là đồ thị sẽ không thể có chu trình. Đến đây thì subtask 5 có thể giải y hệt subtask 4 rồi :D</p>
<h3 id="Thong-ke-2"><a href="#Thong-ke-2" class="headerlink" title="Thống kê"></a>Thống kê</h3><p>Đây là một bài khá lằng nhằng để ăn điểm những sub nhỏ, nhưng thuật toán chuẩn không cần quá nhiều chi tiết cài đặt. Vì thế bài có nhiều người AC, nhưng lượng ăn subtask nhỏ nhỏ hơn.</p>
<p>Chúc mừng 8 bạn đã AC! Fun fact: 4/8 bạn giải được bài này là của THPT Chuyên Lương Thế Vinh.</p>
<p><img src="/images/score_p2grp.png" alt=""></p>
<h2 id="turtle"><a href="#turtle" class="headerlink" title="turtle"></a>turtle</h2><ul>
<li>Author: Nguyễn Đinh Quang Minh</li>
<li>Tester: Nguyễn Hoàng Hải Minh</li>
</ul>
<h3 id="BFS-trang-thai"><a href="#BFS-trang-thai" class="headerlink" title="BFS trạng thái"></a>BFS trạng thái</h3><p>Subtask 1 có giới hạn $N \le 10$, nên chỉ có $10! = 3.628.800$ trạng thái, hơn nữa từ một trạng thái có thể đi được đến tối đa là $N-1$ trạng thái khác. Vì vậy chỉ cần BFS để tìm đường đi ngắn nhất từ trạng thái hiện tại đến trạng thái đích.</p>
<h3 id="N-le-20"><a href="#N-le-20" class="headerlink" title="$N \le 20$?"></a>$N \le 20$?</h3><p>Mình thành thật xin lỗi các bạn đã bỏ công để nghĩ cách lấy 60% số điểm từ subtask 2, vì thực ra mình cũng không có cách giải nào (không phải thuật chuẩn) mà qua được subtask này cả :( . Có lẽ một thuật backtrack đặt cận tốt có thể ăn được một vài test của subtask này, nhưng mình không chắc chắn lắm.</p>
<h3 id="pos-a-i-i"><a href="#pos-a-i-i" class="headerlink" title="pos[a[i]] = i"></a><code>pos[a[i]] = i</code></h3><p>Thoạt nhìn, bước biến đổi hoán vị trong bài toán có vẻ khá phức tạp. Tuy nhiên, để ý kĩ bạn sẽ thấy, thực ra bước biến đổi bao gồm 2 thao tác:</p>
<ol>
<li>Giảm các số có giá trị từ 2 đến $K$ đi 1.</li>
<li>Gán số đang có giá trị 1 thành $K$.</li>
</ol>
<p><em>Fun fact</em>: Khi viết đề, mình đã cố giải thích bước biến đổi theo kiểu chú rùa 1 sẽ hút độ rùa của $K-1$ chú rùa còn lại nhưng cảm thấy hơi kì kì nên thôi ¯\_(ツ)_/¯</p>
<p>Chưa nhìn ra sự kì diệu của bài toán? Gợi ý: <code>pos[a[i]] = i</code> là một dòng vô cùng quan trọng trong code của mình.</p>
<p>Nếu bạn vẫn chưa nghĩ ra, hãy đọc tiếp phần bên dưới. Còn nếu nghĩ ra rồi thì cứ đọc tiếp để chắc chắn thuật toán của mình đúng.</p>
<h3 id="Thuat-toan-O-N"><a href="#Thuat-toan-O-N" class="headerlink" title="Thuật toán O(N)"></a>Thuật toán O(N)</h3><p>Nếu gọi $pos[i]$ là vị trí của số $i$ trong hoán vị, thì mảng $pos$ cũng là một hoán vị. Vậy ta thử xem thao tác trong bài toán thay đổi mảng $pos$ như thế nào?</p>
<ol>
<li>Giảm các số có giá trị từ 2 đến $K$ đi 1. Như vậy thì chính là gán $pos[1] = pos[2], pos[2] = pos[3], …, pos[K-1] = pos[K]$.</li>
<li>Gán số đang có giá trị 1 thành $K$. Vậy là gán $pos[K] = pos[1]$ (cũ).</li>
</ol>
<p>Nói tóm lại, phép biến đổi này thay đổi hoán vị $pos$ bằng cách chèn $pos[1]$ vào bất kì vị trí $K$ nào đó trong $pos$. Ta muốn đưa hoán vị $pos$ về hoán vị đơn vị (1, 2, …, $N$). Điều đó cũng có nghĩa là ta chỉ đụng vào mỗi phần tử trong hoán vị không quá một lần, bởi vì ta chỉ cần đặt nó vào một vị trí $K$ hợp lí nào đấy và không còn quan tâm đến nó nữa. </p>
<p>Vậy những số nào không cần đặt vào chỗ khác?
Giả sử ta thực hiện thao tác $x$ lần, tức là các số $pos[x+1..N]$ không bị thay đổi. Điều đó chứng tỏ ban đầu $pos[x+1] &lt; pos[x+2] &lt; … &lt; pos[N]$. Điều ngược lại cũng đúng: nếu $pos[x+1] &lt; pos[x+2] &lt; … &lt; pos[N]$ thì ta có thể dừng thao tác ở lần thứ $x$ bằng cách chèn các số $pos[1..x]$ vào các vị trí hợp lý để nhận được hoán vị đơn vị.
Như vậy, thuật toán của bài này thực ra rất đơn giản, tìm vị trí $x$ nhỏ nhất sao cho $pos[x+1] &lt; pos[x+2] &lt; … &lt; pos[N]$ rồi in ra $x$.</p>
<h3 id="Thong-ke-3"><a href="#Thong-ke-3" class="headerlink" title="Thống kê"></a>Thống kê</h3><p><img src="/images/score_turtles.png" alt=""></p>
<h4 id="In-ra-a-1-1-duoc-45-diem"><a href="#In-ra-a-1-1-duoc-45-diem" class="headerlink" title="In ra $a[1] - 1$ được 45 điểm???"></a>In ra $a[1] - 1$ được 45 điểm???</h4><p>Trong lúc sinh test, mình gặp phải vấn đề sau: nếu sinh test random thì khả năng số $N-1$ đứng sau số $N$ ($pos[N-1] &gt; pos[N]$) là rất lớn, vì vậy sẽ có chừng 50% số test đáp án là $N-1$. Mặt khác, để đáp án là $K$ thì $pos[K+1] &lt; pos[K+2] &lt; … &lt; pos[N]$, do đó sinh random thì khả năng có đáp án bé gần như bằng không. Vậy mình đã giải quyết như nào?</p>
<p>Mình quyết định sinh test bằng cách: sinh trước vị trí của $K+1, K+2, …, N$ rồi sinh random các số còn lại (tất nhiên còn thêm vài test tay nữa). Nhưng một vấn đề khác lại nảy sinh: nếu $K$ quá nhỏ so với $N$ (giả sử, $K = 100$ và $N = 500000$), thì khả năng $a[1] = K+1$ là vô cùng lớn ($= 1 - K/N$). Cách cuối cùng để giải quyết vấn đề là thêm phần truy vết các thao tác. Tuy nhiên vào phút chót, mình quyết định không làm phức tạp thêm bài toán nữa vì mình cho rằng thời gian 3.5 tiếng là khá ít, cần phải khuyến khích những người nghĩ ra đáp án hơn là đánh đố họ. Dù sao thì việc in $a[1] - 1$ được nhiều điểm hơn cả subtask 1 cũng làm mình khá buồn :(</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://natsukagami.github.io/2017/07/01/HSGSO-2017-Editorial/" data-id="cja0ufafl0011juoeyfev309c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/editorial/">editorial</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hsgso/">hsgso</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vietnamese/">vietnamese</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-05-03-Training" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/03/2017-05-03-Training/" class="article-date">
  <time datetime="2017-05-03T14:00:00.000Z" itemprop="datePublished">2017-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Training/">Training</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/03/2017-05-03-Training/">2017-05-03 Training</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hôm nay bài không phải là khó.</p>
<h1 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h1><h2 id="ballmachine"><a href="#ballmachine" class="headerlink" title="ballmachine"></a>ballmachine</h2><p>Cho một cây $N$ đỉnh có gốc, mỗi đỉnh chứa tối đa
1 quả bóng. Quả bóng từ cha sẽ rơi xuống nút
con nếu có thể. Nếu có nhiều nút con thỏa mãn,
chọn nút con có cây con chứa nút có số thứ tự
nhỏ nhất.
Thực hiện $Q$ truy vấn 1 trong 2 loại:</p>
<ul>
<li>Lần lượt cho $k$ quả bóng vào đỉnh gốc. In ra
nút chứa quả cuối cùng khi bóng rơi xong.</li>
<li>Lấy quả bóng từ đỉnh $u$ ra. Đếm số quả bóng
bị rơi xuống.</li>
</ul>
<h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N, Q \le 10^5$</p>
<h2 id="numbers"><a href="#numbers" class="headerlink" title="numbers"></a>numbers</h2><p>Cho 2 số $A$ và $B$.
Đếm số các số $x$ thỏa mãn:</p>
<ul>
<li>$A \le x \le B$</li>
<li>Nếu coi $x$ là một xâu,
không tồn tại một xâu con nào của $x$ có độ
dài lớn hơn 1 và đối xứng.</li>
</ul>
<h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$0 \le A \le B \le 10^{18}$</p>
<h2 id="pipes"><a href="#pipes" class="headerlink" title="pipes"></a>pipes</h2><p>Cho đồ thị $N$ đỉnh $M$ cạnh. Mỗi cạnh có một
chỉ số $A_i$ chưa biết.
Cho biết với mỗi đỉnh giá trị $B_i$ là tổng
các $A_i$ của các cạnh kề với đỉnh đó.
Kiểm tra xem có tồn tại duy nhất 1 nghiệm
thỏa mãn, và in ra nếu có.</p>
<h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 10^5$, $1 \le M \le 5 \times 10^5$</p>
<p>Trong 25% số test input là cây.</p>
<h2 id="brunhilda"><a href="#brunhilda" class="headerlink" title="brunhilda"></a>brunhilda</h2><p>Cho một tập $N$ số nguyên tố $A_i$.
Với số $x$, ta có thể biến đổi như sau trong
một bước để ra số $y$:</p>
<ul>
<li>Chọn $k = A_i$ với $i$ bất kì</li>
<li>$y = x - x \mod k$</li>
</ul>
<p>Có $Q$ truy vấn, mỗi truy vấn cho một số $X$.
Tìm số bước nhỏ nhất để biến đổi $X$ thành 0.
(Số bước có thể là vô tận)</p>
<h4 id="Gioi-han-3"><a href="#Gioi-han-3" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 10^5$, $1 \le Q \le 10^4$,
$1 \le A_i, X \le 10^7$</p>
<h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="ballmachine-1"><a href="#ballmachine-1" class="headerlink" title="ballmachine"></a>ballmachine</h2><h3 id="Tinh-min-cay-con"><a href="#Tinh-min-cay-con" class="headerlink" title="Tính min cây con"></a>Tính min cây con</h3><p>Theo đúng yêu cầu của bài toán, trước tiên
ta tính $V[u]$ - min chỉ số tất cả các nút
của cây con gốc $u$. Việc này có thể làm đơn
giản bằng 1 lần dfs, độ phức tạp $O(N)$.</p>
<h3 id="Tim-thu-tu-dat"><a href="#Tim-thu-tu-dat" class="headerlink" title="Tìm thứ tự đặt"></a>Tìm thứ tự đặt</h3><p>Ta có thể tóm tắt thuật toán đặt bóng như
sau, từ một cây đã dồn bóng xuống. Giả
sử ta đang ở nút $v$:</p>
<ul>
<li>Sort các cạnh $(v, u)$ theo $V[u]$ tăng dần</li>
<li>Với mỗi cạnh $(v, u)$ theo thứ tự:<ul>
<li>Tìm chỗ đặt ở $u$</li>
<li>Nếu tìm thấy: thoát. Nếu không, tiếp tục</li>
</ul>
</li>
<li>Không có cây con nào còn chỗ. Nếu $v$ có
chỗ, đặt ở $v$. Nếu không, trả về không đặt.</li>
</ul>
<p>Ta có thể chỉnh sửa một chút để tạo ra mảng từng
nút theo “priority” như sau, giả sử ta đang
ở $v$:</p>
<ul>
<li>Sort các cạnh $(v, u)$ theo $V[u]$ tăng dần</li>
<li>Với mỗi cạnh $(v, u)$ theo thứ tự:<ul>
<li>dfs xây mảng xuống $u$</li>
</ul>
</li>
<li>Đẩy $v$ vào mảng</li>
</ul>
<p>Ta sẽ được một dãy $P$ theo kiểu postfix, dễ dàng
nhận thấy nếu $i &lt; j$ thì quả bóng luôn được
rơi xuống $P_i$ trước $P_j$.</p>
<p><img src="../images/ballmachine_tree.png" alt="Xây test mẫu ta được 5 8 6 3 7 4 2 1"></p>
<p>Như vậy, việc đặt thêm bóng chỉ đơn giản là
tìm $i$ bé nhất mà $P_i$ chưa có bóng, và đặt
vào đó. Việc này có thể làm trong $O(1)$, với
1 mảng đánh dấu.</p>
<h3 id="Xoa-nhu-the-nao"><a href="#Xoa-nhu-the-nao" class="headerlink" title="Xóa như thế nào?"></a>Xóa như thế nào?</h3><p>Ta nhận thấy một nút $v$ không thể rỗng nếu như
tồn tại một tổ tiên $p_v$ có bóng.
Do vậy, từ $v$ lên gốc sẽ là một đoạn liên
tiếp có bóng, kế theo là các nút không có
bóng lên đến gốc.
Vì thế, bản
chất việc “dồn bóng” chỉ là tìm tổ tiên $p_v$
cao nhất vẫn chứa bóng, và đưa quả bóng vào
$v$ - hay nói cách khác, thay vì xóa $v$ ta
xóa $p_v$.</p>
<p>Để tìm $p_v$, ta chỉ cần sử dụng chặt nhị phân,
sau đó kiểm tra xem tổ tiên ta chặt có chứa
bóng hay không. Ta có thể dễ dàng cài đặt
thuật toán này bằng nhảy 2 mũ, với độ phức tạp
$O(\log N)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// par[v][i] là cha 2 mũ i của v</span></div><div class="line"><span class="keyword">int</span> len = <span class="number">0</span>, cur = v;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">	<span class="comment">// 2^17 + 2^16 + ... + 1 = 2^18 - 1 &gt; 1e5</span></div><div class="line">	<span class="keyword">if</span> (par[cur][i] != <span class="number">0</span> &amp;&amp; ball[par[cur][i]]) &#123;</div><div class="line">		<span class="comment">// ^ cha này tồn tại  ^ có bóng</span></div><div class="line">		len += (<span class="number">1</span> &lt;&lt; i); cur = par[cur][i];</div><div class="line">		<span class="comment">// ^ khoảng cách tăng 2^i</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, len); <span class="comment">// khoảng cách chính là số bóng rơi</span></div><div class="line">removeBall(cur); <span class="comment">// xóa bóng ở cur</span></div></pre></td></tr></table></figure>
<p>Như vậy ta có thuật toán $O(N \log N + Q \log N)$.
Phần $N \log N$ bị tạo ra do việc tính cha 2 mũ.</p>
<h2 id="numbers-1"><a href="#numbers-1" class="headerlink" title="numbers"></a>numbers</h2><h3 id="Tinh-chat-doi-xung"><a href="#Tinh-chat-doi-xung" class="headerlink" title="Tính chất đối xứng"></a>Tính chất đối xứng</h3><p>Một xâu đối xứng sẽ thuộc 1 trong 2 loại:</p>
<ul>
<li>Xâu chẵn, nửa đầu bằng nửa sau lật lại.</li>
<li>Xâu lẻ, bỏ phần tử giữa ta có xâu đối xứng chẵn.</li>
</ul>
<p>Ta nhận thấy, trong trường hợp thứ nhất, luôn
tồn tại 2 kí tự liên tiếp giống nhau (2 kí
tự ở giữa). Trong trường hợp 2, có thêm
một kí tự khác nằm giữa 2 kí tự giống nhau.</p>
<p>Như vậy, điều kiện không tồn tại xâu con đối
xứng rất đơn giản:</p>
<ul>
<li>Không tồn tại $d<em>i = d</em>{i + 1}$, <em>và</em></li>
<li>Không tồn tại $d<em>i = d</em>{i + 2}$</li>
</ul>
<p>Với $d_i$ là chữ số thứ $i$ của số cần tìm.</p>
<h3 id="Quy-hoach-dong"><a href="#Quy-hoach-dong" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Để đơn giản hóa việc đếm trong đoạn $[A..B]$
ta có thể tính số phần tử nhỏ hơn $B + 1$
rồi trừ đi số phần tử nhỏ hơn $A$. Việc
chỉ viết 1 hàm qhđ sẽ đơn giản hóa bài toán.
Ta tập trung vào bài tính số phần tử thỏa
mãn nhỏ hơn $X$.</p>
<h4 id="Cong-thuc"><a href="#Cong-thuc" class="headerlink" title="Công thức"></a>Công thức</h4><p>Gọi $f[i][a][b][sm]$ là số các số đã xây
$i$ chữ số đầu tiên, 2 chữ số cuối cùng đã
xây là $a$ và $b$, và $sm$ là biến quản lí
việc so sánh số đang xây với $X$ (1 nếu đã
nhỏ hơn, 0 nếu vẫn bằng nhau).</p>
<p>Từ đây ta sẽ chuyển trạng thái bằng cách
chọn chữ số điền tiếp theo ($n$) thỏa mãn:</p>
<ul>
<li>$n \neq a$ và $n \neq b$</li>
<li>$sm = 1$ hoặc $n \le X_{i + 1}$</li>
</ul>
<p>Độ phức tạp sẽ là $O(\log_{10}N \times 10^3)$.
Tất nhiên do tính chất phải lưu 2 chữ số
nên phần cài đặt sẽ lằng nhằng, đồng thời
để dễ dàng xét số chữ số của số đang qhđ ta
cũng cần một số ý tưởng kì dị để quản lí
(ví dụ, bạn phải xây các số 0 phía trước
và cho phép đối xứng).</p>
<h4 id="Quan-li-trang-thai"><a href="#Quan-li-trang-thai" class="headerlink" title="Quản lí trạng thái"></a>Quản lí trạng thái</h4><p>Mình hay làm theo kiểu coi $X$ và số cần
tìm như các số có 20 chữ số với số 0 đứng đầu
khi qhđ chữ số. Tuy nhiên riêng với bài này
việc xử lí trở nên khó khăn hơn khi các số
0 đứng đầu không tạo ra xâu con đối xứng.
Vì vậy, mình làm như sau:</p>
<ul>
<li>Thay vì gọi chữ số 0 ở đầu là 0 gây nhầm
với số 0 ở giữa số, ta gọi số này là <strong>-1</strong></li>
<li>Mình cho phép đặt thêm -1 thoải mái, nhưng
chỉ khi số ngay trước cũng là -1.</li>
<li>Tất nhiên, chữ số đầu tiên không phải -1
phải là một chữ số khác 0.</li>
<li>Và cuối cùng, yêu cầu trên sẽ xóa bỏ số 0
khỏi tập thỏa mãn, vì vậy về sau bạn nên
thêm riêng số này nếu cần.</li>
</ul>
<p>Để đơn giản ta coi $f[0][-1][-1][0] = 1$,
do ta có thể coi có vô tận chữ số -1 phía
trước. Đáp số sẽ là tổng các $f[20][a][b][1]$.</p>
<h2 id="pipes-1"><a href="#pipes-1" class="headerlink" title="pipes"></a>pipes</h2><h3 id="Giai-tren-cay"><a href="#Giai-tren-cay" class="headerlink" title="Giải trên cây"></a>Giải trên cây</h3><p>Ta có cách giải sau trên cây:</p>
<ul>
<li>Chọn một lá $v$. Hiển nhiên nếu cây có
trên 1 đỉnh thì sẽ tồn tại 1 lá.</li>
<li>Xét cạnh $(v, p_v)$. Hiển nhiên trọng số
cạnh này chính là $B[v]$. Ta giải được
cạnh này, và xóa $v$ khỏi cây, giảm $B[p_v]$.</li>
<li>Đồ thị còn lại cũng là một cây, ta
tiếp tục làm đến khi không còn cạnh nào.</li>
</ul>
<p>Do ở mỗi bước, trọng số cạnh là xác định,
nên trên cây luôn tồn tại 1 đáp án duy nhất.
Ta có thể giải với độ phức tạp $O(N)$.</p>
<h3 id="Do-thi…-lua-dao"><a href="#Do-thi…-lua-dao" class="headerlink" title="Đồ thị… lừa đảo"></a>Đồ thị… lừa đảo</h3><p>Vì mỗi thành phần liên thông không liên quan
đến nhau, ta có thể giải riêng. Do vậy từ
đây ta coi đồ thị là liên thông.</p>
<p>Với bài toán đã cho,
ta có thể coi đây là một hệ $N$ phương trình
$M$ ẩn. Hiển nhiên nếu $M &gt; N$ thì hệ sẽ có
vô số nghiệm. Vì vậy, ta chỉ cần xét bài
toán khi $M \le N$.</p>
<p>Nếu $M &lt; N$ và đồ thị liên thông thì đây là
cây, ta giải được ở trên.
Vậy ta chỉ cần quan tâm đến $M = N$, tức đồ
thị “mặt trời”: một chu trình đơn, với mỗi đỉnh
trong chu trình có thể là gốc một cây.</p>
<h3 id="Chu-trinh"><a href="#Chu-trinh" class="headerlink" title="Chu trình"></a>Chu trình</h3><p>Với phần cây “tua rua” trên mỗi đỉnh, cách giải
giống hệt như giải từng cây ở trên. Bài toán
chỉ còn lại một chu trình đơn duy nhất.</p>
<p>Trước tiên, ta cần biết nếu chu trình có độ
dài chẵn thì sẽ có vô số nghiệm. Thật vậy, giả
sử ta tìm được một nghiệm. Theo chiều kim đồng
hồ, tăng các cạnh chẵn thêm 1 và giảm các cạnh
lẻ đi 1. Ta thấy tổng của tất cả các đỉnh đều
không đổi. Vì vậy, từ một nghiệm ta có thể tạo
ra vô số nghiệm khác.</p>
<p>Như vậy, ta chỉ giải trường hợp độ dài lẻ.
Ta tính tổng sau:</p>
<p>$$P = B_1 + B<em>2 + … + B</em>{2k + 1}$$
$$ = (A_{2k + 1} + A_1) + (A_1 + A<em>2) +
… + (A</em>{2k} + A_{2k + 1})$$
$$ = 2(A_1 + A<em>2 + … + A</em>{2k + 1})$$</p>
<p>Và</p>
<p>$$ Q = B_2 + B<em>4 + … + B</em>{2k} $$
$$ = (A_1 + A_2) + (A_3 + A<em>4) + … +
(A</em>{2k - 1} + A_{2k}) $$</p>
<p>Dễ dàng nhận thấy $A<em>{2k + 1} = P / 2 - Q$.
Khi đã có $A</em>{2k + 1}$, ta có thể tính được
tất cả các số còn lại với độ phức tạp là $O(N)$.</p>
<p>Như vậy tổng cộng thuật toán của ta là $O(N)$.</p>
<h2 id="brunhilda-1"><a href="#brunhilda-1" class="headerlink" title="brunhilda"></a>brunhilda</h2><h3 id="Quy-hoach-dong-1"><a href="#Quy-hoach-dong-1" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Gọi $f[i]$ là số bước nhỏ nhất để đưa $i$
về 0. Ta có:</p>
<ul>
<li>$f[0] = 0$</li>
<li>$f[i] = \min\limits_{i \mod A[j] &gt; 0}^
{1 \le j \le N}f[i - i \mod A[j]] + 1$</li>
</ul>
<p>Ta sẽ cần tính $f[i]$ với mọi $1 \le i \le 10^7$.
Sau khi tính thì mỗi truy vấn ta trả lời
trong $O(1)$. Độ phức tạp sẽ là $O(10^7N)$,
quá lớn, cần cải tiến.</p>
<h3 id="So-lan-thay-doi-gia-tri"><a href="#So-lan-thay-doi-gia-tri" class="headerlink" title="Số lần thay đổi giá trị"></a>Số lần thay đổi giá trị</h3><p>Xét $1 \le i \le N$. Giá trị tối ưu của
$f[k \times A[i]]$ sẽ được cập nhật cho
các số từ $k A[i] + 1$ đến $(k + 1)A[i] - 1$.
Như vậy, có $10^7 / A[i]$ lần hàm thay đổi
giá trị.</p>
<p>Do $A[i]$ là các số nguyên tố khác nhau, nên
chỉ có $10^7 / 2 + 10^7 / 3 + … \le 29 \times 10^6$
(10^5 số nguyên tố đầu) lần đổi giá trị.</p>
<p>Hơn nữa, ta cũng có thể thấy
$f[kA[i]] \le f[(k + 1)A[i]] \le f[kA[i]] + 1$.
Ta sẽ tìm cách sử dụng tính chất này khi tối ưu.</p>
<h3 id="Tinh-nhanh"><a href="#Tinh-nhanh" class="headerlink" title="Tính nhanh"></a>Tính nhanh</h3><p>Trước tiên, nếu một số là bội của tất cả
các số $A[i]$ thì chắc chắn số đó không thể
biến đổi được, ta sẽ không tính trường hợp đó.</p>
<p>Không khó để nhận ra $f[i]$ là hàm không giảm
khi $i$ tăng, vì thế ta có thể giữ lại một
deque các $f[j]$ còn thỏa mãn đứng trước, và
xóa dần đuôi khi chúng không còn được tính nữa.</p>
<p>$f[j]$ không được tính nữa khi với mọi $A[k]$
là ước của $j$ thì $i \ge A<a href="j / A[k] + 1">k</a>$.</p>
<p>Ta có thể lưu lại bộ đếm của từng $j$, tiến
deque khi phần tử đầu tiên có bộ đếm về 0.</p>
<p>Tổng độ phức tạp sẽ là $O(29 \times 10^6 + N)$.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://natsukagami.github.io/2017/05/03/2017-05-03-Training/" data-id="cja0ufafc000ljuoe8nq1s7go" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Training/">Training</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/apio/">apio</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thay-Phuong/">thầy Phương</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vietnamese/">vietnamese</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HSGSO-2016-Editorial" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/01/HSGSO-2016-Editorial/" class="article-date">
  <time datetime="2017-05-01T10:00:00.000Z" itemprop="datePublished">2017-05-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Editorials/">Editorials</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/01/HSGSO-2016-Editorial/">HSGSO 2016 Editorial</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Trong năm vừa rồi có kha khá nhiều bạn hỏi mình
cũng như các bạn khác trong BTC HSGSO 2016 (môn
Tin) về solution của contest. Vì hồi đó không có
thời gian (<em>thực ra là lười</em>) nên bọn mình chưa
có dịp chữa bài. Lần này mình quyết định làm cho
chót.</p>
<h1 id="De-bai"><a href="#De-bai" class="headerlink" title="Đề bài"></a>Đề bài</h1><p>Các bạn có thể tải đề bài gốc tại <a href="https://drive.google.com/file/d/0ByCMlnXUqIAIVmpSUWh6dHo1a2c/view" target="_blank" rel="external">đây</a>.</p>
<h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="Muc-luc"><a href="#Muc-luc" class="headerlink" title="Mục lục"></a>Mục lục</h2><ol>
<li><a href="#color">color</a></li>
<li><a href="#domino">domino</a></li>
<li><a href="#gift">gift</a></li>
<li><a href="#letter-o">letter-o</a></li>
<li><a href="#paren">paren</a></li>
<li><a href="#polylines">polylines</a></li>
<li><a href="#socket">socket</a></li>
<li><a href="#zigzag">zigzag</a></li>
</ol>
<h2 id="color"><a href="#color" class="headerlink" title="color"></a>color</h2><p><strong>Author</strong>: Nguyễn Đinh Quang Minh</p>
<h3 id="An-diem"><a href="#An-diem" class="headerlink" title="Ăn điểm"></a>Ăn điểm</h3><p>Để có 10% đầu tiên cho bài này ta nhận thấy chỉ
có cách tô duy nhất là so le với $K = 2$, như
vậy chỉ cần in $0$ khi $K = 1$ và $2$ khi $K = 2
$ là bạn đã cầm trong tay 1 điểm đầu tiên.</p>
<h3 id="Bieu-dien-trang-thai"><a href="#Bieu-dien-trang-thai" class="headerlink" title="Biểu diễn trạng thái"></a>Biểu diễn trạng thái</h3><p>Ta sẽ tiếp cận bài toán, đầu tiên bằng phương
pháp quy hoạch động. Qhđ thường là hướng giải
đúng đối với những bài toán đếm. Để có thể
triển khai qhđ, ta cần biết cách biểu diễn
một trạng thái đang xây.</p>
<p>Để ý giới hạn của bảng là $3 \times N$. Vì chỉ
có 3 ô nên ta hoàn toàn có thể biểu diễn trạng
thái của một cột bằng một $K-$mask - một số
có 3 chữ số trong đó các chữ số trong khoảng
$0$ đến $K - 1$ (theo cơ số $K$). 2 chữ số
liên tiếp phải khác nhau, nên số trạng thái
thỏa mãn một cột sẽ là $5 \times 4 \times 4 =
80$ trạng thái với $K = 5$.</p>
<p>Ta có thể có hàm quy hoạch động đơn giản
$f[i][mask]$ là số cách điền $i$ cột đầu tiên,
trong đó cột cuối cùng có trạng thái là $mask$.
Từ $f[i][mask]$ ta chuyển trạng thái sang
$f[i + 1][mask’]$, for hết $mask’$ thỏa mãn.
Ta có thể thấy cách này có độ phức tạp
$O(80^2 N)$, chưa đủ thỏa mãn cả subtask 2.
Kể cả khi ta chỉ lọc ra các $mask’$ thỏa mãn
và for chúng, ta vẫn có độ phức tạp $O(3380 N)$,
vẫn chưa thể thỏa mãn subtask 2.</p>
<h3 id="Cai-tien-quy-hoach-dong"><a href="#Cai-tien-quy-hoach-dong" class="headerlink" title="Cải tiến quy hoạch động"></a>Cải tiến quy hoạch động</h3><p>Thay vì chuyển trạng thái cả cột cùng lúc, ta
có thể thay bằng việc mỗi lần chỉ điền 1 ô, lần
lượt từ cột đầu sang cột cuối, mỗi cột điền
từ trên xuống dưới. Trạng thái ta lưu lại sẽ
là trạng thái của $K$ ô cuối cùng ta điền.</p>
<p>Tại sao lại lưu như vậy? Thực chất, khi điền lần
lượt, ta chỉ cần quan tâm đến ô phía trên và
bên trái nó, tức ô cách ô hiện tại $1$ và $K$
bước điền. Nhưng do ta cần tính cả các ô phía
sau nên ta phải lưu trạng thái của cả $K$ ô
trước đó.</p>
<p>Gọi $f[i][j][mask]$ là số cách điền các ô từ
đầu đến $(i, j)$, với $K$ cuối cùng mình điền
được lưu trong $mask$. Để chuyển sang ô tiếp
theo, ta cần for một trong $K$ màu của ô
tiếp theo ô $(i, j)$. Như vậy đpt sẽ là
$O(100 <em> N </em> K * 3)$ ($5^2 \times 4$ trạng thái, do
khi lưu như này có thể tồn tại 2 ô liên tiếp
cùng màu), vừa khít qua subtask 2. Code hơi trâu
nhưng không sao, worth it, vì ta đã có 50% số
điểm.</p>
<p>Bạn có thể xem thêm 1 bài mình đã chữa có cách
qhđ tương tự ở <a href="https://natsukagami.github.io/2017/04/21/2017-04-20-Training/">đây (bài Domino)</a>.</p>
<h3 id="Nhan-ma-tran"><a href="#Nhan-ma-tran" class="headerlink" title="Nhân ma trận"></a>Nhân ma trận</h3><p>Đối với những bạn đã biết về nhân ma trận, ta
có thể bỏ qua phần quy hoạch động cải tiến phía
trên và thay vào đó, cải tiến qhđ $O(80^2 N)$
thành nhân ma trận $O(80^3 \log N)$. Việc
chuyển đổi không khó, thực chất ta chỉ cần
dựng bảng chuyển đổi $80 \times 80$ xem 2 trạng
thái nào có thể chuyển được cho nhau, mũ $N-1$
lần lên rồi lấy ma trận $1 \times 80$ toàn 1
(thể hiện hàng đầu) nhân cùng tích ban nãy,
ra được một ma trận $1 \times 80$ mới, đáp số
chính là tổng các phần tử.</p>
<p>Việc nhân ma trận như nào chỉ là kĩ thuật cơ
bản nên mình sẽ không nói nhiều.</p>
<p>Kiến thức nhân ma trận, so với tối ưu quy hoạch
động như trên, là phổ thông hơn nhiều, vì thế
subtask 3 không cho nhiều điểm như subtask 2.</p>
<h3 id="1-ti-mau"><a href="#1-ti-mau" class="headerlink" title="1 tỉ màu??"></a>1 tỉ màu??</h3><p>Đọc đến subtask 4 hẳn tất cả sẽ ngạc nhiên khi
$K$ thay đổi đáng ngạc nhiên: từ $\le 5$ và
là mấu chốt giải bài toán, thành $10^9$ -
không còn đưa được vào độ phức tạp nữa. Để đào
sâu vào subtask này, ta cần có một nhận xét
về tương quan các màu giữa các cột.</p>
<h4 id="Tuong-quan-cac-mau"><a href="#Tuong-quan-cac-mau" class="headerlink" title="Tương quan các màu"></a>Tương quan các màu</h4><p>Trong một cột, chỉ có 2 loại tương quan sau:</p>
<ul>
<li>$a,b,c$ - tức 3 ô trong cột khác nhau</li>
<li>$a,b,a$ - tức 2 ô đầu và cuối giống nhau</li>
</ul>
<p>Hơn nữa, số cách chọn màu cho cột $i + 1$ chỉ
phụ thuộc vào tương quan của hàng $i$, theo bảng
sau:</p>
<ul>
<li>Từ $a, b, c$:<ul>
<li>Sang $a, b, c$: có $(K-1)+2(K-2)^2+
(K-3)(K-1)+(K-3)(K-2)^2$ cách.</li>
<li>Sang $a, b, a$: có $(K-1)+(K-3)(K-2)$ cách.</li>
</ul>
</li>
<li>Từ $a, b, a$:<ul>
<li>Sang $a, b, c$: có $(K-1)+(K-3)(K-2)$ cách.</li>
<li>Sang $a, b, a$: có $(K-1)+(K-2)^2$ cách.</li>
</ul>
</li>
</ul>
<p>Việc chứng minh chỉ là công thức tổ hợp, mình sẽ
không chứng minh để chống dài dòng.</p>
<p>Như vậy ta không cần lưu cụ thể các màu, mà chỉ
cần tương quan giữa các màu, tức chỉ còn 2 trạng
thái để quản lí chứ không nhiều như trưóc. Việc qhđ để ăn sub 4
(độ phức tạp $O(2^2 N)$) hay nhân ma trận để ăn
sub 5 (độ phức tạp $O(2^3 \log N)$) có thể được
thực hiện đơn giản.</p>
<h2 id="domino"><a href="#domino" class="headerlink" title="domino"></a>domino</h2><p><strong>Author</strong>: thầy Hồ Đắc Phương</p>
<h3 id="Backtrack"><a href="#Backtrack" class="headerlink" title="Backtrack"></a>Backtrack</h3><p>Ở subtask 1, đơn giản ta chỉ cần backtrack
tất cả các cách đặt domino. Do bảng chỉ có
$2 \times 20$ nên không có đến $2^{20}$ cách đặt
là tối đa. Độ phức tạp sẽ là $O(2^N)$.</p>
<h3 id="Bo-de-lat-gach-co-ban"><a href="#Bo-de-lat-gach-co-ban" class="headerlink" title="Bổ đề: lát gạch cơ bản"></a>Bổ đề: lát gạch cơ bản</h3><p><strong>Đếm số cách lát gạch vào bảng $2 \times N$</strong></p>
<p>Có lẽ đây là bài toán nổi tiếng trong giới
VNOI. Cách giải khá đơn giản: quy hoạch động
$f[i]$ là số cách lát $i$ cột đầu tiên. Ta
có 2 cách lát: 1 viên dọc (chuyển xuống
$f[i - 1]$) hoặc 2 viên ngang (chuyển xuống
$f[i - 2]$). Độ phức tạp là $O(N)$, hoặc vì
đây là phương trình đệ quy tuyến tính nên
ta có thể nhân ma trận $O(2^3 \log N)$.</p>
<p>Không khó để nhận ra $f[i]$ cũng chính là
số fibonacci, ta cũng có 1 số cách tính
chính xác khác trong $O(\log N)$.</p>
<h3 id="Cach-dien-duy-nhat"><a href="#Cach-dien-duy-nhat" class="headerlink" title="Cách điền duy nhất?"></a>Cách điền duy nhất?</h3><p>Để giải <em>tất cả subtask sau</em>, ta cần có chút quan
sát về các ô cấm:</p>
<ul>
<li>Nếu một cột bị cấm cả 2 ô, hiển nhiên ta
có bên trái và bên phải là 2 bài toán riêng
biệt, ta chỉ cần tính riêng 2 bên rồi nhân
vào nhau.</li>
<li>Nếu một cột bị chặn 1 ô, hiển nhiên ô đó
thuộc một viên domino ngang. Ta sẽ phải lựa
chọn viên ngang đó nằm lệch về bên trái hay
bên phải.</li>
</ul>
<p>Ngạc nhiên thay, cách chọn ô đó là duy nhất.
Để hiểu rõ tại sao, hãy xét 3 trường hợp sau:</p>
<h5 id="Nhan-1-ben"><a href="#Nhan-1-ben" class="headerlink" title="Nhận 1 bên"></a>Nhận 1 bên</h5><p><img src="/images/domino_one.png" alt="TH 1. Ô đỏ là ô cấm"></p>
<p>Hiển nhiên trong trường hợp này, số cách điền
là 0. Đơn là vì có lẻ ô.</p>
<h5 id="Nhan-2-ben-dien-duoc"><a href="#Nhan-2-ben-dien-duoc" class="headerlink" title="Nhận 2 bên, điền được"></a>Nhận 2 bên, điền được</h5><p><img src="/images/domino_two.png" alt="TH 2, cách điền duy nhất"></p>
<p>Xét cột thứ nhất, ta có cách điền domino duy
nhất. Con domino này chắn 1 ô của cột thứ hai,
làm cho bài toán đệ quy xuống. Tại mỗi bước
chỉ có một cách điền duy nhất nên với cả đoạn
cũng chỉ tồn tại 1 cách điền.</p>
<h5 id="Nhan-2-ben-khong-dien-duoc"><a href="#Nhan-2-ben-khong-dien-duoc" class="headerlink" title="Nhận 2 bên, không điền được"></a>Nhận 2 bên, không điền được</h5><p><img src="/images/domino_three.png" alt="TH 3"></p>
<p>Giống như trường hợp trên, nhưng vì khi đặt
con domino cuối cùng, ta bị đặt trùng lên ô
cấm, nên ta không thể điền trường hợp này.</p>
<p>Phân biệt với TH 2 như nào? Ta điền được
khi và chỉ khi:</p>
<ul>
<li>Cả đoạn độ dài chẵn <strong>và</strong> 2 ô cấm cùng hàng,
<em>hoặc</em></li>
<li>Cả đoạn độ dài lẻ <strong>và</strong> 2 ô cấm khác hàng</li>
</ul>
<h3 id="Cach-tinh"><a href="#Cach-tinh" class="headerlink" title="Cách tính"></a>Cách tính</h3><p>Xét một đoạn bị chắn 2 đầu là cột 2 ô cấm (hoặc
biên, ta có thể coi 2 biên là 2 cột 2 ô cấm).
Gọi $P_1, P_2, …, P_K$ là vị trí các cột có
1 ô cấm, từ trái sang phải.</p>
<p>Hiển nhiên nếu $K$ lẻ thì có 0 cách điền vì có
lẻ ô.</p>
<p><img src="/images/domino_all.png" alt="$P_1 = 3$, $P_2 = 5$, số cách điền là $f[2] \times 1 \times f[3]$"></p>
<p>Ta có:</p>
<ul>
<li>Xét đoạn $1..P_1$: Hiển nhiên viên ở $P_1$ sẽ
đặt sang phải vì nếu không ta sẽ có TH 1. Số
cách điền đoạn $1..P_1-1$ là $f[P_1 - 1]$.</li>
<li>Xét đoạn $P_1..P_2$: Vì viên ở $P_1$ đặt trọn
trong đoạn nên $P_2$ cũng vậy, nếu không sẽ
bị TH 1. Số cách điền là 0 hoặc 1 phụ thuộc
vào nó là TH 2 hay 3.</li>
<li>Xét đoạn $P_2..P_3$, vì viên ở $P_2$ nằm
trọn bên trái nên trường hợp này như đoạn
$1..P_1$, số cách chọn là $f[P_3 - P_2 - 1]$.</li>
<li>Vân vân, xét đến khi ta gặp $P_{2k}..N$
thì cũng như đoạn đầu, số cách là $f[N - 2k]$.</li>
</ul>
<p>Số cách điền cả đoạn sẽ là tích số cách điền
từng đoạn con.</p>
<p>Độ phức tạp là $O(N \log 10^9)$, vì ta tính
$f[i]$ trong $O(\log i)$.</p>
<h3 id="Tai-sao-lai-chia-subtask-nhu-vay"><a href="#Tai-sao-lai-chia-subtask-nhu-vay" class="headerlink" title="Tại sao lại chia subtask như vậy?"></a>Tại sao lại chia subtask như vậy?</h3><p>Với $K = 4$, bạn có thể mập mờ nhìn ra tính
chất trên khi chia tất cả trường hợp 4 ô cấm.
Bọn mình muốn hướng suy nghĩ phải theo mạch
tự nhiên, không bị gò bó.</p>
<h2 id="gift"><a href="#gift" class="headerlink" title="gift"></a>gift</h2><p><strong>Author</strong>: Nguyễn Đức Duy</p>
<h3 id="Thuat-toan-backtrack"><a href="#Thuat-toan-backtrack" class="headerlink" title="Thuật toán backtrack"></a>Thuật toán backtrack</h3><p>Với $N \le 10$, ta có thể thực hiện backtrack,
mỗi bước cho phần tử $i$ cho Alice, Bob hoặc
giữ lại. Đến cuối, nếu có đáp án, ta in ra
và thoát chương trình.</p>
<p>Do mỗi bước ta có 3 lựa chọn nên độ phức tạp
là $O(3^N)$.</p>
<h3 id="22-phan-tu"><a href="#22-phan-tu" class="headerlink" title="22 phần tử"></a>22 phần tử</h3><p>Với $N$ lớn hơn, hẳn là lượng tập con
càng lớn so với giới hạn, vì thể xác suất
tồn tại đáp số càng lớn.
Ta sẽ chứng minh chỉ với 22 phần tử, luôn
luôn tồn tại đáp số.</p>
<p>Hiển nhiên, với 22 phần tử, ta có $2^{22} - 1$
tập con không rỗng.
Đồng thời, các tổng nằm trong khoảng $1..
22 \times 10^5$.
Vì $2^22 - 1 &gt; 22 \times 10^5$ nên theo định
lí Dirichlet ta luôn có 2 tập có cùng tổng.</p>
<p>Gọi 2 tập này là $x$ và $y$. Chắc chắn 2 tập
này không phải tập con của nhau, vì mỗi phần
tử đều lớn hơn 0. Như vậy chắc chắn tồn tại
ít nhất 1 phần tử của mỗi tập mà không tồn
tại trong tập kia.</p>
<p>Ta loại đi các phần tử có trong cả 2 (vì
chúng cùng trừ cả 2 bên đi 1 lượng), và
còn lại 2 tập không rỗng. Đây chính là đáp số.</p>
<p>Như vậy, với $N \ge 22$, ta chỉ cần bốc ra
22 phần tử rồi tính tất cả tổng tập con, lấy
2 tập bằng nhau và loại đi các phần tử trùng
là sẽ ra đáp số.</p>
<p>Độ phức tạp là $O(2^{22})$.</p>
<h3 id="N-“at-o”"><a href="#N-“at-o”" class="headerlink" title="$N$ “ất ơ”"></a>$N$ “ất ơ”</h3><p>Vậy với $10 &lt; N &lt; 22$ thì sao? Rất tiếc bọn
mình không chuẩn bị được test mà giết được
thuật ở trên. Tuy nhiên, ta vẫn có thể
backtrack gặp nhau ở giữa, lần lượt backtrack
$3^{10}$ trường hợp ở đầu và $3^{N - 10}$
trường hợp ở cuối, sau đó ghép 2 số có
hiệu trái dấu.
Như vậy độ phức tạp sẽ không quá $O(3^{N / 2})$.</p>
<h2 id="letter-o"><a href="#letter-o" class="headerlink" title="letter-o"></a>letter-o</h2><p><strong>Author</strong>: mình</p>
<p>Lưu ý đây là bài output-only, vì vậy bạn có
5 tiếng để chạy chứ không phải 1 giây.</p>
<h3 id="Thuat-toan-O-N-4"><a href="#Thuat-toan-O-N-4" class="headerlink" title="Thuật toán $O(N^4)$"></a>Thuật toán $O(N^4)$</h3><p>Thực ra thuật toán $O(N^4)$ khá đơn giản, ta
chỉ cần for 2 góc của hình chữ nhật và kiểm
tra liệu 4 cạnh của chúng có chứa toàn cùng
kí tự không. Để kiểm tra ta có thể tính
trước mảng cộng dồn $O(N^2)$.</p>
<p>Lấy thuật $O(N^4)$ có thể chạy 1s đến input 5,
và ăn 50% số điểm.
Bài thật là dễ!</p>
<h3 id="Thuat-toan-O-N-3"><a href="#Thuat-toan-O-N-3" class="headerlink" title="Thuật toán $O(N^3)$"></a>Thuật toán $O(N^3)$</h3><p>Ta nhận thấy, nếu ta for trước 2 cạnh song song
của hình chữ nhật, thì chỉ cần xét các vị trí
mà có toàn kí tự <code>x</code> nào đó trong cả đoạn nằm
giữa 2 cạnh. Ta sẽ chọn 2 điểm xa nhau nhất mà
2 điểm đó dọc 2 cạnh đều là các kí tự giống nhau.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">11111</div><div class="line">10021</div><div class="line">10311</div><div class="line">11111</div><div class="line">10231</div><div class="line">11111</div><div class="line">10230</div><div class="line">11111</div></pre></td></tr></table></figure>
<p>Xét ví dụ trên, chọn 2 cột đầu cuối. Ta thấy
chỉ có các hàng 1, 4, 6 và 8 có thể làm 2
cạnh ngang của hình chữ nhật. Ngoài ra,
chỉ có 1, 4, 6 được nối với nhau. Ta chọn
hình lớn nhất (1 - 6).</p>
<p>Việc lựa chọn có thể được thực hiện chỉ trong
$O(N)$ bằng một vòng for lưu max. Như vậy ta
có thuật $O(N^3)$ đủ ăn input 6.</p>
<h3 id="Suc-manh-cua-input"><a href="#Suc-manh-cua-input" class="headerlink" title="Sức mạnh của input!"></a>Sức mạnh của input!</h3><p>Đối với input 7 và 8, đáp số được đảm bảo là
lớn, nên bạn có thể sử dụng chiến thuật chỉ
bài output-only mới có: sử dụng mắt.</p>
<p>Với mỗi số ta có thể in ra vị trí của chúng
(và để trống những vị trí khác). Việc nhìn
bằng mắt cũng sẽ cho ta thấy một số hình lớn,
chỉ việc thử vào đáp số.</p>
<h3 id="Tim-kiem-pattern"><a href="#Tim-kiem-pattern" class="headerlink" title="Tìm kiếm pattern"></a>Tìm kiếm pattern</h3><p>Nếu nhìn kỹ, bạn có thể nhận ra input 9 có pattern
khá dị, khi chỉ có một số hình chữ nhật. Bạn có
thể nhìn tay và chỉ chạy các miền có hình chữ nhật
thỏa mãn.</p>
<h3 id="…-hoac-khong"><a href="#…-hoac-khong" class="headerlink" title="… hoặc không"></a>… hoặc không</h3><p>Để giải input 10, bạn cần phải nhận ra quy tắc
quan trọng nhất: bạn không bị giới hạn bởi thời
gian chạy của máy chấm. Vì thế hãy nhập input
10 vào, đặt cận đáp số và chờ 15-20 phút cho
máy chạy. Tính trên máy trường mình, chỉ mất
1h để chạy tất cả input với $O(N^3)$ đặt cận
đáp số! Bạn có 5 tiếng cơ mà, chạy trâu rồi
làm bài khác… đó là chiến thuật của bài này.</p>
<h2 id="paren"><a href="#paren" class="headerlink" title="paren"></a>paren</h2><p><strong>Author</strong>: thầy Hồ Đắc Phương &amp; Phạm Tùng
Dương.</p>
<h3 id="De-quy"><a href="#De-quy" class="headerlink" title="Đệ quy"></a>Đệ quy</h3><p>Thực chất đây chỉ là một bài tính toán có
chút lằng nhằng. Phương thức tính toán như
sau, xét đoạn ngoặc $l..r$ là 1 cặp ngoặc:</p>
<ul>
<li>Tính tất cả các cặp ngoặc con $l_1..r_1, …, l_p..r_p$</li>
<li>Độ cao của $l..r$ là max độ cao của các cặp ngoặc con, cộng 1</li>
<li>Độ dài của $l..r$ là tổng độ dài của các cặp
ngoặc con, cộng $p-1$ khoảng cách ở giữa,
cộng 2 hoặc 4 tùy loại ngoặc của $l..r$</li>
<li>Phần tô màu của $l..r$ là:<ul>
<li>Nếu viền ngoài cùng của $l..r$ là đen:
độ dài $\times$ độ cao $-$ diện tích các hình con</li>
<li>Nếu không thì là 0</li>
<li>Sau đó cộng thêm phần tô màu các hình con</li>
</ul>
</li>
</ul>
<h3 id="Dung-cay"><a href="#Dung-cay" class="headerlink" title="Dựng cây"></a>Dựng cây</h3><p>Để có thể dựng quan hệ cha - con và tính đệ quy
trong $O(N)$, ta sẽ cần dựng cây bằng stack.
Cách dựng như sau:</p>
<ul>
<li>Duy trì 1 stack, lúc đầu stack rỗng</li>
<li>Đi từ trái sang phải, giả sử kí tự ta có là
$S_x$:<ul>
<li>Nếu $S_x$ là mở ngoặc: Nếu stack không rỗng,
thì cặp ngoặc $x$ có cha là đỉnh stack. Push
$x$ vào stack.</li>
<li>Nếu $x$ là đóng ngoặc: xóa đỉnh stack.</li>
</ul>
</li>
</ul>
<p>Tổng độ phức tạp là $O(N)$.</p>
<h2 id="polylines"><a href="#polylines" class="headerlink" title="polylines"></a>polylines</h2><p><strong>Author</strong>: mình</p>
<h3 id="Quy-hoach-dong-trau-co-ban"><a href="#Quy-hoach-dong-trau-co-ban" class="headerlink" title="Quy hoạch động trâu cơ bản"></a>Quy hoạch động trâu cơ bản</h3><p>Để đơn giản ta coi điểm xuất phát là $0$,
đích là $M + 1$.</p>
<p>Ta có công thức quy hoạch động: Gọi $f[i]$ là
số đường đi kết thúc ở $i$. Ta có</p>
<ul>
<li>$f[0] = 1$</li>
<li>$f[i] = \sum\limits_{X_j \le X_i, Y_j \le Y_i, i \neq j}f[j]$</li>
<li>Đáp số là $f[M + 1]$ - 1.</li>
</ul>
<p>Để có thứ tự qhđ ta chỉ cần sort các điểm theo cả 2 tọa độ tăng
dần.
Chỉ đơn giản vậy ta có thuật toán $O(N^2)$.</p>
<h3 id="Tang-toc"><a href="#Tang-toc" class="headerlink" title="Tăng tốc!"></a>Tăng tốc!</h3><p>Nhìn vào điều kiện của $j$ ở hàm qhđ, ta nhận thấy hoàn toàn
có thể lấy nhanh tổng các $f[j]$ bằng 1 cấu trúc
dữ liệu nào đó.</p>
<p>Nhận thấy, khi sort các phần tử theo $X$ rồi lấy
các phần tử đứng trước, ta chỉ còn cần lọc
điều kiện $Y$ là đủ. Việc này ta hoàn toàn có
thể sử dụng BIT để lấy nhanh, sort tọa độ BIT
theo $Y$ rồi get prefix, update điểm.</p>
<p>Độ phức tạp là $O(N \log N)$.</p>
<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p><strong>Author</strong>: Nguyễn Đức Duy</p>
<h3 id="Tim-dap-an"><a href="#Tim-dap-an" class="headerlink" title="Tìm đáp án"></a>Tìm đáp án</h3><p>Không khó để nhận ra nếu chỉ có thể xếp được
$K$ thiết bị, ta luôn lấy $K$ thiết bị có
độ yêu cầu cao nhất. Vì vậy ta có thể sort
thiết bị theo yêu cầu giảm dần rồi chặt nhị
phân, kiểm tra xem có thể đặt $K$ thiết bị
đầu tiên không.</p>
<h3 id="Xep-o-dien-nhu-nao"><a href="#Xep-o-dien-nhu-nao" class="headerlink" title="Xếp ổ điện như nào?"></a>Xếp ổ điện như nào?</h3><p>Ta có thể coi hệ thống ổ điện như một cây,
trong đó gốc nối với nguồn. Xét 2 ổ điện
$i$ và $j$, trong đó $i$ gần gốc hơn $j$.
Nếu $A_i$ &lt; $A_j$, ta hoàn toàn có thể
đổi chỗ $i$ và $j$ và đáp án không thể
nhỏ hơn ban đầu. Vì thế, để xây cây từ gốc,
ta đặt các ổ điện theo thứ tự $A_i$ giảm dần.</p>
<p>Với nhận xét trên, ta coi như $A_i$ đã
được xếp giảm dần. Giờ ta BFS theo từng tầng,
dễ dàng nhận thấy khi xét tầng $x$:</p>
<ul>
<li>Nếu tồn tại $B_i = x$, lập tức phải đặt $i$
vào tầng đó. Nếu không đặt được thì kiểm
tra fail.</li>
<li>Mỗi lần ở tầng $x$ ta thêm ổ $j$ vào,
thì bớt 1 chỗ ở tầng $x$ và thêm $A_j$ chỗ
ở tầng $x + 1$. Vì $A_j$ dương nên sau khi
thêm ta luôn có nhiều chỗ ở tầng $x + 1$
cho các $B_i &gt; x$ hơn ở tầng $x$. <em>Vì vậy,</em></li>
<li>Nếu $B_i &gt; x$, ta nhường cho ổ điện nếu
còn, nếu không ta sẽ xét sau.</li>
</ul>
<h3 id="Tom-tat-thuat-toan"><a href="#Tom-tat-thuat-toan" class="headerlink" title="Tóm tắt thuật toán"></a>Tóm tắt thuật toán</h3><p>Ta chặt nhị phân $K$, kiểm tra xem có thể
xếp $K$ thiết bị $B[1..K]$ vào không.</p>
<p>Để kiểm tra:</p>
<ul>
<li>Lúc đầu ở tầng 0 ta có 1 vị trí đặt (ổ điện)</li>
<li>Nếu có nhiều $B[i] = x$ hơn số vị trí đặt,
kiểm tra fail. Nếu không, đặt hết $B[i] = x$.</li>
<li>Nếu còn chỗ ở tầng $x$ và còn ổ điện, đặt ổ
điện cho tầng $x + 1$.</li>
<li>Nếu còn chỗ, coi như chúng của tầng $x + 1$.</li>
</ul>
<p>Độ phức tạp sẽ là $O((N + M) \log M)$, do các bước
kiểm tra chỉ là $O(N + M)$.</p>
<h2 id="zigzag"><a href="#zigzag" class="headerlink" title="zigzag"></a>zigzag</h2><h3 id="Truong-hop-K-1"><a href="#Truong-hop-K-1" class="headerlink" title="Trường hợp $K = 1$"></a>Trường hợp $K = 1$</h3><p>Không khó để nhận thấy với 10 chữ số và điều
kiện phải thăm mỗi số ít nhất 1 lần và không
cần đúng thứ tự, ta sẽ cần sử dụng đến bitmask.
Từ ngôi nhà nguồn, ta cần bfs đến các đỉnh, tìm
đường đi ngắn nhất dựng ra đủ mask.</p>
<p>Trên đồ thị ta dựng ra các đỉnh $(i, j, mask)$,
tức đứng ở ô $(i, j)$ và tập các số đã đi qua là
$mask$. Từ đỉnh $(i, j)$ ta đi đến các đỉnh lân
cận, thêm mask của đỉnh đó vào nếu cần, mất
1 bước. Đáp số là khoảng cách đến đỉnh gần nhất
có mask đầy đủ 10 bit.</p>
<p>Độ phức tạp là $O(NM2^{10})$.</p>
<h3 id="K-lon-hon"><a href="#K-lon-hon" class="headerlink" title="$K$ lớn hơn"></a>$K$ lớn hơn</h3><p>Với $K$ lớn đến $M \times N$, ta không thể chỉ
đơn giản là chạy thuật toán trên $K$ lần, vì
như vậy là không thỏa mãn giới hạn bài toán.</p>
<p>Thay vào đó, ta cần một cách để có thể chạy
tất cả các truy vấn một lúc.</p>
<h3 id="Lat-nguoc-yeu-cau"><a href="#Lat-nguoc-yeu-cau" class="headerlink" title="Lật ngược yêu cầu"></a>Lật ngược yêu cầu</h3><p>Đề bài yêu cầu từ một ngôi nhà, ta đến một
ô bất kì, miễn là đủ mask trên đường đi. Ta
sẽ lật ngược yêu cầu lại, cho phép xuất phát
từ đỉnh bất kì, đi thoải mái, với điều kiện
kết thúc ở nhà và đủ mask trên đường đi.</p>
<p>Vậy điểm khác biệt là gì? Với bài toán không quan
trọng đích với mỗi nguồn, ta cần BFS với từng
nguồn riêng biệt. Tuy nhiên, với bài toán không
quan trọng nguồn, ta có thể thực hiện BFS song
song nhiều nguồn, để tính khoảng cách từ <em>nguồn
gần nhất</em> tới mỗi đỉnh, với độ phức tạp chỉ
bằng 1 lần BFS.</p>
<p>Nói cách khác, thay vì ta xuất phát từ $(X_i,
Y_i, 0)$, ta xuất phát từ tất cả các đỉnh
$(i, j, 0)$ và tìm đường từ đỉnh bất kì đến
$(X_i, Y_i, 1023)$. Để chạy song song, tưởng
tượng có một nguồn ảo nối đến tất cả nguồn
thật với trọng số 0. Như vậy, vì chỉ có 1
nguồn (ảo), nên độ phức tạp chỉ là $O(NM2^{10})$.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://natsukagami.github.io/2017/05/01/HSGSO-2016-Editorial/" data-id="cja0ufafi000xjuoe00s6p406" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/editorial/">editorial</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hsgso/">hsgso</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vietnamese/">vietnamese</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Editorials/">Editorials</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Thoughts/">Thoughts</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Training/">Training</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Writing/">Writing</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/First-Post/">First Post</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Training/">Training</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anh-Hanh/">anh Hạnh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anh-Khue/">anh Khuê</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anh-Minh/">anh Minh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apio/">apio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/editorial/">editorial</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/english/">english</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hsgso/">hsgso</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/random/">random</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/story/">story</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thay-Hoang/">thầy Hoàng</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thay-Nghia/">thầy Nghĩa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thay-Phuong/">thầy Phương</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thay-Dong/">thầy Đông</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/training/">training</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vietnamese/">vietnamese</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/writing/">writing</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/First-Post/" style="font-size: 10px;">First Post</a> <a href="/tags/Training/" style="font-size: 10px;">Training</a> <a href="/tags/anh-Hanh/" style="font-size: 12.5px;">anh Hạnh</a> <a href="/tags/anh-Khue/" style="font-size: 10px;">anh Khuê</a> <a href="/tags/anh-Minh/" style="font-size: 12.5px;">anh Minh</a> <a href="/tags/apio/" style="font-size: 17.5px;">apio</a> <a href="/tags/editorial/" style="font-size: 12.5px;">editorial</a> <a href="/tags/english/" style="font-size: 12.5px;">english</a> <a href="/tags/hsgso/" style="font-size: 12.5px;">hsgso</a> <a href="/tags/random/" style="font-size: 10px;">random</a> <a href="/tags/story/" style="font-size: 10px;">story</a> <a href="/tags/thay-Hoang/" style="font-size: 10px;">thầy Hoàng</a> <a href="/tags/thay-Nghia/" style="font-size: 10px;">thầy Nghĩa</a> <a href="/tags/thay-Phuong/" style="font-size: 12.5px;">thầy Phương</a> <a href="/tags/thay-Dong/" style="font-size: 10px;">thầy Đông</a> <a href="/tags/training/" style="font-size: 15px;">training</a> <a href="/tags/vietnamese/" style="font-size: 20px;">vietnamese</a> <a href="/tags/writing/" style="font-size: 10px;">writing</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/10/24/Random-Rain/">[Random] Rain</a>
          </li>
        
          <li>
            <a href="/2017/07/01/HSGSO-2017-Editorial/">HSGSO 2017 Editorial</a>
          </li>
        
          <li>
            <a href="/2017/05/03/2017-05-03-Training/">2017-05-03 Training</a>
          </li>
        
          <li>
            <a href="/2017/05/01/HSGSO-2016-Editorial/">HSGSO 2016 Editorial</a>
          </li>
        
          <li>
            <a href="/2017/04/28/2017-04-28-Training/">2017/04/28 Training</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Natsu Kagami<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>