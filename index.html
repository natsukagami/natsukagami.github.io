<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Kagami&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Some random stuff I write to express my life.">
<meta property="og:type" content="website">
<meta property="og:title" content="Kagami's Blog">
<meta property="og:url" content="http://natsukagami.github.io/index.html">
<meta property="og:site_name" content="Kagami's Blog">
<meta property="og:description" content="Some random stuff I write to express my life.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kagami's Blog">
<meta name="twitter:description" content="Some random stuff I write to express my life.">
<meta name="twitter:creator" content="@natsukagami">
  
    <link rel="alternate" href="/atom.xml" title="Kagami&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

  <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>
  <script type="text/javascript">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'] ],
        displayMath: [ ['$$','$$'] ],
        processEscape: true
      }
    }); 
  </script>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Kagami&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">IOI Medalist, osu! lover, I tryhard everything.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Tìm kiếm"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://natsukagami.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2017-05-03-Training" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/03/2017-05-03-Training/" class="article-date">
  <time datetime="2017-05-03T14:00:00.000Z" itemprop="datePublished">2017-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Training/">Training</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/03/2017-05-03-Training/">2017-05-03 Training</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hôm nay bài không phải là khó.</p>
<h1 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h1><h2 id="ballmachine"><a href="#ballmachine" class="headerlink" title="ballmachine"></a>ballmachine</h2><p>Cho một cây $N$ đỉnh có gốc, mỗi đỉnh chứa tối đa
1 quả bóng. Quả bóng từ cha sẽ rơi xuống nút
con nếu có thể. Nếu có nhiều nút con thỏa mãn,
chọn nút con có cây con chứa nút có số thứ tự
nhỏ nhất.
Thực hiện $Q$ truy vấn 1 trong 2 loại:</p>
<ul>
<li>Lần lượt cho $k$ quả bóng vào đỉnh gốc. In ra
nút chứa quả cuối cùng khi bóng rơi xong.</li>
<li>Lấy quả bóng từ đỉnh $u$ ra. Đếm số quả bóng
bị rơi xuống.</li>
</ul>
<h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N, Q \le 10^5$</p>
<h2 id="numbers"><a href="#numbers" class="headerlink" title="numbers"></a>numbers</h2><p>Cho 2 số $A$ và $B$.
Đếm số các số $x$ thỏa mãn:</p>
<ul>
<li>$A \le x \le B$</li>
<li>Nếu coi $x$ là một xâu,
không tồn tại một xâu con nào của $x$ có độ
dài lớn hơn 1 và đối xứng.</li>
</ul>
<h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$0 \le A \le B \le 10^{18}$</p>
<h2 id="pipes"><a href="#pipes" class="headerlink" title="pipes"></a>pipes</h2><p>Cho đồ thị $N$ đỉnh $M$ cạnh. Mỗi cạnh có một
chỉ số $A_i$ chưa biết.
Cho biết với mỗi đỉnh giá trị $B_i$ là tổng
các $A_i$ của các cạnh kề với đỉnh đó.
Kiểm tra xem có tồn tại duy nhất 1 nghiệm
thỏa mãn, và in ra nếu có.</p>
<h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 10^5$, $1 \le M \le 5 \times 10^5$</p>
<p>Trong 25% số test input là cây.</p>
<h2 id="brunhilda"><a href="#brunhilda" class="headerlink" title="brunhilda"></a>brunhilda</h2><p>Cho một tập $N$ số nguyên tố $A_i$.
Với số $x$, ta có thể biến đổi như sau trong
một bước để ra số $y$:</p>
<ul>
<li>Chọn $k = A_i$ với $i$ bất kì</li>
<li>$y = x - x \mod k$</li>
</ul>
<p>Có $Q$ truy vấn, mỗi truy vấn cho một số $X$.
Tìm số bước nhỏ nhất để biến đổi $X$ thành 0.
(Số bước có thể là vô tận)</p>
<h4 id="Gioi-han-3"><a href="#Gioi-han-3" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 10^5$, $1 \le Q \le 10^4$,
$1 \le A_i, X \le 10^7$</p>
<h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="ballmachine-1"><a href="#ballmachine-1" class="headerlink" title="ballmachine"></a>ballmachine</h2><h3 id="Tinh-min-cay-con"><a href="#Tinh-min-cay-con" class="headerlink" title="Tính min cây con"></a>Tính min cây con</h3><p>Theo đúng yêu cầu của bài toán, trước tiên
ta tính $V[u]$ - min chỉ số tất cả các nút
của cây con gốc $u$. Việc này có thể làm đơn
giản bằng 1 lần dfs, độ phức tạp $O(N)$.</p>
<h3 id="Tim-thu-tu-dat"><a href="#Tim-thu-tu-dat" class="headerlink" title="Tìm thứ tự đặt"></a>Tìm thứ tự đặt</h3><p>Ta có thể tóm tắt thuật toán đặt bóng như
sau, từ một cây đã dồn bóng xuống. Giả
sử ta đang ở nút $v$:</p>
<ul>
<li>Sort các cạnh $(v, u)$ theo $V[u]$ tăng dần</li>
<li>Với mỗi cạnh $(v, u)$ theo thứ tự:<ul>
<li>Tìm chỗ đặt ở $u$</li>
<li>Nếu tìm thấy: thoát. Nếu không, tiếp tục</li>
</ul>
</li>
<li>Không có cây con nào còn chỗ. Nếu $v$ có
chỗ, đặt ở $v$. Nếu không, trả về không đặt.</li>
</ul>
<p>Ta có thể chỉnh sửa một chút để tạo ra mảng từng
nút theo “priority” như sau, giả sử ta đang
ở $v$:</p>
<ul>
<li>Sort các cạnh $(v, u)$ theo $V[u]$ tăng dần</li>
<li>Với mỗi cạnh $(v, u)$ theo thứ tự:<ul>
<li>dfs xây mảng xuống $u$</li>
</ul>
</li>
<li>Đẩy $v$ vào mảng</li>
</ul>
<p>Ta sẽ được một dãy $P$ theo kiểu postfix, dễ dàng
nhận thấy nếu $i &lt; j$ thì quả bóng luôn được
rơi xuống $P_i$ trước $P_j$.</p>
<p><img src="../images/ballmachine_tree.png" alt="Xây test mẫu ta được 5 8 6 3 7 4 2 1"></p>
<p>Như vậy, việc đặt thêm bóng chỉ đơn giản là
tìm $i$ bé nhất mà $P_i$ chưa có bóng, và đặt
vào đó. Việc này có thể làm trong $O(1)$, với
1 mảng đánh dấu.</p>
<h3 id="Xoa-nhu-the-nao"><a href="#Xoa-nhu-the-nao" class="headerlink" title="Xóa như thế nào?"></a>Xóa như thế nào?</h3><p>Ta nhận thấy một nút $v$ không thể rỗng nếu như
tồn tại một tổ tiên $p_v$ có bóng.
Do vậy, từ $v$ lên gốc sẽ là một đoạn liên
tiếp có bóng, kế theo là các nút không có
bóng lên đến gốc.
Vì thế, bản
chất việc “dồn bóng” chỉ là tìm tổ tiên $p_v$
cao nhất vẫn chứa bóng, và đưa quả bóng vào
$v$ - hay nói cách khác, thay vì xóa $v$ ta
xóa $p_v$.</p>
<p>Để tìm $p_v$, ta chỉ cần sử dụng chặt nhị phân,
sau đó kiểm tra xem tổ tiên ta chặt có chứa
bóng hay không. Ta có thể dễ dàng cài đặt
thuật toán này bằng nhảy 2 mũ, với độ phức tạp
$O(\log N)$.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// par[v][i] là cha 2 mũ i của v</span></div><div class="line"><span class="keyword">int</span> len = <span class="number">0</span>, cur = v;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">17</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">	<span class="comment">// 2^17 + 2^16 + ... + 1 = 2^18 - 1 &gt; 1e5</span></div><div class="line">	<span class="keyword">if</span> (par[cur][i] != <span class="number">0</span> &amp;&amp; ball[par[cur][i]]) &#123;</div><div class="line">		<span class="comment">// ^ cha này tồn tại  ^ có bóng</span></div><div class="line">		len += (<span class="number">1</span> &lt;&lt; i); cur = par[cur][i];</div><div class="line">		<span class="comment">// ^ khoảng cách tăng 2^i</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, len); <span class="comment">// khoảng cách chính là số bóng rơi</span></div><div class="line">removeBall(cur); <span class="comment">// xóa bóng ở cur</span></div></pre></td></tr></table></figure>
<p>Như vậy ta có thuật toán $O(N \log N + Q \log N)$.
Phần $N \log N$ bị tạo ra do việc tính cha 2 mũ.</p>
<h2 id="numbers-1"><a href="#numbers-1" class="headerlink" title="numbers"></a>numbers</h2><h3 id="Tinh-chat-doi-xung"><a href="#Tinh-chat-doi-xung" class="headerlink" title="Tính chất đối xứng"></a>Tính chất đối xứng</h3><p>Một xâu đối xứng sẽ thuộc 1 trong 2 loại:</p>
<ul>
<li>Xâu chẵn, nửa đầu bằng nửa sau lật lại.</li>
<li>Xâu lẻ, bỏ phần tử giữa ta có xâu đối xứng chẵn.</li>
</ul>
<p>Ta nhận thấy, trong trường hợp thứ nhất, luôn
tồn tại 2 kí tự liên tiếp giống nhau (2 kí
tự ở giữa). Trong trường hợp 2, có thêm
một kí tự khác nằm giữa 2 kí tự giống nhau.</p>
<p>Như vậy, điều kiện không tồn tại xâu con đối
xứng rất đơn giản:</p>
<ul>
<li>Không tồn tại $d_i = d_{i + 1}$, <em>và</em></li>
<li>Không tồn tại $d_i = d_{i + 2}$</li>
</ul>
<p>Với $d_i$ là chữ số thứ $i$ của số cần tìm.</p>
<h3 id="Quy-hoach-dong"><a href="#Quy-hoach-dong" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Để đơn giản hóa việc đếm trong đoạn $[A..B]$
ta có thể tính số phần tử nhỏ hơn $B + 1$
rồi trừ đi số phần tử nhỏ hơn $A$. Việc
chỉ viết 1 hàm qhđ sẽ đơn giản hóa bài toán.
Ta tập trung vào bài tính số phần tử thỏa
mãn nhỏ hơn $X$.</p>
<h4 id="Cong-thuc"><a href="#Cong-thuc" class="headerlink" title="Công thức"></a>Công thức</h4><p>Gọi $f[i][a][b][sm]$ là số các số đã xây
$i$ chữ số đầu tiên, 2 chữ số cuối cùng đã
xây là $a$ và $b$, và $sm$ là biến quản lí
việc so sánh số đang xây với $X$ (1 nếu đã
nhỏ hơn, 0 nếu vẫn bằng nhau).</p>
<p>Từ đây ta sẽ chuyển trạng thái bằng cách
chọn chữ số điền tiếp theo ($n$) thỏa mãn:</p>
<ul>
<li>$n \neq a$ và $n \neq b$</li>
<li>$sm = 1$ hoặc $n \le X_{i + 1}$</li>
</ul>
<p>Độ phức tạp sẽ là $O(\log_{10}N \times 10^3)$.
Tất nhiên do tính chất phải lưu 2 chữ số
nên phần cài đặt sẽ lằng nhằng, đồng thời
để dễ dàng xét số chữ số của số đang qhđ ta
cũng cần một số ý tưởng kì dị để quản lí
(ví dụ, bạn phải xây các số 0 phía trước
và cho phép đối xứng).</p>
<h4 id="Quan-li-trang-thai"><a href="#Quan-li-trang-thai" class="headerlink" title="Quản lí trạng thái"></a>Quản lí trạng thái</h4><p>Mình hay làm theo kiểu coi $X$ và số cần
tìm như các số có 20 chữ số với số 0 đứng đầu
khi qhđ chữ số. Tuy nhiên riêng với bài này
việc xử lí trở nên khó khăn hơn khi các số
0 đứng đầu không tạo ra xâu con đối xứng.
Vì vậy, mình làm như sau:</p>
<ul>
<li>Thay vì gọi chữ số 0 ở đầu là 0 gây nhầm
với số 0 ở giữa số, ta gọi số này là <strong>-1</strong></li>
<li>Mình cho phép đặt thêm -1 thoải mái, nhưng
chỉ khi số ngay trước cũng là -1.</li>
<li>Tất nhiên, chữ số đầu tiên không phải -1
phải là một chữ số khác 0.</li>
<li>Và cuối cùng, yêu cầu trên sẽ xóa bỏ số 0
khỏi tập thỏa mãn, vì vậy về sau bạn nên
thêm riêng số này nếu cần.</li>
</ul>
<p>Để đơn giản ta coi $f[0][-1][-1][0] = 1$,
do ta có thể coi có vô tận chữ số -1 phía
trước. Đáp số sẽ là tổng các $f[20][a][b][1]$.</p>
<h2 id="pipes-1"><a href="#pipes-1" class="headerlink" title="pipes"></a>pipes</h2><h3 id="Giai-tren-cay"><a href="#Giai-tren-cay" class="headerlink" title="Giải trên cây"></a>Giải trên cây</h3><p>Ta có cách giải sau trên cây:</p>
<ul>
<li>Chọn một lá $v$. Hiển nhiên nếu cây có
trên 1 đỉnh thì sẽ tồn tại 1 lá.</li>
<li>Xét cạnh $(v, p_v)$. Hiển nhiên trọng số
cạnh này chính là $B[v]$. Ta giải được
cạnh này, và xóa $v$ khỏi cây, giảm $B[p_v]$.</li>
<li>Đồ thị còn lại cũng là một cây, ta
tiếp tục làm đến khi không còn cạnh nào.</li>
</ul>
<p>Do ở mỗi bước, trọng số cạnh là xác định,
nên trên cây luôn tồn tại 1 đáp án duy nhất.
Ta có thể giải với độ phức tạp $O(N)$.</p>
<h3 id="Do-thi…-lua-dao"><a href="#Do-thi…-lua-dao" class="headerlink" title="Đồ thị… lừa đảo"></a>Đồ thị… lừa đảo</h3><p>Vì mỗi thành phần liên thông không liên quan
đến nhau, ta có thể giải riêng. Do vậy từ
đây ta coi đồ thị là liên thông.</p>
<p>Với bài toán đã cho,
ta có thể coi đây là một hệ $N$ phương trình
$M$ ẩn. Hiển nhiên nếu $M &gt; N$ thì hệ sẽ có
vô số nghiệm. Vì vậy, ta chỉ cần xét bài
toán khi $M \le N$.</p>
<p>Nếu $M &lt; N$ và đồ thị liên thông thì đây là
cây, ta giải được ở trên.
Vậy ta chỉ cần quan tâm đến $M = N$, tức đồ
thị “mặt trời”: một chu trình đơn, với mỗi đỉnh
trong chu trình có thể là gốc một cây.</p>
<h3 id="Chu-trinh"><a href="#Chu-trinh" class="headerlink" title="Chu trình"></a>Chu trình</h3><p>Với phần cây “tua rua” trên mỗi đỉnh, cách giải
giống hệt như giải từng cây ở trên. Bài toán
chỉ còn lại một chu trình đơn duy nhất.</p>
<p>Trước tiên, ta cần biết nếu chu trình có độ
dài chẵn thì sẽ có vô số nghiệm. Thật vậy, giả
sử ta tìm được một nghiệm. Theo chiều kim đồng
hồ, tăng các cạnh chẵn thêm 1 và giảm các cạnh
lẻ đi 1. Ta thấy tổng của tất cả các đỉnh đều
không đổi. Vì vậy, từ một nghiệm ta có thể tạo
ra vô số nghiệm khác.</p>
<p>Như vậy, ta chỉ giải trường hợp độ dài lẻ.
Ta tính tổng sau:</p>
<p>$$P = B_1 + B_2 + … + B_{2k + 1}$$
$$ = (A_{2k + 1} + A_1) + (A_1 + A_2) +
… + (A_{2k} + A_{2k + 1})$$
$$ = 2(A_1 + A_2 + … + A_{2k + 1})$$</p>
<p>Và</p>
<p>$$ Q = B_2 + B_4 + … + B_{2k} $$
$$ = (A_1 + A_2) + (A_3 + A_4) + … +
(A_{2k - 1} + A_{2k}) $$</p>
<p>Dễ dàng nhận thấy $A_{2k + 1} = P / 2 - Q$.
Khi đã có $A_{2k + 1}$, ta có thể tính được
tất cả các số còn lại với độ phức tạp là $O(N)$.</p>
<p>Như vậy tổng cộng thuật toán của ta là $O(N)$.</p>
<h2 id="brunhilda-1"><a href="#brunhilda-1" class="headerlink" title="brunhilda"></a>brunhilda</h2><h3 id="Quy-hoach-dong-1"><a href="#Quy-hoach-dong-1" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Gọi $f[i]$ là số bước nhỏ nhất để đưa $i$
về 0. Ta có:</p>
<ul>
<li>$f[0] = 0$</li>
<li>$f[i] = \min\limits_{i \mod A[j] &gt; 0}^
{1 \le j \le N}f[i - i \mod A[j]] + 1$</li>
</ul>
<p>Ta sẽ cần tính $f[i]$ với mọi $1 \le i \le 10^7$.
Sau khi tính thì mỗi truy vấn ta trả lời
trong $O(1)$. Độ phức tạp sẽ là $O(10^7N)$,
quá lớn, cần cải tiến.</p>
<h3 id="So-lan-thay-doi-gia-tri"><a href="#So-lan-thay-doi-gia-tri" class="headerlink" title="Số lần thay đổi giá trị"></a>Số lần thay đổi giá trị</h3><p>Xét $1 \le i \le N$. Giá trị tối ưu của
$f[k \times A[i]]$ sẽ được cập nhật cho
các số từ $k A[i] + 1$ đến $(k + 1)A[i] - 1$.
Như vậy, có $10^7 / A[i]$ lần hàm thay đổi
giá trị.</p>
<p>Do $A[i]$ là các số nguyên tố khác nhau, nên
chỉ có $10^7 / 2 + 10^7 / 3 + … \le 29 \times 10^6$
(10^5 số nguyên tố đầu) lần đổi giá trị.</p>
<p>Hơn nữa, ta cũng có thể thấy
$f[kA[i]] \le f[(k + 1)A[i]] \le f[kA[i]] + 1$.
Ta sẽ tìm cách sử dụng tính chất này khi tối ưu.</p>
<h3 id="Tinh-nhanh"><a href="#Tinh-nhanh" class="headerlink" title="Tính nhanh"></a>Tính nhanh</h3><p>Trước tiên, nếu một số là bội của tất cả
các số $A[i]$ thì chắc chắn số đó không thể
biến đổi được, ta sẽ không tính trường hợp đó.</p>
<p>Không khó để nhận ra $f[i]$ là hàm không giảm
khi $i$ tăng, vì thế ta có thể giữ lại một
deque các $f[j]$ còn thỏa mãn đứng trước, và
xóa dần đuôi khi chúng không còn được tính nữa.</p>
<p>$f[j]$ không được tính nữa khi với mọi $A[k]$
là ước của $j$ thì $i \ge A<a href="j / A[k] + 1">k</a>$.</p>
<p>Ta có thể lưu lại bộ đếm của từng $j$, tiến
deque khi phần tử đầu tiên có bộ đếm về 0.</p>
<p>Tổng độ phức tạp sẽ là $O(29 \times 10^6 + N)$.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://natsukagami.github.io/2017/05/03/2017-05-03-Training/" data-id="cj290jo6y0000e12bm62f09qp" class="article-share-link">Chia sẻ</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Training/">Training</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/apio/">apio</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thay-Phuong/">thầy Phương</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vietnamese/">vietnamese</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HSGSO-2016-Editorial" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/01/HSGSO-2016-Editorial/" class="article-date">
  <time datetime="2017-05-01T10:00:00.000Z" itemprop="datePublished">2017-05-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Editorials/">Editorials</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/01/HSGSO-2016-Editorial/">HSGSO 2016 Editorial</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Trong năm vừa rồi có kha khá nhiều bạn hỏi mình
cũng như các bạn khác trong BTC HSGSO 2016 (môn
Tin) về solution của contest. Vì hồi đó không có
thời gian (<em>thực ra là lười</em>) nên bọn mình chưa
có dịp chữa bài. Lần này mình quyết định làm cho
chót.</p>
<h1 id="De-bai"><a href="#De-bai" class="headerlink" title="Đề bài"></a>Đề bài</h1><p>Các bạn có thể tải đề bài gốc tại <a href="https://drive.google.com/file/d/0ByCMlnXUqIAIVmpSUWh6dHo1a2c/view" target="_blank" rel="external">đây</a>.</p>
<h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="Muc-luc"><a href="#Muc-luc" class="headerlink" title="Mục lục"></a>Mục lục</h2><ol>
<li><a href="#color">color</a></li>
<li><a href="#domino">domino</a></li>
<li><a href="#gift">gift</a></li>
<li><a href="#letter-o">letter-o</a></li>
<li><a href="#paren">paren</a></li>
<li><a href="#polylines">polylines</a></li>
<li><a href="#socket">socket</a></li>
<li><a href="#zigzag">zigzag</a></li>
</ol>
<h2 id="color"><a href="#color" class="headerlink" title="color"></a>color</h2><p><strong>Author</strong>: Nguyễn Đinh Quang Minh</p>
<h3 id="An-diem"><a href="#An-diem" class="headerlink" title="Ăn điểm"></a>Ăn điểm</h3><p>Để có 10% đầu tiên cho bài này ta nhận thấy chỉ
có cách tô duy nhất là so le với $K = 2$, như
vậy chỉ cần in $0$ khi $K = 1$ và $2$ khi $K = 2
$ là bạn đã cầm trong tay 1 điểm đầu tiên.</p>
<h3 id="Bieu-dien-trang-thai"><a href="#Bieu-dien-trang-thai" class="headerlink" title="Biểu diễn trạng thái"></a>Biểu diễn trạng thái</h3><p>Ta sẽ tiếp cận bài toán, đầu tiên bằng phương
pháp quy hoạch động. Qhđ thường là hướng giải
đúng đối với những bài toán đếm. Để có thể
triển khai qhđ, ta cần biết cách biểu diễn
một trạng thái đang xây.</p>
<p>Để ý giới hạn của bảng là $3 \times N$. Vì chỉ
có 3 ô nên ta hoàn toàn có thể biểu diễn trạng
thái của một cột bằng một $K-$mask - một số
có 3 chữ số trong đó các chữ số trong khoảng
$0$ đến $K - 1$ (theo cơ số $K$). 2 chữ số
liên tiếp phải khác nhau, nên số trạng thái
thỏa mãn một cột sẽ là $5 \times 4 \times 4 =
80$ trạng thái với $K = 5$.</p>
<p>Ta có thể có hàm quy hoạch động đơn giản
$f[i][mask]$ là số cách điền $i$ cột đầu tiên,
trong đó cột cuối cùng có trạng thái là $mask$.
Từ $f[i][mask]$ ta chuyển trạng thái sang
$f[i + 1][mask’]$, for hết $mask’$ thỏa mãn.
Ta có thể thấy cách này có độ phức tạp
$O(80^2 N)$, chưa đủ thỏa mãn cả subtask 2.
Kể cả khi ta chỉ lọc ra các $mask’$ thỏa mãn
và for chúng, ta vẫn có độ phức tạp $O(3380 N)$,
vẫn chưa thể thỏa mãn subtask 2.</p>
<h3 id="Cai-tien-quy-hoach-dong"><a href="#Cai-tien-quy-hoach-dong" class="headerlink" title="Cải tiến quy hoạch động"></a>Cải tiến quy hoạch động</h3><p>Thay vì chuyển trạng thái cả cột cùng lúc, ta
có thể thay bằng việc mỗi lần chỉ điền 1 ô, lần
lượt từ cột đầu sang cột cuối, mỗi cột điền
từ trên xuống dưới. Trạng thái ta lưu lại sẽ
là trạng thái của $K$ ô cuối cùng ta điền.</p>
<p>Tại sao lại lưu như vậy? Thực chất, khi điền lần
lượt, ta chỉ cần quan tâm đến ô phía trên và
bên trái nó, tức ô cách ô hiện tại $1$ và $K$
bước điền. Nhưng do ta cần tính cả các ô phía
sau nên ta phải lưu trạng thái của cả $K$ ô
trước đó.</p>
<p>Gọi $f[i][j][mask]$ là số cách điền các ô từ
đầu đến $(i, j)$, với $K$ cuối cùng mình điền
được lưu trong $mask$. Để chuyển sang ô tiếp
theo, ta cần for một trong $K$ màu của ô
tiếp theo ô $(i, j)$. Như vậy đpt sẽ là
$O(100 <em> N </em> K * 3)$ ($5^2 \times 4$ trạng thái, do
khi lưu như này có thể tồn tại 2 ô liên tiếp
cùng màu), vừa khít qua subtask 2. Code hơi trâu
nhưng không sao, worth it, vì ta đã có 50% số
điểm.</p>
<p>Bạn có thể xem thêm 1 bài mình đã chữa có cách
qhđ tương tự ở <a href="https://natsukagami.github.io/2017/04/21/2017-04-20-Training/">đây (bài Domino)</a>.</p>
<h3 id="Nhan-ma-tran"><a href="#Nhan-ma-tran" class="headerlink" title="Nhân ma trận"></a>Nhân ma trận</h3><p>Đối với những bạn đã biết về nhân ma trận, ta
có thể bỏ qua phần quy hoạch động cải tiến phía
trên và thay vào đó, cải tiến qhđ $O(80^2 N)$
thành nhân ma trận $O(80^3 \log N)$. Việc
chuyển đổi không khó, thực chất ta chỉ cần
dựng bảng chuyển đổi $80 \times 80$ xem 2 trạng
thái nào có thể chuyển được cho nhau, mũ $N-1$
lần lên rồi lấy ma trận $1 \times 80$ toàn 1
(thể hiện hàng đầu) nhân cùng tích ban nãy,
ra được một ma trận $1 \times 80$ mới, đáp số
chính là tổng các phần tử.</p>
<p>Việc nhân ma trận như nào chỉ là kĩ thuật cơ
bản nên mình sẽ không nói nhiều.</p>
<p>Kiến thức nhân ma trận, so với tối ưu quy hoạch
động như trên, là phổ thông hơn nhiều, vì thế
subtask 3 không cho nhiều điểm như subtask 2.</p>
<h3 id="1-ti-mau"><a href="#1-ti-mau" class="headerlink" title="1 tỉ màu??"></a>1 tỉ màu??</h3><p>Đọc đến subtask 4 hẳn tất cả sẽ ngạc nhiên khi
$K$ thay đổi đáng ngạc nhiên: từ $\le 5$ và
là mấu chốt giải bài toán, thành $10^9$ -
không còn đưa được vào độ phức tạp nữa. Để đào
sâu vào subtask này, ta cần có một nhận xét
về tương quan các màu giữa các cột.</p>
<h4 id="Tuong-quan-cac-mau"><a href="#Tuong-quan-cac-mau" class="headerlink" title="Tương quan các màu"></a>Tương quan các màu</h4><p>Trong một cột, chỉ có 2 loại tương quan sau:</p>
<ul>
<li>$a,b,c$ - tức 3 ô trong cột khác nhau</li>
<li>$a,b,a$ - tức 2 ô đầu và cuối giống nhau</li>
</ul>
<p>Hơn nữa, số cách chọn màu cho cột $i + 1$ chỉ
phụ thuộc vào tương quan của hàng $i$, theo bảng
sau:</p>
<ul>
<li>Từ $a, b, c$:<ul>
<li>Sang $a, b, c$: có $(K-1)+2(K-2)^2+
(K-3)(K-1)+(K-3)(K-2)^2$ cách.</li>
<li>Sang $a, b, a$: có $(K-1)+(K-3)(K-2)$ cách.</li>
</ul>
</li>
<li>Từ $a, b, a$:<ul>
<li>Sang $a, b, c$: có $(K-1)+(K-3)(K-2)$ cách.</li>
<li>Sang $a, b, a$: có $(K-1)+(K-2)^2$ cách.</li>
</ul>
</li>
</ul>
<p>Việc chứng minh chỉ là công thức tổ hợp, mình sẽ
không chứng minh để chống dài dòng.</p>
<p>Như vậy ta không cần lưu cụ thể các màu, mà chỉ
cần tương quan giữa các màu, tức chỉ còn 2 trạng
thái để quản lí chứ không nhiều như trưóc. Việc qhđ để ăn sub 4
(độ phức tạp $O(2^2 N)$) hay nhân ma trận để ăn
sub 5 (độ phức tạp $O(2^3 \log N)$) có thể được
thực hiện đơn giản.</p>
<h2 id="domino"><a href="#domino" class="headerlink" title="domino"></a>domino</h2><p><strong>Author</strong>: thầy Hồ Đắc Phương</p>
<h3 id="Backtrack"><a href="#Backtrack" class="headerlink" title="Backtrack"></a>Backtrack</h3><p>Ở subtask 1, đơn giản ta chỉ cần backtrack
tất cả các cách đặt domino. Do bảng chỉ có
$2 \times 20$ nên không có đến $2^{20}$ cách đặt
là tối đa. Độ phức tạp sẽ là $O(2^N)$.</p>
<h3 id="Bo-de-lat-gach-co-ban"><a href="#Bo-de-lat-gach-co-ban" class="headerlink" title="Bổ đề: lát gạch cơ bản"></a>Bổ đề: lát gạch cơ bản</h3><p><strong>Đếm số cách lát gạch vào bảng $2 \times N$</strong></p>
<p>Có lẽ đây là bài toán nổi tiếng trong giới
VNOI. Cách giải khá đơn giản: quy hoạch động
$f[i]$ là số cách lát $i$ cột đầu tiên. Ta
có 2 cách lát: 1 viên dọc (chuyển xuống
$f[i - 1]$) hoặc 2 viên ngang (chuyển xuống
$f[i - 2]$). Độ phức tạp là $O(N)$, hoặc vì
đây là phương trình đệ quy tuyến tính nên
ta có thể nhân ma trận $O(2^3 \log N)$.</p>
<p>Không khó để nhận ra $f[i]$ cũng chính là
số fibonacci, ta cũng có 1 số cách tính
chính xác khác trong $O(\log N)$.</p>
<h3 id="Cach-dien-duy-nhat"><a href="#Cach-dien-duy-nhat" class="headerlink" title="Cách điền duy nhất?"></a>Cách điền duy nhất?</h3><p>Để giải <em>tất cả subtask sau</em>, ta cần có chút quan
sát về các ô cấm:</p>
<ul>
<li>Nếu một cột bị cấm cả 2 ô, hiển nhiên ta
có bên trái và bên phải là 2 bài toán riêng
biệt, ta chỉ cần tính riêng 2 bên rồi nhân
vào nhau.</li>
<li>Nếu một cột bị chặn 1 ô, hiển nhiên ô đó
thuộc một viên domino ngang. Ta sẽ phải lựa
chọn viên ngang đó nằm lệch về bên trái hay
bên phải.</li>
</ul>
<p>Ngạc nhiên thay, cách chọn ô đó là duy nhất.
Để hiểu rõ tại sao, hãy xét 3 trường hợp sau:</p>
<h5 id="Nhan-1-ben"><a href="#Nhan-1-ben" class="headerlink" title="Nhận 1 bên"></a>Nhận 1 bên</h5><p><img src="/images/domino_one.png" alt="TH 1. Ô đỏ là ô cấm"></p>
<p>Hiển nhiên trong trường hợp này, số cách điền
là 0. Đơn là vì có lẻ ô.</p>
<h5 id="Nhan-2-ben-dien-duoc"><a href="#Nhan-2-ben-dien-duoc" class="headerlink" title="Nhận 2 bên, điền được"></a>Nhận 2 bên, điền được</h5><p><img src="/images/domino_two.png" alt="TH 2, cách điền duy nhất"></p>
<p>Xét cột thứ nhất, ta có cách điền domino duy
nhất. Con domino này chắn 1 ô của cột thứ hai,
làm cho bài toán đệ quy xuống. Tại mỗi bước
chỉ có một cách điền duy nhất nên với cả đoạn
cũng chỉ tồn tại 1 cách điền.</p>
<h5 id="Nhan-2-ben-khong-dien-duoc"><a href="#Nhan-2-ben-khong-dien-duoc" class="headerlink" title="Nhận 2 bên, không điền được"></a>Nhận 2 bên, không điền được</h5><p><img src="/images/domino_three.png" alt="TH 3"></p>
<p>Giống như trường hợp trên, nhưng vì khi đặt
con domino cuối cùng, ta bị đặt trùng lên ô
cấm, nên ta không thể điền trường hợp này.</p>
<p>Phân biệt với TH 2 như nào? Ta điền được
khi và chỉ khi:</p>
<ul>
<li>Cả đoạn độ dài chẵn <strong>và</strong> 2 ô cấm cùng hàng,
<em>hoặc</em></li>
<li>Cả đoạn độ dài lẻ <strong>và</strong> 2 ô cấm khác hàng</li>
</ul>
<h3 id="Cach-tinh"><a href="#Cach-tinh" class="headerlink" title="Cách tính"></a>Cách tính</h3><p>Xét một đoạn bị chắn 2 đầu là cột 2 ô cấm (hoặc
biên, ta có thể coi 2 biên là 2 cột 2 ô cấm).
Gọi $P_1, P_2, …, P_K$ là vị trí các cột có
1 ô cấm, từ trái sang phải.</p>
<p>Hiển nhiên nếu $K$ lẻ thì có 0 cách điền vì có
lẻ ô.</p>
<p><img src="/images/domino_all.png" alt="$P_1 = 3$, $P_2 = 5$, số cách điền là $f[2] \times 1 \times f[3]$"></p>
<p>Ta có:</p>
<ul>
<li>Xét đoạn $1..P_1$: Hiển nhiên viên ở $P_1$ sẽ
đặt sang phải vì nếu không ta sẽ có TH 1. Số
cách điền đoạn $1..P_1-1$ là $f[P_1 - 1]$.</li>
<li>Xét đoạn $P_1..P_2$: Vì viên ở $P_1$ đặt trọn
trong đoạn nên $P_2$ cũng vậy, nếu không sẽ
bị TH 1. Số cách điền là 0 hoặc 1 phụ thuộc
vào nó là TH 2 hay 3.</li>
<li>Xét đoạn $P_2..P_3$, vì viên ở $P_2$ nằm
trọn bên trái nên trường hợp này như đoạn
$1..P_1$, số cách chọn là $f[P_3 - P_2 - 1]$.</li>
<li>Vân vân, xét đến khi ta gặp $P_{2k}..N$
thì cũng như đoạn đầu, số cách là $f[N - 2k]$.</li>
</ul>
<p>Số cách điền cả đoạn sẽ là tích số cách điền
từng đoạn con.</p>
<p>Độ phức tạp là $O(N \log 10^9)$, vì ta tính
$f[i]$ trong $O(\log i)$.</p>
<h3 id="Tai-sao-lai-chia-subtask-nhu-vay"><a href="#Tai-sao-lai-chia-subtask-nhu-vay" class="headerlink" title="Tại sao lại chia subtask như vậy?"></a>Tại sao lại chia subtask như vậy?</h3><p>Với $K = 4$, bạn có thể mập mờ nhìn ra tính
chất trên khi chia tất cả trường hợp 4 ô cấm.
Bọn mình muốn hướng suy nghĩ phải theo mạch
tự nhiên, không bị gò bó.</p>
<h2 id="gift"><a href="#gift" class="headerlink" title="gift"></a>gift</h2><p><strong>Author</strong>: Nguyễn Đức Duy</p>
<h3 id="Thuat-toan-backtrack"><a href="#Thuat-toan-backtrack" class="headerlink" title="Thuật toán backtrack"></a>Thuật toán backtrack</h3><p>Với $N \le 10$, ta có thể thực hiện backtrack,
mỗi bước cho phần tử $i$ cho Alice, Bob hoặc
giữ lại. Đến cuối, nếu có đáp án, ta in ra
và thoát chương trình.</p>
<p>Do mỗi bước ta có 3 lựa chọn nên độ phức tạp
là $O(3^N)$.</p>
<h3 id="22-phan-tu"><a href="#22-phan-tu" class="headerlink" title="22 phần tử"></a>22 phần tử</h3><p>Với $N$ lớn hơn, hẳn là lượng tập con
càng lớn so với giới hạn, vì thể xác suất
tồn tại đáp số càng lớn.
Ta sẽ chứng minh chỉ với 22 phần tử, luôn
luôn tồn tại đáp số.</p>
<p>Hiển nhiên, với 22 phần tử, ta có $2^{22} - 1$
tập con không rỗng.
Đồng thời, các tổng nằm trong khoảng $1..
22 \times 10^5$.
Vì $2^22 - 1 &gt; 22 \times 10^5$ nên theo định
lí Dirichlet ta luôn có 2 tập có cùng tổng.</p>
<p>Gọi 2 tập này là $x$ và $y$. Chắc chắn 2 tập
này không phải tập con của nhau, vì mỗi phần
tử đều lớn hơn 0. Như vậy chắc chắn tồn tại
ít nhất 1 phần tử của mỗi tập mà không tồn
tại trong tập kia.</p>
<p>Ta loại đi các phần tử có trong cả 2 (vì
chúng cùng trừ cả 2 bên đi 1 lượng), và
còn lại 2 tập không rỗng. Đây chính là đáp số.</p>
<p>Như vậy, với $N \ge 22$, ta chỉ cần bốc ra
22 phần tử rồi tính tất cả tổng tập con, lấy
2 tập bằng nhau và loại đi các phần tử trùng
là sẽ ra đáp số.</p>
<p>Độ phức tạp là $O(2^{22})$.</p>
<h3 id="N-“at-o”"><a href="#N-“at-o”" class="headerlink" title="$N$ “ất ơ”"></a>$N$ “ất ơ”</h3><p>Vậy với $10 &lt; N &lt; 22$ thì sao? Rất tiếc bọn
mình không chuẩn bị được test mà giết được
thuật ở trên. Tuy nhiên, ta vẫn có thể
backtrack gặp nhau ở giữa, lần lượt backtrack
$3^{10}$ trường hợp ở đầu và $3^{N - 10}$
trường hợp ở cuối, sau đó ghép 2 số có
hiệu trái dấu.
Như vậy độ phức tạp sẽ không quá $O(3^{N / 2})$.</p>
<h2 id="letter-o"><a href="#letter-o" class="headerlink" title="letter-o"></a>letter-o</h2><p><strong>Author</strong>: mình</p>
<p>Lưu ý đây là bài output-only, vì vậy bạn có
5 tiếng để chạy chứ không phải 1 giây.</p>
<h3 id="Thuat-toan-O-N-4"><a href="#Thuat-toan-O-N-4" class="headerlink" title="Thuật toán $O(N^4)$"></a>Thuật toán $O(N^4)$</h3><p>Thực ra thuật toán $O(N^4)$ khá đơn giản, ta
chỉ cần for 2 góc của hình chữ nhật và kiểm
tra liệu 4 cạnh của chúng có chứa toàn cùng
kí tự không. Để kiểm tra ta có thể tính
trước mảng cộng dồn $O(N^2)$.</p>
<p>Lấy thuật $O(N^4)$ có thể chạy 1s đến input 5,
và ăn 50% số điểm.
Bài thật là dễ!</p>
<h3 id="Thuat-toan-O-N-3"><a href="#Thuat-toan-O-N-3" class="headerlink" title="Thuật toán $O(N^3)$"></a>Thuật toán $O(N^3)$</h3><p>Ta nhận thấy, nếu ta for trước 2 cạnh song song
của hình chữ nhật, thì chỉ cần xét các vị trí
mà có toàn kí tự <code>x</code> nào đó trong cả đoạn nằm
giữa 2 cạnh. Ta sẽ chọn 2 điểm xa nhau nhất mà
2 điểm đó dọc 2 cạnh đều là các kí tự giống nhau.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">11111</div><div class="line">10021</div><div class="line">10311</div><div class="line">11111</div><div class="line">10231</div><div class="line">11111</div><div class="line">10230</div><div class="line">11111</div></pre></td></tr></table></figure>
<p>Xét ví dụ trên, chọn 2 cột đầu cuối. Ta thấy
chỉ có các hàng 1, 4, 6 và 8 có thể làm 2
cạnh ngang của hình chữ nhật. Ngoài ra,
chỉ có 1, 4, 6 được nối với nhau. Ta chọn
hình lớn nhất (1 - 6).</p>
<p>Việc lựa chọn có thể được thực hiện chỉ trong
$O(N)$ bằng một vòng for lưu max. Như vậy ta
có thuật $O(N^3)$ đủ ăn input 6.</p>
<h3 id="Suc-manh-cua-input"><a href="#Suc-manh-cua-input" class="headerlink" title="Sức mạnh của input!"></a>Sức mạnh của input!</h3><p>Đối với input 7 và 8, đáp số được đảm bảo là
lớn, nên bạn có thể sử dụng chiến thuật chỉ
bài output-only mới có: sử dụng mắt.</p>
<p>Với mỗi số ta có thể in ra vị trí của chúng
(và để trống những vị trí khác). Việc nhìn
bằng mắt cũng sẽ cho ta thấy một số hình lớn,
chỉ việc thử vào đáp số.</p>
<h3 id="Tim-kiem-pattern"><a href="#Tim-kiem-pattern" class="headerlink" title="Tìm kiếm pattern"></a>Tìm kiếm pattern</h3><p>Nếu nhìn kỹ, bạn có thể nhận ra input 9 có pattern
khá dị, khi chỉ có một số hình chữ nhật. Bạn có
thể nhìn tay và chỉ chạy các miền có hình chữ nhật
thỏa mãn.</p>
<h3 id="…-hoac-khong"><a href="#…-hoac-khong" class="headerlink" title="… hoặc không"></a>… hoặc không</h3><p>Để giải input 10, bạn cần phải nhận ra quy tắc
quan trọng nhất: bạn không bị giới hạn bởi thời
gian chạy của máy chấm. Vì thế hãy nhập input
10 vào, đặt cận đáp số và chờ 15-20 phút cho
máy chạy. Tính trên máy trường mình, chỉ mất
1h để chạy tất cả input với $O(N^3)$ đặt cận
đáp số! Bạn có 5 tiếng cơ mà, chạy trâu rồi
làm bài khác… đó là chiến thuật của bài này.</p>
<h2 id="paren"><a href="#paren" class="headerlink" title="paren"></a>paren</h2><p><strong>Author</strong>: thầy Hồ Đắc Phương &amp; Phạm Tùng
Dương.</p>
<h3 id="De-quy"><a href="#De-quy" class="headerlink" title="Đệ quy"></a>Đệ quy</h3><p>Thực chất đây chỉ là một bài tính toán có
chút lằng nhằng. Phương thức tính toán như
sau, xét đoạn ngoặc $l..r$ là 1 cặp ngoặc:</p>
<ul>
<li>Tính tất cả các cặp ngoặc con $l_1..r_1, …, l_p..r_p$</li>
<li>Độ cao của $l..r$ là max độ cao của các cặp ngoặc con, cộng 1</li>
<li>Độ dài của $l..r$ là tổng độ dài của các cặp
ngoặc con, cộng $p-1$ khoảng cách ở giữa,
cộng 2 hoặc 4 tùy loại ngoặc của $l..r$</li>
<li>Phần tô màu của $l..r$ là:<ul>
<li>Nếu viền ngoài cùng của $l..r$ là đen:
độ dài $\times$ độ cao $-$ diện tích các hình con</li>
<li>Nếu không thì là 0</li>
<li>Sau đó cộng thêm phần tô màu các hình con</li>
</ul>
</li>
</ul>
<h3 id="Dung-cay"><a href="#Dung-cay" class="headerlink" title="Dựng cây"></a>Dựng cây</h3><p>Để có thể dựng quan hệ cha - con và tính đệ quy
trong $O(N)$, ta sẽ cần dựng cây bằng stack.
Cách dựng như sau:</p>
<ul>
<li>Duy trì 1 stack, lúc đầu stack rỗng</li>
<li>Đi từ trái sang phải, giả sử kí tự ta có là
$S_x$:<ul>
<li>Nếu $S_x$ là mở ngoặc: Nếu stack không rỗng,
thì cặp ngoặc $x$ có cha là đỉnh stack. Push
$x$ vào stack.</li>
<li>Nếu $x$ là đóng ngoặc: xóa đỉnh stack.</li>
</ul>
</li>
</ul>
<p>Tổng độ phức tạp là $O(N)$.</p>
<h2 id="polylines"><a href="#polylines" class="headerlink" title="polylines"></a>polylines</h2><p><strong>Author</strong>: mình</p>
<h3 id="Quy-hoach-dong-trau-co-ban"><a href="#Quy-hoach-dong-trau-co-ban" class="headerlink" title="Quy hoạch động trâu cơ bản"></a>Quy hoạch động trâu cơ bản</h3><p>Để đơn giản ta coi điểm xuất phát là $0$,
đích là $M + 1$.</p>
<p>Ta có công thức quy hoạch động: Gọi $f[i]$ là
số đường đi kết thúc ở $i$. Ta có</p>
<ul>
<li>$f[0] = 1$</li>
<li>$f[i] = \sum\limits_{X_j \le X_i, Y_j \le Y_i, i \neq j}f[j]$</li>
<li>Đáp số là $f[M + 1]$ - 1.</li>
</ul>
<p>Để có thứ tự qhđ ta chỉ cần sort các điểm theo cả 2 tọa độ tăng
dần.
Chỉ đơn giản vậy ta có thuật toán $O(N^2)$.</p>
<h3 id="Tang-toc"><a href="#Tang-toc" class="headerlink" title="Tăng tốc!"></a>Tăng tốc!</h3><p>Nhìn vào điều kiện của $j$ ở hàm qhđ, ta nhận thấy hoàn toàn
có thể lấy nhanh tổng các $f[j]$ bằng 1 cấu trúc
dữ liệu nào đó.</p>
<p>Nhận thấy, khi sort các phần tử theo $X$ rồi lấy
các phần tử đứng trước, ta chỉ còn cần lọc
điều kiện $Y$ là đủ. Việc này ta hoàn toàn có
thể sử dụng BIT để lấy nhanh, sort tọa độ BIT
theo $Y$ rồi get prefix, update điểm.</p>
<p>Độ phức tạp là $O(N \log N)$.</p>
<h2 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h2><p><strong>Author</strong>: Nguyễn Đức Duy</p>
<h3 id="Tim-dap-an"><a href="#Tim-dap-an" class="headerlink" title="Tìm đáp án"></a>Tìm đáp án</h3><p>Không khó để nhận ra nếu chỉ có thể xếp được
$K$ thiết bị, ta luôn lấy $K$ thiết bị có
độ yêu cầu cao nhất. Vì vậy ta có thể sort
thiết bị theo yêu cầu giảm dần rồi chặt nhị
phân, kiểm tra xem có thể đặt $K$ thiết bị
đầu tiên không.</p>
<h3 id="Xep-o-dien-nhu-nao"><a href="#Xep-o-dien-nhu-nao" class="headerlink" title="Xếp ổ điện như nào?"></a>Xếp ổ điện như nào?</h3><p>Ta có thể coi hệ thống ổ điện như một cây,
trong đó gốc nối với nguồn. Xét 2 ổ điện
$i$ và $j$, trong đó $i$ gần gốc hơn $j$.
Nếu $A_i$ &lt; $A_j$, ta hoàn toàn có thể
đổi chỗ $i$ và $j$ và đáp án không thể
nhỏ hơn ban đầu. Vì thế, để xây cây từ gốc,
ta đặt các ổ điện theo thứ tự $A_i$ giảm dần.</p>
<p>Với nhận xét trên, ta coi như $A_i$ đã
được xếp giảm dần. Giờ ta BFS theo từng tầng,
dễ dàng nhận thấy khi xét tầng $x$:</p>
<ul>
<li>Nếu tồn tại $B_i = x$, lập tức phải đặt $i$
vào tầng đó. Nếu không đặt được thì kiểm
tra fail.</li>
<li>Mỗi lần ở tầng $x$ ta thêm ổ $j$ vào,
thì bớt 1 chỗ ở tầng $x$ và thêm $A_j$ chỗ
ở tầng $x + 1$. Vì $A_j$ dương nên sau khi
thêm ta luôn có nhiều chỗ ở tầng $x + 1$
cho các $B_i &gt; x$ hơn ở tầng $x$. <em>Vì vậy,</em></li>
<li>Nếu $B_i &gt; x$, ta nhường cho ổ điện nếu
còn, nếu không ta sẽ xét sau.</li>
</ul>
<h3 id="Tom-tat-thuat-toan"><a href="#Tom-tat-thuat-toan" class="headerlink" title="Tóm tắt thuật toán"></a>Tóm tắt thuật toán</h3><p>Ta chặt nhị phân $K$, kiểm tra xem có thể
xếp $K$ thiết bị $B[1..K]$ vào không.</p>
<p>Để kiểm tra:</p>
<ul>
<li>Lúc đầu ở tầng 0 ta có 1 vị trí đặt (ổ điện)</li>
<li>Nếu có nhiều $B[i] = x$ hơn số vị trí đặt,
kiểm tra fail. Nếu không, đặt hết $B[i] = x$.</li>
<li>Nếu còn chỗ ở tầng $x$ và còn ổ điện, đặt ổ
điện cho tầng $x + 1$.</li>
<li>Nếu còn chỗ, coi như chúng của tầng $x + 1$.</li>
</ul>
<p>Độ phức tạp sẽ là $O((N + M) \log M)$, do các bước
kiểm tra chỉ là $O(N + M)$.</p>
<h2 id="zigzag"><a href="#zigzag" class="headerlink" title="zigzag"></a>zigzag</h2><h3 id="Truong-hop-K-1"><a href="#Truong-hop-K-1" class="headerlink" title="Trường hợp $K = 1$"></a>Trường hợp $K = 1$</h3><p>Không khó để nhận thấy với 10 chữ số và điều
kiện phải thăm mỗi số ít nhất 1 lần và không
cần đúng thứ tự, ta sẽ cần sử dụng đến bitmask.
Từ ngôi nhà nguồn, ta cần bfs đến các đỉnh, tìm
đường đi ngắn nhất dựng ra đủ mask.</p>
<p>Trên đồ thị ta dựng ra các đỉnh $(i, j, mask)$,
tức đứng ở ô $(i, j)$ và tập các số đã đi qua là
$mask$. Từ đỉnh $(i, j)$ ta đi đến các đỉnh lân
cận, thêm mask của đỉnh đó vào nếu cần, mất
1 bước. Đáp số là khoảng cách đến đỉnh gần nhất
có mask đầy đủ 10 bit.</p>
<p>Độ phức tạp là $O(NM2^{10})$.</p>
<h3 id="K-lon-hon"><a href="#K-lon-hon" class="headerlink" title="$K$ lớn hơn"></a>$K$ lớn hơn</h3><p>Với $K$ lớn đến $M \times N$, ta không thể chỉ
đơn giản là chạy thuật toán trên $K$ lần, vì
như vậy là không thỏa mãn giới hạn bài toán.</p>
<p>Thay vào đó, ta cần một cách để có thể chạy
tất cả các truy vấn một lúc.</p>
<h3 id="Lat-nguoc-yeu-cau"><a href="#Lat-nguoc-yeu-cau" class="headerlink" title="Lật ngược yêu cầu"></a>Lật ngược yêu cầu</h3><p>Đề bài yêu cầu từ một ngôi nhà, ta đến một
ô bất kì, miễn là đủ mask trên đường đi. Ta
sẽ lật ngược yêu cầu lại, cho phép xuất phát
từ đỉnh bất kì, đi thoải mái, với điều kiện
kết thúc ở nhà và đủ mask trên đường đi.</p>
<p>Vậy điểm khác biệt là gì? Với bài toán không quan
trọng đích với mỗi nguồn, ta cần BFS với từng
nguồn riêng biệt. Tuy nhiên, với bài toán không
quan trọng nguồn, ta có thể thực hiện BFS song
song nhiều nguồn, để tính khoảng cách từ <em>nguồn
gần nhất</em> tới mỗi đỉnh, với độ phức tạp chỉ
bằng 1 lần BFS.</p>
<p>Nói cách khác, thay vì ta xuất phát từ $(X_i,
Y_i, 0)$, ta xuất phát từ tất cả các đỉnh
$(i, j, 0)$ và tìm đường từ đỉnh bất kì đến
$(X_i, Y_i, 1023)$. Để chạy song song, tưởng
tượng có một nguồn ảo nối đến tất cả nguồn
thật với trọng số 0. Như vậy, vì chỉ có 1
nguồn (ảo), nên độ phức tạp chỉ là $O(NM2^{10})$.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://natsukagami.github.io/2017/05/01/HSGSO-2016-Editorial/" data-id="cj25s8vwc0000j72bfu54oea3" class="article-share-link">Chia sẻ</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/editorial/">editorial</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hsgso/">hsgso</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vietnamese/">vietnamese</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-04-28-Training" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/28/2017-04-28-Training/" class="article-date">
  <time datetime="2017-04-28T13:00:00.000Z" itemprop="datePublished">2017-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Training/">Training</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/28/2017-04-28-Training/">2017/04/28 Training</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hôm nay có hai phần: bài thầy Hoàng và bài
anh Khuê.
Cả 2 đều cần một sự tay to nhất định.</p>
<h1 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h1><h2 id="select-thay-Hoang"><a href="#select-thay-Hoang" class="headerlink" title="select (thầy Hoàng)"></a>select (thầy Hoàng)</h2><p>Cho dãy $S$ gồm các kí tự <code>d</code> và <code>x</code>. 2 người lần
lượt chơi, mỗi lượt bốc 1 kí tự, kí tự này phải đứng
cạnh 1 vị trí đã bị chọn trước đó (trừ nước
đầu tiên được chọn thoải mái). Khi trò chơi
kết thúc, người đi trước thắng khi có nhiều <code>d</code>
<strong>hơn hẳn</strong> người kia. Đếm số vị trí ban đầu
mà người đi trước có thể chọn mà vẫn đảm bảo
chiến thắng?</p>
<h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le |S| \le 1000$.</p>
<h2 id="eureka-thay-Hoang"><a href="#eureka-thay-Hoang" class="headerlink" title="eureka (thầy Hoàng)"></a>eureka (thầy Hoàng)</h2><p>Cho một hệ thống cân đĩa được biểu diễn như
sau:</p>
<ul>
<li>Nếu chỉ gồm <code>-1</code>: Đây là một vị trí đặt
quả cân.</li>
<li>Là một cái cân có dạng <code>x y A B</code> trong đó
$x$ và $y$ lần lượt là độ dài cánh tay đòn
bên trái và bên phải của cân; $A$ và $B$ là
2 hệ thống cân được treo vào bên trái và
bên phải của cân.</li>
</ul>
<p>Hình dưới biểu diễn hệ thống cân được biểu diễn
bằng dãy <code>12 18 4 2 -1 -1 10 8 3 3 -1 -1 6 4
-1 -1</code>:</p>
<p><img src="/images/eureka_exp.png" alt="Mô tả cân (các ô có nền xanh là
các quả cân)"></p>
<p>Trọng lượng các quả cân đều phải là số
nguyên dương.</p>
<p>Hãy tìm trọng lượng cho các quả cân của từng vị
trí đặt sao cho tất cả các cân đều thăng bằng
và tổng trọng lượng các quả cân phải đặt là nhỏ
nhất. Giả sử cân không có trọng lượng.</p>
<p>In ra tổng nhỏ nhất lấy dư cho $123456789$.</p>
<h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>Miêu tả được cho bởi dãy $A[1..N]$.</p>
<p>$1 \le N \le 3 \times 10^5$, $A[i] = -1$ hoặc
$1 \le A[i] \le 100$.</p>
<h2 id="liondance-thay-Hoang"><a href="#liondance-thay-Hoang" class="headerlink" title="liondance (thầy Hoàng)"></a>liondance (thầy Hoàng)</h2><p>Cho 2 dãy số $A[1..N]$ và $B[1..N]$. Tìm dãy
con chung dài nhất sao cho 2 phần tử liên
tiếp chênh lệch nhau không quá $d$.</p>
<p>Nếu có nhiều dãy, in ra dãy có <strong>thứ tự từ
điển</strong> lớn nhất.</p>
<h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 4000$, $1 \le A[i], B[i] \le 10^9$</p>
<h2 id="desert-thay-Hoang"><a href="#desert-thay-Hoang" class="headerlink" title="desert (thầy Hoàng)"></a>desert (thầy Hoàng)</h2><p>Trên mặt phẳng cho $N$ điểm. Tìm đường đi từ
$1$ đến $N$ sao cho khoảng cách Manhattan
lớn nhất giữa 2 điểm liên tiếp đi qua là
nhỏ nhất.</p>
<h4 id="Gioi-han-3"><a href="#Gioi-han-3" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 10^5$, tọa độ $-10^9 \le X_i,
Y_i\le 10^9$</p>
<h2 id="Tron-viec-anh-Khue"><a href="#Tron-viec-anh-Khue" class="headerlink" title="Trốn việc (anh Khuê)"></a>Trốn việc (anh Khuê)</h2><p>Cho dãy số $A[1..3N]$, chọn ra tập số có
tổng lớn nhất sao cho trong $N$ số liên
tiếp bất kì có không quá $K$ số được chọn.</p>
<h4 id="Gioi-han-4"><a href="#Gioi-han-4" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 200$, $1 \le K \le 10$, $1
\le A[i] \le 10^6$</p>
<h2 id="Party1-anh-Khue"><a href="#Party1-anh-Khue" class="headerlink" title="Party1 (anh Khuê)"></a>Party1 (anh Khuê)</h2><p>Cho $N$ bạn nam và $M$ bạn nữ, và $K$ mối
quan hệ nam - nữ. Liệt kê tất cả bạn nam
và bạn nữ chắc chắn sẽ xuất hiện trong
cặp ghép cực đại.</p>
<h4 id="Gioi-han-5"><a href="#Gioi-han-5" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N, M \le 10^4$, $1 \le K \le 10^5$.</p>
<h2 id="Party2-anh-Khue"><a href="#Party2-anh-Khue" class="headerlink" title="Party2 (anh Khuê)"></a>Party2 (anh Khuê)</h2><p>Cho đồ thị $N$ đỉnh $M$ cạnh xanh $K$ cạnh
đỏ, đỉnh $i$ có trọng số $A[i]$.
Chọn một tập điểm có tổng trọng số lớn nhất
thỏa mãn:</p>
<ul>
<li>2 đỉnh có cạnh xanh nối giữa thì không
được cùng chọn.</li>
<li>2 đỉnh có cạnh đỏ nối giữa thì cùng
được chọn, hoặc cùng không được chọn.</li>
</ul>
<p>Đồng thời, đếm số cách chọn tối ưu.</p>
<h4 id="Gioi-han-6"><a href="#Gioi-han-6" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 250$, $0 \le M \le
\frac{N(N-1)}{6}$,
$\frac{N(N-1)}{3} \le K \le
\frac{N(N-1)}{2}$</p>
<h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="Chuyen-doi-bai-toan"><a href="#Chuyen-doi-bai-toan" class="headerlink" title="Chuyển đổi bài toán"></a>Chuyển đổi bài toán</h3><p>Rất khó quản lí trạng thái thắng thua khi
bài toán yêu cầu so sánh số lượng. Vì vậy,
ta sẽ biến đổi bài toán một chút - mặc dù
tính chất thắng - thua không thay đổi.</p>
<p>Thay vì so sánh số lượng <code>d</code> của từng người,
ta lấy số lượng <code>d</code> của người đi trước trừ
đi người đi sau. Hiển nhiên người đi trước
muốn hiệu dương - tức <em>đối đa hóa</em> nó, và
người đi sau muốn tối thiểu hóa nó.</p>
<p>Bởi vì đây là trò chơi hữu hạn bước, và
2 người đều phải chơi tối ưu, nên ta sẽ
chỉ đi tìm một kết quả duy nhất: hiệu tối ưu
của trò chơi, với mỗi cách chọn bước đầu.</p>
<h3 id="Quy-hoach-dong"><a href="#Quy-hoach-dong" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Gọi $f[l][r]$ là hiệu tối ưu của trò chơi,
nếu trò chơi bắt đầu với trạng thái đoạn
$l..r$ bị khuyết. Ta có:</p>
<ul>
<li>Hiển nhiên $f[l][r] = 0$ nếu $l..r$ đã
phủ toàn bộ vòng tròn.</li>
<li>Ta có thể hiểu độ dài $l..r$ sẽ tương
đương với số bước đã xảy ra, vì vậy ta có
thể biết được lượt đi tiếp theo là của ai.</li>
<li>Nếu đây là lượt của người đi trước, hẳn
hắn ta sẽ muốn $f[l][r]$ lớn nhất có thể,
tức hắn sẽ chọn vị trí $l - 1$ hay $r + 1$
sao cho $f[l - 1][r]$ hoặc $f[l][r + 1]$,
cộng vị trí hắn chọn nếu nó màu đỏ,
sao cho tổng ấy lớn nhất có thể. Nói
cách khác ta có:
$$ f[l][r] = \max(f[l - 1][r] +
(\text{S[l - 1] == ‘d’}), f[l][r + 1] +
(\text{S[r + 1] == ‘d’}))$$</li>
<li>Ngược lại, người đi sau sẽ muốn lựa
chọn của mình là nhỏ nhất có thể, tức:
$$ f[l][r] = \min(f[l - 1][r] -
(\text{S[l - 1] == ‘d’}), f[l][r + 1] -
(\text{S[r + 1] == ‘d’}))$$
Lưu ý dấu <code>-</code>, bởi ta đang tối ưu hiệu
người đi trước trừ người đi sau.</li>
</ul>
<p>Ta có thể tính tất cả các hàm $f[1][1]$,
$f[2][2]$, …, $f[N][N]$ trong độ phức
tạp $O(N^2)$.</p>
<h3 id="Dem-vi-tri-tot"><a href="#Dem-vi-tri-tot" class="headerlink" title="Đếm vị trí tốt"></a>Đếm vị trí tốt</h3><p>Một vị trí $i$ thỏa mãn đầu bài nếu như
hiệu tối ưu lớn hơn $0$, bởi khi đó người
thứ nhất luôn có thể làm cho mình có nhiều
<code>d</code> hơn. Như vậy, ta chỉ cần thử hết các
vị trí $i$ và kiểm tra xem $f[i][i] &gt; 0$
đúng không.</p>
<p>Tổng độ phức tạp của bài toán là $O(N^2)$.</p>
<h2 id="eureka"><a href="#eureka" class="headerlink" title="eureka"></a>eureka</h2><h3 id="Tinh-chat-cua-tong-trong-luong"><a href="#Tinh-chat-cua-tong-trong-luong" class="headerlink" title="Tính chất của tổng trọng lượng"></a>Tính chất của tổng trọng lượng</h3><p>Xét một hệ thống cân, không khó để chứng
minh tổng trọng lượng của nó phải là
một bội của số $X$ tương ứng với từng
hệ thống.</p>
<p>Nhiệm vụ của ta là đi tìm $X$ đó cho cả hệ
thống lớn, bằng cách tính từ các hệ thống
con.</p>
<h3 id="Quy-nap"><a href="#Quy-nap" class="headerlink" title="Quy nạp"></a>Quy nạp</h3><p>Hiển nhiên quả cân có thể nhận trọng lượng
bất kì, vậy quả cân là hệ thống cân có $X$
là 1.</p>
<p>Ta xét hệ thống cân $a, b, X_l, X_r$ trong
đó $X_l, X_r$ là các giá trị mình đã tính
trước đó cho hệ thống cân bên trái và phải.
Ta có:</p>
<ul>
<li>Tồn tại $(p, q) = 1$ sao cho $paX_l =
qbX_r$. Hiển nhiên đây là $p$ và $q$ có
tổng nhỏ nhất thỏa mãn.</li>
<li>Khi đó, $X = pX_l + qX_r$.</li>
</ul>
<p>Ta có thể nhận thấy $\frac{p}{q} =
\frac{bX_r}{aX_l}$, vậy $p = bX_r / d$ và
$q = aX_l / d$ với $d = \gcd(aX_l, bX_r)$.
Như vậy $X = \dfrac{X_l X_r(a + b)}{d}$.</p>
<h3 id="So-lon"><a href="#So-lon" class="headerlink" title="Số lớn"></a>Số lớn</h3><p>Ta nhận thấy từ công thức trên rằng
đáp số có thể rất lớn. Ta không cần phải in
số lớn, tuy vậy các phép tính như $\gcd$
không thể được tính khi số đã bị mod.</p>
<p>Tuy nhiên ta cũng không cần phải cài số
lớn: Mỗi lần ta nhân thêm một số $a + b
\le 200$, nên thay vì lưu số lớn ta sẽ
lưu tập ước nguyên tố và số mũ. Khi đó,
các phép nhân (cộng số mũ), chia (trừ
số mũ), lấy $\gcd$ (lấy min số mũ) trở
nên đơn giản, với độ phức tạp $O(A[i])$.</p>
<p>Ta có thuật toán đáp số với độ phức tạp
$O(N * A[i])$.</p>
<h3 id="Cai-dat"><a href="#Cai-dat" class="headerlink" title="Cài đặt"></a>Cài đặt</h3><p>Một cách cài đặt ngắn gọn là sử dụng
đệ quy, vừa đọc vừa làm.
Ta thực hiện lần lượt:</p>
<ul>
<li>Đọc $a$ và kiểm tra xem có phải quả cân
không. Nếu có trả về 1.</li>
<li>Đọc $b$.</li>
<li>Đệ quy giải bên trái $X_l$.</li>
<li>Đệ quy giải bên phải $X_r$.</li>
<li>Tính và trả về $X$.</li>
</ul>
<h2 id="liondance"><a href="#liondance" class="headerlink" title="liondance"></a>liondance</h2><h3 id="Quy-hoach-dong-1"><a href="#Quy-hoach-dong-1" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Về cơ bản, đây chỉ là bài toán LCS có thêm
điều kiện, vì vậy hướng suy nghĩ của ta
tất nhiên là cải thiện thuật toán quy hoạch
động LCS, vì độ phức tạp yêu cầu cũng tương
đương.</p>
<p>Vậy làm sao để quản lí trạng thái vẫn là
$[i][j]$ khi ta còn cần thông tin về 2 phần
tử liên tiếp? Ta sẽ cần “gói” nhiều thông
tin hơn vào trạng thái $(i, j)$.</p>
<h3 id="Them-thong-tin"><a href="#Them-thong-tin" class="headerlink" title="Thêm thông tin!"></a>Thêm thông tin!</h3><p>Ta sẽ định nghĩa hàm quy hoạch động như sau:
Gọi $f[i][j]$ là dãy con chung dài nhất
khi sử dụng đoạn $A[i..N]$, đoạn $B[i + 1..N]$
<strong>và $B[j]$ là phần tử cuối cùng được thêm
ở đầu đoạn</strong> (để đơn giản, ta không tính
cặp $B[j]$ - ?? vào đáp số, cũng như coi $
B[0]$ là phần tử có thể ghép với mọi thứ).</p>
<h4 id="Tai-sao-lai-dinh-nghia-nhu-vay"><a href="#Tai-sao-lai-dinh-nghia-nhu-vay" class="headerlink" title="Tại sao lại định nghĩa như vậy?"></a>Tại sao lại định nghĩa như vậy?</h4><p>Nhờ có việc đánh dấu $B[j]$ là số được thêm
vào cuối cùng, ta có thể quản lí giá trị
có thể thêm vào tiếp theo.
Khi có $f[i][j]$, và $A[i] = B[k]$ ($k \ge
j + 1$), điều kiện duy nhất đẻ kiểm tra
chỉ là $|B[j] - B[k]| \le d$.</p>
<h4 id="Tai-sao-lai-tu-cuoi"><a href="#Tai-sao-lai-tu-cuoi" class="headerlink" title="Tại sao lại từ cuối?"></a>Tại sao lại từ cuối?</h4><p>Để giúp cho việc truy vết thứ tự từ điển,
sau này mình sẽ nói đến.</p>
<p>Ta có thể tính hàm quy hoạch động này như
sau - $f[i][j]$ có thể được tính từ các trạng
thái:</p>
<ul>
<li>$f[i + 1][j]$, hiển nhiên</li>
<li>$f[i + 1][k] + 1$, với $k \ge j + 1$ và
$A[i] = B[k]$.</li>
</ul>
<p>Độ phức tạp là $O(N^3)$. Ta sẽ cần một chút
quan sát để hạ độ phức tạp.</p>
<h3 id="Nhay-xuong-O-N-2"><a href="#Nhay-xuong-O-N-2" class="headerlink" title="Nhảy xuống $O(N^2)$"></a>Nhảy xuống $O(N^2)$</h3><p>Khi xét $f[i][j]$, ta có thể thấy nếu
$k \le k’$ và $A[i] = B[k] = B[k’]$ thì
$f[i + 1][k] \ge f[i + 1][k’]$. Chứng minh
rất đơn giản: $B[k + 1..N]$ dài hơn
$B[k’ + 1..N]$, mà điều kiện ghép không đổi.</p>
<p>Vì vậy, thực chất ta chỉ cần tìm $k$ nhỏ
nhất thỏa mãn $k \ge j + 1$ và $A[i] = B[k]$
để cập nhật vào $f[i][j]$. Việc này có thể
thực hiện bằng việc đánh dấu khi for ngược
$i$ và $j$, nên độ phức tạp chỉ còn $O(N^2)$.</p>
<h3 id="Thu-tu-tu-dien"><a href="#Thu-tu-tu-dien" class="headerlink" title="Thứ tự từ điển"></a>Thứ tự từ điển</h3><p>Khi quy hoạch động $f[i][j]$, ta sẽ lưu thêm
$nx[i][j]$ là chỉ số $B[k]$ mà mình chọn làm
kí tự tiếp theo. Do điều kiện của dãy đáp số
là phụ thuộc vào <em>giá trị</em> chứ không phải
chỉ số, ta sẽ phải thêm vào các điều kiện sau
đây để đảm bảo lựa chọn chỉ số tiếp theo cho
truy vết:</p>
<ul>
<li>Hiển nhiên nếu $f[i + 1][j] \neq f[i + 1][k]$
thì ta chọn cái nào lớn hơn, vì được dãy dài
hơn.</li>
<li>Nếu bằng nhau, hiển nhiên trong $B[nx[i + 1][j]]$
và $B[k]$ cái nào lớn hơn ta chọn.</li>
<li>Nếu vẫn bằng nhau, ta nhận thấy chắc chắn
$nx[i + 1][j] \ge k$, do vậy từ $(i + 1, k)$
ta có nhiều lựa chọn hơn (và có tất cả lựa
chọn của) $(i + 1, nx[i + 1][j])$, nên ta
sẽ chọn $(i + 1, k)$.</li>
</ul>
<p>Khi đã có mảng $nx[i][j]$, việc truy vết trở
thành đơn giản.</p>
<h2 id="desert"><a href="#desert" class="headerlink" title="desert"></a>desert</h2><h3 id="Cay-khung-Manhattan"><a href="#Cay-khung-Manhattan" class="headerlink" title="Cây khung Manhattan"></a>Cây khung Manhattan</h3><p>Bản chất của việc dựng đường đi sao cho
cạnh $\max$ là $\min$ chính là dựng cây khung
nhỏ nhất của đồ thị.</p>
<p>Từ việc chăm chỉ đọc wiki, ta cũng biết có
thể dựng lên cây khung giữa các đỉnh theo
khoảng cách Manhattan với độ phức tạp
$O(N \log N)$. Thực chất đây chỉ là bài
yêu cầu implement thuật toán đó.</p>
<h3 id="Dung-cay-khung-nhu-nao"><a href="#Dung-cay-khung-nhu-nao" class="headerlink" title="Dựng cây khung như nào?"></a>Dựng cây khung như nào?</h3><p>Ta có thể <a href="https://www.topcoder.com/community/data-science/data-science-tutorials/line-sweep-algorithms/" target="_blank" rel="external">chứng minh</a>
rằng, để dựng cây khung Manhattan, với mỗi
điểm ta chỉ cần nối cạnh đến đỉnh gần nó nhất
trong mỗi <a href="https://www.wikiwand.com/en/Octant_(plane_geometry" target="_blank" rel="external">góc phần tám</a>).
Vậy tìm chúng như thế nào?</p>
<h4 id="Tim-diem-gan-nhat-trong-goc-phan-tam"><a href="#Tim-diem-gan-nhat-trong-goc-phan-tam" class="headerlink" title="Tìm điểm gần nhất trong góc phần tám"></a>Tìm điểm gần nhất trong góc phần tám</h4><p>Giả sử ta sẽ giải bài toán cho góc phần tám
có $X \le X_0$, $Y \le Y_0$ và $X - Y \le X_0 - Y_0$.</p>
<p>Ta sắp xếp các điểm theo thứ tự $X_i - Y_i$
giảm dần, và thêm vào một IT có tọa độ được
xếp theo $X_i$ giá trị $X_i + Y_i$ lấy $\max$.</p>
<p>Với mỗi điểm, ta <code>get</code> trong IT giá trị
$X_j + Y_j$ lớn nhất với $X_j \le X_i$, rồi
cập nhật điểm đó vào IT. Điểm <code>get</code> ra
sẽ là điểm gần nhất theo góc phần tám này.</p>
<p>Để hiểu tại sao sắp xếp như vậy lại đúng,
xem hình dưới.</p>
<p><img src="/images/desert_tree_upd.png" alt="Phần được gọi khi xét điểm $A$. Phần
tô màu đã được thêm vào IT, phần màu xanh
thể hiện phần được get trong IT"></p>
<p>Dễ dàng làm với góc phần tám đối diện, chỉ
cần for tập điểm ngược lại.</p>
<h4 id="Giai-nhanh-tat-ca-cac-phan"><a href="#Giai-nhanh-tat-ca-cac-phan" class="headerlink" title="Giải nhanh tất cả các phần"></a>Giải nhanh tất cả các phần</h4><p>Thay vì cài tất cả các trường hợp góc phần
tám, ta có thể chỉ cần giải 2 góc đối diện
như trên, rồi thực hiện <a href="https://quizlet.com/6704360/rotation-rules-for-mrs-nelsons-geometry-flash-cards/" target="_blank" rel="external">phép quay 90 độ</a>
cho tất cả các điểm theo gốc, và tiếp tục giải.</p>
<p>Hiển nhiên sau khi xoay 3 lần ta sẽ giải đủ 8
góc phần tám.</p>
<h2 id="Tron-viec"><a href="#Tron-viec" class="headerlink" title="Trốn việc"></a>Trốn việc</h2><h3 id="Lien-tuong"><a href="#Lien-tuong" class="headerlink" title="Liên tưởng"></a>Liên tưởng</h3><p>Trong một hệ thống $N$ máy song song, ta phải
đảm bảo trong khoảng thời gian $M$ bất kì
không có quá $N$ thao tác được thực hiện trên
bất cứ máy nào.
Ta sẽ làm như nào?</p>
<p>Một cách đơn giản là ra lệnh cho một máy,
sau khi thực hiện một thao tác, sẽ ngủ trong
$M$ giây. Như vậy, không có khoảng thời gian
$M$ nào có một máy chạy 2 lần, vì thế không
có chuyện có nhiều hơn $N$ thao tác được chạy.</p>
<p>Ta sẽ sử dụng ý tưởng này cho bài toán.</p>
<h3 id="Bien-doi-bai-toan"><a href="#Bien-doi-bai-toan" class="headerlink" title="Biến đổi bài toán"></a>Biến đổi bài toán</h3><p>Đề bài yêu cầu ta chọn một tập lớn nhất sao
cho cứ $N$ phần tử liên tiếp bất kì có không
quá $K$ phần tử được chọn. Ta sẽ biến bài
toán thành: Cho phép chạy $K$ máy lựa chọn
song song, mỗi phần tử chỉ được cho một máy
lựa chọn, trong khoảng $N$ bất kì không
có máy nào chọn liên tiếp 2 phần tử.</p>
<p>Nếu $K = 1$, ta có thể sử dụng quy hoạch động
$f[i] = \max(f[i - 1], f[i - N] + A[i])$. Với
$K$ lớn hơn, ta sẽ phải tìm cách khác để đảm
bảo mỗi phần tử chỉ được tối đa một máy lựa chọn.</p>
<p>Hãy tưởng tượng một đường ống $3N + 1$ đoạn liên
tiếp nối thành một đường thẳng. Ngoài ra
đường ống thứ $i$ còn được nối với $\min(
i + N, 3N + 1)$. Từ đỉnh 1 ta cho $K$ robot
chạy về hướng $3N + 1$. Các robot có thể
đi đường $i$ - $i + 1$ thoải mái, nhưng
mỗi đường đi $i$ - $i + N$ chỉ có thể cho
1 robot đi qua, đồng thời sẽ thu về $A[i]$
đồng tiền. Ta cần thu về nhiều tiền nhất
có thể.</p>
<p>Nghe rất giống một bài luồng max cost.</p>
<h3 id="Dung-luong"><a href="#Dung-luong" class="headerlink" title="Dựng luồng"></a>Dựng luồng</h3><p>Ta áp dụng toàn bộ ý tưởng của đường ống vào
luồng.</p>
<ul>
<li>$3N + 2$ đỉnh, $0$ là nguồn $3N + 1$ là đích.</li>
<li>$0$ =&gt; $1$: cap = $K$, cost = $0$</li>
<li>Với $i &gt; 0$, $i$ =&gt; $i + 1$: cap = $inf$, cost = $0$</li>
<li>Với $i &gt; 0$, $i$ =&gt; $\min(i + N, 3N + 1)$: cap = $1$, cost = $A[i]$</li>
</ul>
<p>Trên mạng, ta tìm luồng max cost. Hiển nhiên
luồng cực đại là $K$, nhưng ta chỉ cần quan
tâm đến cost tối đa. Cost chính là đáp số.</p>
<p>Độ phức tạp là <code>O(luồng 600 đỉnh 1000 cạnh)</code>.</p>
<h2 id="Party1"><a href="#Party1" class="headerlink" title="Party1"></a>Party1</h2><h3 id="Thay-doi-muc-tieu"><a href="#Thay-doi-muc-tieu" class="headerlink" title="Thay đổi mục tiêu"></a>Thay đổi mục tiêu</h3><p>Thay vì đi tìm những đỉnh mà xuất hiện trong
mọi cặp ghép cực đại, ta sẽ tìm những đỉnh
không có tính chất đó. Thật vậy, ta sẽ cần
tìm những đỉnh mà khi bỏ nó đi, kích cỡ cặp ghép
cực đại vẫn không thay đổi.</p>
<h3 id="Tinh-chat-cua-cap-ghep"><a href="#Tinh-chat-cua-cap-ghep" class="headerlink" title="Tính chất của cặp ghép"></a>Tính chất của cặp ghép</h3><p>Đầu tiên, ta dựng cặp ghép cực đại trên đồ thị
đã cho. Hiển nhiên các đỉnh không thuộc cặp
ghép là các đỉnh cần tìm. Ta sẽ chỉ xét đến
các đỉnh thuộc cặp ghép.</p>
<p>Giả sử $v_0$ là một đỉnh không được ghép.
Xét đường tăng $v_0, v_1,…, v_{2k}$. Hiển
nhiên độ dài đường tăng phải chẵn, nếu không
ta có thể tăng số cặp ghép, không thỏa mãn
tính chất cặp ghép cực đại.</p>
<p>Ta nhận thấy, nếu xóa đi 1 trong các đỉnh
$v_2, v_4, …,v_{2k}$, ta sẽ tách đường tăng
hiện tại ra thành 1 đường tăng lẻ, đồng thời số cặp ghép giảm đi 1.
Tuy nhiến, do tồn tại đường tăng lẻ nên ta
có thể đảo lại, làm tăng số cặp ghép về như
cũ. Vì vậy $v_2, v_4, …, v_{2k}$ đều là
các đỉnh cần tìm.</p>
<p>Nếu một đỉnh $x$ khi xóa đi không tạo ra
đường tăng lẻ nào (nhưng làm giảm số cặp ghép),
chắc chắn nó không phải đỉnh cần tìm.</p>
<p><img src="/images/party1_exp.png" alt="Các cạnh xanh là cạnh cặp ghép. Xét
đường tăng DHCGBFA (tím xanh), nếu bỏ B, đường tăng
DHCG sẽ là đường lẻ, tăng cặp ghép về như cũ.
Tương tự với C và A. Đường tăng JEI (xanh dương-xanh) cũng vậy."></p>
<h3 id="Thuat-toan"><a href="#Thuat-toan" class="headerlink" title="Thuật toán"></a>Thuật toán</h3><p>Trước tiên, tìm cặp ghép. Sau đó, ta BFS từ các
đỉnh không được cặp ghép, đi theo các đường tăng,
đánh dấu các đỉnh cùng phía được thăm.</p>
<p>Do tính chất của đồ thị 2 phía nên ta chỉ cần 2
lần BFS, mỗi lần xuất phát từ tất cả các đính
không được thăm trên cùng 1 phía.</p>
<p>Độ phức tạp sẽ là $O(K \sqrt{N + M})$ do cặp
ghép.</p>
<h2 id="Party2"><a href="#Party2" class="headerlink" title="Party2"></a>Party2</h2><h3 id="Nen-do-thi"><a href="#Nen-do-thi" class="headerlink" title="Nén đồ thị"></a>Nén đồ thị</h3><p>Với tập đỉnh đỏ, ta sẽ gộp tất cả các đỉnh liên
thông lại thành một, cộng tất cả các trọng số lại.
Bài toán trở thành tìm tập độc lập cực đại trên
đồ thị cạnh xanh.</p>
<p>Đây là một bài <strong>NP-Hard</strong>, chưa thể giải với
giới hạn $N \le 250$.</p>
<h3 id="So-luong-dinh"><a href="#So-luong-dinh" class="headerlink" title="Số lượng đỉnh"></a>Số lượng đỉnh</h3><p>Một chi tiết quan trọng là số lượng cạnh đỏ
rất lớn. Với $N = 250$ và $K = \frac{N(N-1)}{3}$,
chỉ có tối đa $46$ đỉnh đã gộp (bao gồm 205
đỉnh có clique và 45 đỉnh bậc 0).</p>
<p>Từ đây, ta có chút hi vọng với thuật backtrack.</p>
<h3 id="Dat-can"><a href="#Dat-can" class="headerlink" title="Đặt cận!"></a>Đặt cận!</h3><p>Đây là danh sách cận cần thiết để hi vọng qua
được đống test(?):</p>
<ul>
<li>Sort các đỉnh theo bậc rồi backtrack dần</li>
<li>Xử lí nhanh các đỉnh bị cấm</li>
<li>Loại bỏ các trường hợp khi tổng các đỉnh còn
lại không lớn hơn max hiện tại</li>
<li>Tính riêng các tplt rồi nhân với nhau</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://natsukagami.github.io/2017/04/28/2017-04-28-Training/" data-id="cj21sa4po00008t2bvndb6m8v" class="article-share-link">Chia sẻ</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/anh-Khue/">anh Khuê</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/apio/">apio</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thay-Hoang/">thầy Hoàng</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/training/">training</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vietnamese/">vietnamese</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-04-25-Training" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/25/2017-04-25-Training/" class="article-date">
  <time datetime="2017-04-25T13:00:00.000Z" itemprop="datePublished">2017-04-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Training/">Training</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/25/2017-04-25-Training/">2017/04/25 Training</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Hôm nay có khá nhiều bài trí tuệ.</p>
<h1 id="Tom-tat-de-bai"><a href="#Tom-tat-de-bai" class="headerlink" title="Tóm tắt đề bài"></a>Tóm tắt đề bài</h1><h2 id="wash"><a href="#wash" class="headerlink" title="wash"></a>wash</h2><p>Cho $N$ máy giặt và $M$ máy sấy chạy song song,
thời gian giặt là $A[1..N]$, sấy là $B[1..M]$ cho
từng máy. Tìm thời gian nhỏ nhất để giặt xong
$L$ quần áo.</p>
<h4 id="Gioi-han"><a href="#Gioi-han" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N, M \le 10^5$, $1 \le L \le 10^6$,
$1 \le A[i], B[i] \le 10^9$.</p>
<h2 id="mars"><a href="#mars" class="headerlink" title="mars"></a>mars</h2><p>Cho $N$ nhà kho với sức chứa $C[1..N]$, ban
đầu các nhà kho rỗng. Trong ngày thứ $i$
($1 \le i \le D$), nhà kho $j$ nhận thêm
$A[i][j]$ món hàng, đồng thời bạn được chuyển
tổng cộng $d[i]$ món hàng ra khỏi các nhà kho.
Việc chuyển ra được thực hiện sau khi nhận
hàng. Hỏi sau $N$ ngày liệu có thể chuyển
tất cả hàng hóa đã nhận không?</p>
<h4 id="Gioi-han-1"><a href="#Gioi-han-1" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N, D \le 30$,
$1 \le C[i], A[i][j], d[i] \le 10^6$</p>
<h2 id="government"><a href="#government" class="headerlink" title="government"></a>government</h2><p>Cho $N$ điểm, điểm $i$ có trọng số $A[i]$.
Tìm cách đặt các điểm vào các tọa độ nguyên
của đoạn thẳng $[1..M]$ (mỗi tọa độ chứa
không quá 1 điểm) để tối đa hóa:
$$\sum\limits_{i = 1}^N \sum\limits_{j = i + 1}
^N |x_i - x_j| \times A[i] \times A[j]$$</p>
<p>Với $x_i$ là tọa độ điểm $i$.</p>
<h4 id="Gioi-han-2"><a href="#Gioi-han-2" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le M \le 10^6$, $1 \le N \le 1000$,
$1 \le A[i] \le 100$.</p>
<h2 id="permutation"><a href="#permutation" class="headerlink" title="permutation"></a>permutation</h2><p>Xét một hoán vị $P$, gọi $R[i]$ là bán kính của
$P_i$ nếu $R[i]$ là số lớn nhất thỏa mãn:</p>
<ul>
<li>$1 \le i - R[i]$ và $i + R[i] \le N$</li>
<li>$P_j &lt; P_i$ với mọi $i - R[i] \le j &lt; i$</li>
<li>$P_j &lt; P_i$ với mọi $i &lt; j \le i + R[i]$</li>
</ul>
<p>Cho số $N$ và dãy $R[1..N]$, đếm số hoán vị
$P$ độ dài $N$ có bán kính của $P_i$ là $R[i]$
với mọi $1 \le i \le N$.</p>
<h4 id="Gioi-han-3"><a href="#Gioi-han-3" class="headerlink" title="Giới hạn"></a>Giới hạn</h4><p>$1 \le N \le 1000$.</p>
<h1 id="Loi-giai"><a href="#Loi-giai" class="headerlink" title="Lời giải"></a>Lời giải</h1><h2 id="wash-1"><a href="#wash-1" class="headerlink" title="wash"></a>wash</h2><h3 id="Tham-lam-tren-mot-may"><a href="#Tham-lam-tren-mot-may" class="headerlink" title="Tham lam trên một máy"></a>Tham lam trên một máy</h3><p>Giả sử bài toán chỉ có một loại máy (máy giặt
chẳng hạn, phơi thôi sấy làm gì tốn điện), ta
có thể sử dụng thuật toán tham lam: Với mỗi
bước ta chọn máy giặt mà có <strong>thời điểm hoàn
thành đồ tiếp theo</strong> (không phải đồ máy đó
đang giặt - nếu có) là nhỏ nhất.</p>
<p>Không khó để chứng minh thuật toán này là tối
ưu. Việc cài đặt cũng không khó khăn, chỉ
cần sử dụng 1 <code>priority_queue</code>.</p>
<p>Độ phức tạp là $O(L \log N)$.</p>
<p>Mạnh hơn thế, thuật toán này cho ta không
chỉ đáp án tối ưu, mà từng phần tử cũng tối
ưu: <strong>Không thể giặt đồ thứ $i$ xong
trước thời điểm $T[i]$.</strong></p>
<h3 id="Chat-nhi-phan-ket-qua"><a href="#Chat-nhi-phan-ket-qua" class="headerlink" title="Chặt nhị phân kết quả"></a>Chặt nhị phân kết quả</h3><p>Theo tính chất bài toán, ta có thể chặt nhị
phân kết quả. Bài toán trở thành kiểm tra,
liệu trong thời gian $X$ có thể giặt và
sấy $L$ quần áo không?</p>
<p>Để kiểm tra, đầu tiên ta sẽ tham lam theo thuật
toán trên để có tập thời gian giặt xong của
từng đồ, $T[i]$.</p>
<p>Sau đó, ta “lật ngược” trục trời gian lại,
xuất phát từ thời điểm $L$ và thực hiện tính
tập thời gian sấy $V[i]$, <em>cũng bằng thuật
tham lam trên</em>. Tại sao thuật tham lam vẫn
đúng? Tại vì, với mỗi máy, ta chỉ cần đảo
ngược thứ tự sấy các đồ của máy đó là tổng
thời gian vẫn không đổi, các đồ được sấy
đúng thứ tự xuôi trục thời gian.</p>
<p>Việc cuối cùng là dựng lên cặp ghép $T[i]$ - $V[i]$
sao cho $i$ ghép với $j$ thì $T[i] + V[j] &lt; X$.
Ta có thể tưởng tượng là giặt mất $T[i]$,
đợi đến $X - V[j]$ rồi sấy mất $V[j]$.</p>
<p>Hiển nhiên cách ghép tối ưu nhất là ghép $T[i]$
nhỏ nhất với $V[j]$ lớn nhất, nhỏ nhì với lớn
nhì và vân vân…</p>
<p>Ta có thuật toán $O(L \log N \log 10^{15})$,
chưa đủ mạnh.</p>
<h3 id="Khu-chat-nhi-phan"><a href="#Khu-chat-nhi-phan" class="headerlink" title="Khử chặt nhị phân"></a>Khử chặt nhị phân</h3><p>Ta nhận thấy việc tính mảng $T[i]$ và $V[i]$
không liên quan đến việc chặt nhị phân, vì
thế thực chất việc chặt nhị phân của ta
chỉ là tìm giá trị max của việc ghép cặp.</p>
<p>Như vậy, không cần chặt nhị phân, ta chỉ
cần tìm 2 mảng trên, thực hiện ghép cặp
rồi tìm giá trị max.</p>
<p>Độ phức tạp là $O(L \log N)$.</p>
<h2 id="mars-1"><a href="#mars-1" class="headerlink" title="mars"></a>mars</h2><h3 id="Luong"><a href="#Luong" class="headerlink" title="Luồng"></a>Luồng</h3><p>Ta có thể để ý, đề bài gồm một số đầu vào,
một số đầu ra và yêu cầu kiểm tra xem
có thể truyền từ đầu vào sang đầu ra không.
Đây chính là đặc điểm của bài toán luồng
cực đại - vì thế đây là bài luồng cơ bản.</p>
<p>Ngoài ra, giới hạn nhỏ của đề bài cũng
ủng hộ ý tưởng luồng.</p>
<h3 id="Dung-luong-nhu-the-nao"><a href="#Dung-luong-nhu-the-nao" class="headerlink" title="Dựng luồng như thế nào?"></a>Dựng luồng như thế nào?</h3><ul>
<li>Với mỗi ngày ta chỉ có thể giữ lại $C_i$
đơn vị ở nhà kho $i$ =&gt; Ta sẽ cần phải
dựng đỉnh quản lí $V[i][j]$ quản lí nhà
kho $i$ trong ngày $j$, từ $V[i][j]$ đi
đến $V[i][j + 1]$ với capacity $C_i$.</li>
<li>Trong ngày $i$ chỉ được chuyển $D_i$
đơn vị =&gt; Ta dựng đỉnh $Q[i]$ quản lí
lượng chuyển ra trong ngày $i$. Từ $Q[i]$
đến đích có capacity $D_i$, từ các
$V[i][j]$ đến $Q[j]$ có capacity vô tận.</li>
<li>Kho $j$ ngày $i$ tăng thêm $A[i][j]$ đơn
vị =&gt; từ nguồn vào $V[i][j]$ có capacity
$A[i][j]$.</li>
<li>Chuyển vào trước khi chuyển ra:
để xử lí phần này ta cần tách $V[i][j]$
thành $V_in[i][j]$ và $V_out[i][j]$,
từ $V_out[i][j - 1]$ vào $V_in[i][j]$
như trên, $V_out[i][j]$ vào $Q[j]$ như
trên và $V_in[i][j]$ vào $V_out[i][j]$
có capacity $C_i$.</li>
</ul>
<p>Sau đó ta tìm luồng cực đại và kiểm tra
nó có bằng tổng $A[i][j]$ không.</p>
<p>Độ phức tạp là <code>O(luồng 2000 đỉnh 2000 cạnh)</code>.</p>
<h2 id="government-1"><a href="#government-1" class="headerlink" title="government"></a>government</h2><h3 id="Bien-doi-cong-thuc"><a href="#Bien-doi-cong-thuc" class="headerlink" title="Biến đổi công thức"></a>Biến đổi công thức</h3><p>Ta có thể hiểu công thức chính là khoảng cách
có trọng số của từng cặp. Sử dụng công thức
này có điểm bất lợi là có quá nhiều biến.
Ta sẽ biến đổi công thức một chút.</p>
<p>Giả sử các điểm $1..N$ đã được xếp từ trái
sang phải, đáp số sẽ là
$$ \sum\limits_{i = 1}^{N - 1}(x_{i + 1} - x_i)
(\sum\limits_{j = 1}^i A[j])
(\sum\limits_{k = i + 1}^N A[k])$$</p>
<p>Với mỗi đoạn liên tiếp, số lần nó bị tính
vào đáp số sẽ là tổng trọng số những điểm
bến trái nó nhân với tổng trọng số những
điểm bên phải.</p>
<h3 id="Don-ve-2-ben"><a href="#Don-ve-2-ben" class="headerlink" title="Dồn về 2 bên"></a>Dồn về 2 bên</h3><p>Giả sử ta đã có thứ tự các số $A[i]$, vậy
đặt chúng vào đâu thì hợp lí nhất?</p>
<p>Dựa theo công thức phía trên, ta có: </p>
<ul>
<li>Tổng các $(x_{i + 1} - x_i)$ không quá $M$.
Vì ta cần tối đa hóa nên ta coi tổng là
$M$ luôn.</li>
<li>Vị trí có phần tích $A[i]$ lớn nhất là
khi tổng bên trái và bên phải gần nhau nhất.
Gọi vị trí này là $(x_{l + 1} - x_l)$.</li>
</ul>
<p>Từ đây ta suy ra luôn có thể tối đa hóa đáp
án bằng cách tối đa hóa đoạn $l$, tức cho
$(x_{l + 1} - x_l) = M - N + 1$ và các đoạn
còn lại là 1. Nói cách khác, ta sẽ dồn tập
điểm về 2 bên sao cho tổng trọng số của
chúng gần nhau nhất, tức $l$ lớn nhất
thỏa mãn tổng $A[1..l - 1]$ bé hơn nửa tổng.</p>
<h3 id="Thu-tu-cua-tung-ben"><a href="#Thu-tu-cua-tung-ben" class="headerlink" title="Thứ tự của từng bên"></a>Thứ tự của từng bên</h3><p>Giả sử ta biết tập con của từng bên, làm
sao để tìm thứ tự sắp xếp của chúng?</p>
<p>Xét tập bên trái $A[1..k]$.
Dễ dàng nhìn
thấy phần đáp số của các đoạn trong tập
chính là
$$A[1] \times (S - A[1]) +
(A[1] + A[2]) \times (S - A[1] - A[2]) + … +
(A[1] + … + A[k - 1]) \times (S + A[k])$$</p>
<p>Ta nhận thấy $A[1]$, $A[1] + A[2]$, …
đều sẽ nhỏ hơn số hạng còn lại tương ứng
(theo nhận xét phía trên), vì vậy để
tổng các tích này max, thì $A[1]$, $A[1] + A[2]$,
…, $A[1] + … + A[k - 1]$ đều phải
lớn nhất có thể. Vậy dãy $A[1..K]$ phải được
sắp xếp giảm dần.</p>
<p>Tương tự ta sẽ chứng minh được dãy bên phải
phải được sắp xếp <strong>tăng</strong> dần.</p>
<h3 id="Quy-hoach-dong"><a href="#Quy-hoach-dong" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Khi đã biết sắp xếp các phần tử, ta đã có
thứ tự quy hoạch động: ta sẽ thêm dần các
phần tử vào bên trái hoặc bên phải, theo
thứ tự $A[i]$ giảm dần.</p>
<p>Để có thể vận dụng công thức tính phần giữa,
trong hàm qhđ ta cần lưu lại tổng của 1 bên.</p>
<p>Ta có $f[i][j]$ là tổng đáp số của 2 tập, sao
cho tập bên trái có tổng là $j$, cả 2 tập
gồm các phần tử từ 1 đến $i$, lớn nhất.
Ta chuyển trạng thái từ $f[i][j]$ bằng cách
chọn $i + 1$ vào tập trái hay phải:</p>
<ul>
<li>Sang trái: chuyển sang $f[i + 1][j + A[i + 1]]$,
tổng tăng thêm $j \times (S - j)$.</li>
<li>Sang phải: chuyển sang $f[i + 1][j]$, tổng
tăng thêm: $(S[i] - j) * (S - S[i] + j)$, với
$S[i]$ là tổng $A[1..i]$.</li>
</ul>
<p>Đáp số sẽ là
$$ \max\limits_{i = 0}^{S}(f[N][i] + (M - N + 1)
\times i \times (S - i))$$</p>
<p>Độ phức tạp là $O(N^2 * A[i])$.</p>
<h2 id="permutation-1"><a href="#permutation-1" class="headerlink" title="permutation"></a>permutation</h2><h3 id="Vi-tri-dat-so-N"><a href="#Vi-tri-dat-so-N" class="headerlink" title="Vị trí đặt số $N$"></a>Vị trí đặt số $N$</h3><p>Xét dãy $R_i$. Ta nhận thấy số $N$ có thể đặt
ở $i$ khi và chỉ khi:</p>
<ul>
<li>$R_i$ phủ đến 1 hoặc đến $N$.</li>
<li>Không có $R_j$ nào phủ $i$.</li>
</ul>
<p>Giả sử ta có một vị trí thỏa mãn $x$. Nếu
đặt $x$ ở $N$, ta nhận thấy không có $j &lt; x$
nào mà $R_j$ phủ qua $x$, cũng như không
có $j &gt; x$ nào thỏa mãn. Vì thế $R[1..x - 1]$
và $R[x + 1..N]$ trở thành 2 bài toán riêng
biệt.</p>
<p>Ta có thể giải riêng 2 bài toán này, nhân
số cách với nhau, cùng với số cách chọn
$x - 1$ số trong $N - 1$ số cho tập bên trái
(và các số còn lại trong tập bên phải),
tức $C^{x - 1}_{N - 1}$.</p>
<h3 id="Quy-hoach-dong-1"><a href="#Quy-hoach-dong-1" class="headerlink" title="Quy hoạch động"></a>Quy hoạch động</h3><p>Gọi $f[i][j]$ là số cách điền các số hoán vị
thỏa mãn $R[i..j]$. Ta có:</p>
<ul>
<li>$x$ được gọi là thỏa mãn $i..j$ nếu:<ul>
<li>$i \le x \le j$</li>
<li>$R_x$ phủ $i$ hoặc phủ $j$</li>
<li>Không tồn tại $i \le k \le j$, $k \neq x$
mà $R_k$ phủ $x$.</li>
</ul>
</li>
<li>Ta định nghĩa đoạn đúng:<ul>
<li>$R[1..N]$ là đoạn đúng nếu không có
2 cặp nào phủ nhau.</li>
<li>Đoạn rỗng là đoạn đúng.</li>
<li>Nếu $R[i..j]$ đúng và $x$ thỏa mãn
$i..j$ thì $R[i..x-1]$ và $R[x+1..j]$
là đoạn đúng.</li>
</ul>
</li>
<li>$f[i][j] = 1$ nếu $R[i..j]$ là đoạn đúng
và $i = j$ hoặc $i = j + 1$.</li>
<li>$f[i][j] = \sum\limits_{x \text{ t/m } i..j}
f[i][x - 1] \times f[x + 1][j] \times C^{x - 1}_{N - 1}$</li>
</ul>
<p>Đáp số là $f[1][N]$. Độ phức tạp là $O(N^3)$,
do với mỗi đoạn ta cần tìm $x$ thỏa mãn.</p>
<p>Ta sẽ tối ưu việc lựa chọn này.</p>
<h3 id="So-luong-x-thoa-man"><a href="#So-luong-x-thoa-man" class="headerlink" title="Số lượng $x$ thỏa mãn"></a>Số lượng $x$ thỏa mãn</h3><p>Xét đoạn $i..j$. Gọi $L[i][j]$ là $k \le j$ lớn
nhất thỏa mãn $R[k]$ phủ $i$, $R[i][j]$
là $k \ge i$ nhỏ nhất thỏa mãn $R[k]$ phủ $j$.
Hiển nhiên $L[i][j]$ phủ tất cả các số
phủ $i$ đứng trước nó, $R[i][j]$ phủ tất
cả các số phủ $j$ đứng sau nó. Vậy chỉ có
$L[i][j]$ hoặc $R[i][j]$ có thể thỏa mãn.</p>
<p>Ta có thể tính được 2 mảng này trong
$O(N^2)$, việc còn lại là kiểm tra tính
thỏa mãn của 2 phần tử này.</p>
<h3 id="Kiem-tra-thoa-man"><a href="#Kiem-tra-thoa-man" class="headerlink" title="Kiểm tra thỏa mãn"></a>Kiểm tra thỏa mãn</h3><p>Ta còn điều kiện thỏa mãn: Không có phần
tử nào cùng đoạn phủ nó. Ta có thể dựng mảng
tính như sau:</p>
<ul>
<li>$S[i][j] = 1$ nếu $i$ phủ $j$ và 0 nếu không.</li>
<li>Ta có thể for trâu từng số và đánh dấu, tổng
độ phức tạp sẽ là $O(N^2 \log N)$ do tính chất
của bán kính.</li>
<li>Khi kiểm tra ta cần tính tổng $S[x][i..j]$.
Ta có thể sử dụng mảng tổng dồn để lấy tổng
trong $O(1)$.</li>
</ul>
<p>Như vậy ta có thuật toán $O(N^2 \log N)$.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://natsukagami.github.io/2017/04/25/2017-04-25-Training/" data-id="cj1z8w5rv000lb32bscdonn6k" class="article-share-link">Chia sẻ</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/anh-Minh/">anh Minh</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/apio/">apio</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/training/">training</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vietnamese/">vietnamese</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Các chủ đề</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Editorials/">Editorials</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Thoughts/">Thoughts</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Training/">Training</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Các nhãn</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/First-Post/">First Post</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Training/">Training</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anh-Hanh/">anh Hạnh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anh-Khue/">anh Khuê</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/anh-Minh/">anh Minh</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apio/">apio</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/editorial/">editorial</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/english/">english</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hsgso/">hsgso</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thay-Hoang/">thầy Hoàng</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thay-Nghia/">thầy Nghĩa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thay-Phuong/">thầy Phương</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thay-Dong/">thầy Đông</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/training/">training</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vietnamese/">vietnamese</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tập hợp nhãn</h3>
    <div class="widget tagcloud">
      <a href="/tags/First-Post/" style="font-size: 10px;">First Post</a> <a href="/tags/Training/" style="font-size: 10px;">Training</a> <a href="/tags/anh-Hanh/" style="font-size: 13.33px;">anh Hạnh</a> <a href="/tags/anh-Khue/" style="font-size: 10px;">anh Khuê</a> <a href="/tags/anh-Minh/" style="font-size: 13.33px;">anh Minh</a> <a href="/tags/apio/" style="font-size: 20px;">apio</a> <a href="/tags/editorial/" style="font-size: 10px;">editorial</a> <a href="/tags/english/" style="font-size: 10px;">english</a> <a href="/tags/hsgso/" style="font-size: 10px;">hsgso</a> <a href="/tags/thay-Hoang/" style="font-size: 10px;">thầy Hoàng</a> <a href="/tags/thay-Nghia/" style="font-size: 10px;">thầy Nghĩa</a> <a href="/tags/thay-Phuong/" style="font-size: 13.33px;">thầy Phương</a> <a href="/tags/thay-Dong/" style="font-size: 10px;">thầy Đông</a> <a href="/tags/training/" style="font-size: 16.67px;">training</a> <a href="/tags/vietnamese/" style="font-size: 20px;">vietnamese</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Lưu trữ</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">tháng 5 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">tháng 4 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">tháng 10 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Các bài gần đây</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/03/2017-05-03-Training/">2017-05-03 Training</a>
          </li>
        
          <li>
            <a href="/2017/05/01/HSGSO-2016-Editorial/">HSGSO 2016 Editorial</a>
          </li>
        
          <li>
            <a href="/2017/04/28/2017-04-28-Training/">2017/04/28 Training</a>
          </li>
        
          <li>
            <a href="/2017/04/25/2017-04-25-Training/">2017/04/25 Training</a>
          </li>
        
          <li>
            <a href="/2017/04/24/2017-04-24-Training/">2017/04/24 Training</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Natsu Kagami<br>
      Được tạo ra bởi <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>